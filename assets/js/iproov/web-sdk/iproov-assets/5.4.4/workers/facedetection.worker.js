(()=>{var t={853:(t,e,n)=>{var r,a=(r=(r="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return P.buffer!=R&&q(P.buffer),I}function a(){return P.buffer!=R&&q(P.buffer),M}function s(){return P.buffer!=R&&q(P.buffer),L}function o(){return P.buffer!=R&&q(P.buffer),z}function i(){return P.buffer!=R&&q(P.buffer),V}var u,l,c,d="undefined"!=typeof(t=t||{})?t:{};d.ready=new Promise((function(t,e){u=t,l=e})),"undefined"!=typeof process&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var p,m,f,h=Object.assign({},d),y=[],b=(t,e)=>{throw e},g="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,v=d.ENVIRONMENT_IS_PTHREAD||!1,T="";function S(t){return d.locateFile?d.locateFile(t,T):T+t}if(_){var N=n(465),x=n(981);let t;T=w?x.dirname(T)+"/":"//",p=(t,e)=>(t=st(t)?new URL(t):x.normalize(t),N.readFileSync(t,e?void 0:"utf8")),f=t=>{var e=p(t,!0);return e.buffer||(e=new Uint8Array(e)),e},m=(t,e,n)=>{t=st(t)?new URL(t):x.normalize(t),N.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),y=process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ut))throw t})),process.on("unhandledRejection",(function(t){throw t})),b=(t,e)=>{if(K())throw process.exitCode=t,e;var n;(n=e)instanceof ut||E("exiting due to exception: "+n),process.exit(t)},d.inspect=function(){return"[Emscripten Module object]"};try{t=n(880)}catch(t){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),t}n.g.Worker=t.Worker}else(g||w)&&(w?T=self.location.href:"undefined"!=typeof document&&document.currentScript&&(T=document.currentScript.src),"undefined"!=typeof r&&r&&(T=r),T=0!==T.indexOf("blob:")?T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(f=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),m=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(520).performance);var k=console.log.bind(console),C=console.warn.bind(console);_&&(k=t=>N.writeSync(1,t+"\n"),C=t=>N.writeSync(2,t+"\n"));var A,D=d.print||k,E=d.printErr||C;Object.assign(d,h),h=null,d.arguments&&(y=d.arguments),d.thisProgram&&d.thisProgram,d.quit&&(b=d.quit),Atomics.load,Atomics.store,Atomics.compareExchange,d.wasmBinary&&(A=d.wasmBinary);var P,F,$=d.noExitRuntime||!0;"object"!=typeof WebAssembly&&rt("no native wasm support detected");var O,R,I,M,L,z,V,B=!1,U="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function W(t,e,n){for(var r=(e>>>=0)+n,a=e;t[a]&&!(a>=r);)++a;if(a-e>16&&t.buffer&&U)return U.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,a):t.subarray(e,a));for(var s="";e<a;){var o=t[e++];if(128&o){var i=63&t[e++];if(192!=(224&o)){var u=63&t[e++];if((o=224==(240&o)?(15&o)<<12|i<<6|u:(7&o)<<18|i<<12|u<<6|63&t[e++])<65536)s+=String.fromCharCode(o);else{var l=o-65536;s+=String.fromCharCode(55296|l>>10,56320|1023&l)}}else s+=String.fromCharCode((31&o)<<6|i)}else s+=String.fromCharCode(o)}return s}function j(t,e){return(t>>>=0)?W(a(),t,e):""}function q(t){R=t,d.HEAP8=I=new Int8Array(t),d.HEAP16=new Int16Array(t),d.HEAP32=L=new Int32Array(t),d.HEAPU8=M=new Uint8Array(t),d.HEAPU16=new Uint16Array(t),d.HEAPU32=z=new Uint32Array(t),d.HEAPF32=new Float32Array(t),d.HEAPF64=V=new Float64Array(t)}v&&(R=d.buffer);var H,G=d.INITIAL_MEMORY||16777216;if(v)P=d.wasmMemory,R=d.buffer;else if(d.wasmMemory)P=d.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:G/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw E("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&E("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");P&&(R=P.buffer),G=R.byteLength,q(R);var Q=[],X=[],J=[];function K(){return $}function Z(){v||ft(X)}var Y,tt=0,et=null,nt=null;function rt(t){d.onAbort&&d.onAbort(t),E(t="Aborted("+t+")"),B=!0,O=1,t+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(t);throw l(e),e}function at(t){return t.startsWith("data:application/octet-stream;base64,")}function st(t){return t.startsWith("file://")}function ot(t){try{if(t==Y&&A)return new Uint8Array(A);if(f)return f(t);throw"both async and sync fetching of the wasm failed"}catch(t){rt(t)}}at(Y="tfjs-backend-wasm-threaded-simd.wasm")||(Y=S(Y));var it={};function ut(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function lt(t){var e,n=mt.pthreads[t];n||rt(e),mt.returnWorkerToPool(n)}function ct(t){var e=mt.getNewWorker();if(!e)return 6;mt.runningWorkers.push(e),mt.pthreads[t.pthread_ptr]=e,e.pthread_ptr=t.pthread_ptr;var n={cmd:"run",start_routine:t.startRoutine,arg:t.arg,pthread_ptr:t.pthread_ptr};return e.runPthread=()=>{_&&e.ref(),e.postMessage(n,t.transferList),delete e.runPthread},e.loaded&&e.runPthread(),0}function dt(t){if(v)return Tt(1,1,t);O=t,K()||(mt.terminateAllThreads(),d.onExit&&d.onExit(t),B=!0),b(t,new ut(t))}var pt=function(t,e){if(O=t,!e&&v)throw ht(t),"unwind";dt(t)},mt={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){v?mt.initWorker():mt.initMainThread()},initMainThread:function(){for(var t=8;t--;)mt.allocateUnusedWorker()},initWorker:function(){$=!1},setExitStatus:function(t){O=t},terminateAllThreads:function(){for(var t of Object.values(mt.pthreads))mt.returnWorkerToPool(t);for(var t of mt.unusedWorkers)t.terminate();mt.unusedWorkers=[]},returnWorkerToPool:function(t){var e=t.pthread_ptr;delete mt.pthreads[e],mt.unusedWorkers.push(t),mt.runningWorkers.splice(mt.runningWorkers.indexOf(t),1),t.pthread_ptr=0,_&&t.unref(),Bt(e)},receiveObjectTransfer:function(t){},threadInitTLS:function(){mt.tlsInitFunctions.forEach((t=>t()))},loadWasmModuleToWorker:function(t,e){t.onmessage=n=>{var r,a=n.data,s=a.cmd;if(t.pthread_ptr&&(mt.currentProxiedOperationCallerThread=t.pthread_ptr),a.targetThread&&a.targetThread!=Mt()){var o=mt.pthreads[a.targetThread];return o?o.postMessage(a,a.transferList):E('Internal error! Worker sent a message "'+s+'" to target pthread '+a.targetThread+", but that thread no longer exists!"),void(mt.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===s?_t(a.queue):"spawnThread"===s?ct(a):"cleanupThread"===s?lt(a.thread):"killThread"===s?function(t){var e=mt.pthreads[t];delete mt.pthreads[t],e.terminate(),Bt(t),mt.runningWorkers.splice(mt.runningWorkers.indexOf(e),1),e.pthread_ptr=0}(a.thread):"cancelThread"===s?(r=a.thread,mt.pthreads[r].postMessage({cmd:"cancel"})):"loaded"===s?(t.loaded=!0,_&&t.unref(),e&&e(t),t.runPthread&&t.runPthread()):"print"===s?D("Thread "+a.threadId+": "+a.text):"printErr"===s?E("Thread "+a.threadId+": "+a.text):"alert"===s?alert("Thread "+a.threadId+": "+a.text):"setimmediate"===a.target?t.postMessage(a):"callHandler"===s?d[a.handler](...a.args):s&&E("worker sent an unknown command "+s),mt.currentProxiedOperationCallerThread=void 0},t.onerror=t=>{throw E("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){})));var n=[];for(var a of["onExit","onAbort","print","printErr"])d.hasOwnProperty(a)&&n.push(a);t.postMessage({cmd:"load",handlers:n,urlOrBlob:d.mainScriptUrlOrBlob||r,wasmMemory:P,wasmModule:F})},allocateUnusedWorker:function(){var t,e=S("tfjs-backend-wasm-threaded-simd.worker.js");t=new Worker(e),mt.unusedWorkers.push(t)},getNewWorker:function(){return 0==mt.unusedWorkers.length&&(mt.allocateUnusedWorker(),mt.loadWasmModuleToWorker(mt.unusedWorkers[0])),mt.unusedWorkers.pop()}};function ft(t){for(;t.length>0;)t.shift()(d)}function ht(t){if(v)return Tt(2,0,t);try{pt(t)}catch(t){!function(t){if(t instanceof ut||"unwind"==t)return O;b(1,t)}(t)}}d.PThread=mt,d.establishStackSpace=function(){var t=Mt(),e=s()[t+52>>>2],n=s()[t+56>>>2];Wt(e,e-n),qt(e)};var yt,bt=[];function gt(t,e,n,r){return v?Tt(3,1,t,e,n,r):wt(t,e,n,r)}function wt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return E("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];if(v&&0===a.length)return gt(t,e,n,r);var s={startRoutine:n,pthread_ptr:t,arg:r,transferList:a};return v?(s.cmd="spawnThread",postMessage(s,a),0):ct(s)}function _t(t){Atomics.store(s(),t>>2,1),Mt()&&Vt(t),Atomics.compareExchange(s(),t>>2,1,0)}function vt(t){vt.shown||(vt.shown={}),vt.shown[t]||(vt.shown[t]=1,_&&(t="warning: "+t),E(t))}function Tt(t,e){var n,r,a,s=arguments.length-2,o=arguments;return n=()=>{for(var n=s,r=Ht(8*n),a=r>>3,u=0;u<s;u++){var l=o[2+u];i()[a+u>>>0]=l}return zt(t,n,r,e)},r=jt(),a=n(),qt(r),a}d.invokeEntryPoint=function(t,e){var n,r,a=((r=bt[n=t])||(n>=bt.length&&(bt.length=n+1),bt[n]=r=H.get(n)),r)(e);K()?mt.setExitStatus(a):Ut(a)},d.executeNotifiedProxyingQueue=_t,yt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.timeOrigin+performance.now();var St=[];function Nt(t){try{return P.grow(t-R.byteLength+65535>>>16),q(P.buffer),1}catch(t){}}function xt(t){return v?Tt(4,1,t):52}function kt(t,e,n,r,a){return v?Tt(5,1,t,e,n,r,a):70}var Ct=[null,[],[]];function At(t,e){var n=Ct[t];0===e||10===e?((1===t?D:E)(W(n,0)),n.length=0):n.push(e)}function Dt(t,e,n,r){if(v)return Tt(6,1,t,e,n,r);for(var s=0,i=0;i<n;i++){var u=o()[e>>>2],l=o()[e+4>>>2];e+=8;for(var c=0;c<l;c++)At(t,a()[u+c>>>0]);s+=l}return o()[r>>>2]=s,0}function Et(t){return d["_"+t]}function Pt(t,n,r,s,o){var i={string:t=>{var e=0;if(null!=t&&0!==t){var n=1+(t.length<<2);!function(t,e,n){!function(t,e,n,r){if(!(r>0))return 0;n>>>=0;for(var a=n+r-1,s=0;s<t.length;++s){var o=t.charCodeAt(s);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++s)),o<=127){if(n>=a)break;e[n++>>>0]=o}else if(o<=2047){if(n+1>=a)break;e[n++>>>0]=192|o>>6,e[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=a)break;e[n++>>>0]=224|o>>12,e[n++>>>0]=128|o>>6&63,e[n++>>>0]=128|63&o}else{if(n+3>=a)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63,e[n++>>>0]=128|o>>6&63,e[n++>>>0]=128|63&o}}e[n>>>0]=0}(t,a(),e,n)}(t,e=Ht(n),n)}return e},array:t=>{var n=Ht(t.length);return function(t,n){e().set(t,n>>>0)}(t,n),n}},u=Et(t),l=[],c=0;if(s)for(var d=0;d<s.length;d++){var p=i[r[d]];p?(0===c&&(c=jt()),l[d]=p(s[d])):l[d]=s[d]}var m=u.apply(null,l);return m=function(t){return 0!==c&&qt(c),function(t){return"string"===n?j(t):"boolean"===n?Boolean(t):t}(t)}(m)}mt.init();var Ft,$t,Ot,Rt=[null,dt,ht,gt,xt,kt,Dt],It={__emscripten_init_main_thread_js:function(t){Lt(t,!w,1,!g),mt.threadInitTLS()},__emscripten_thread_cleanup:function(t){v?postMessage({cmd:"cleanupThread",thread:t}):lt(t)},__pthread_create_js:wt,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return!0},_emscripten_notify_task_queue:function(t,e,n,r){if(t==e)setTimeout((()=>_t(r)));else if(v)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{var a=mt.pthreads[t];if(!a)return;a.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},_emscripten_set_offscreencanvas_size:function(t,e,n){return-1},abort:function(){rt("")},emscripten_check_blocking_allowed:function(){_||w||vt("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:yt,emscripten_memcpy_big:function(t,e,n){a().copyWithin(t>>>0,e>>>0,e+n>>>0)},emscripten_num_logical_cores:function(){return _?n(614).cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(t,e,n){St.length=e;for(var r=n>>3,a=0;a<e;a++)St[a]=i()[r+a>>>0];return(t<0?it[-t-1]:Rt[t]).apply(null,St)},emscripten_resize_heap:function(t){var e=a().length;if((t>>>=0)<=e)return!1;var n,r,s=4294901760;if(t>s)return!1;for(var o=1;o<=4;o*=2){var i=e*(1+.2/o);if(i=Math.min(i,t+100663296),Nt(Math.min(s,(n=Math.max(t,i))+((r=65536)-n%r)%r)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:pt,fd_close:xt,fd_seek:kt,fd_write:Dt,memory:P||d.wasmMemory},Mt=(function(){var t={env:It,wasi_snapshot_preview1:It};function e(t,e){var n,r,a=t.exports;if(d.asm=a,n=d.asm._emscripten_tls_init,mt.tlsInitFunctions.push(n),H=d.asm.__indirect_function_table,r=d.asm.__wasm_call_ctors,X.unshift(r),F=e,!v){var s=mt.unusedWorkers.length;mt.unusedWorkers.forEach((function(t){mt.loadWasmModuleToWorker(t,(function(){--s||function(){if(tt--,d.monitorRunDependencies&&d.monitorRunDependencies(tt),0==tt&&(null!==et&&(clearInterval(et),et=null),nt)){var t=nt;nt=null,t()}}()}))}))}}function n(t){e(t.instance,t.module)}function r(e){return function(){if(!A&&(g||w)){if("function"==typeof fetch&&!st(Y))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at '"+Y+"'";return t.arrayBuffer()})).catch((function(){return ot(Y)}));if(m)return new Promise((function(t,e){m(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot(Y)}))}().then((function(e){return WebAssembly.instantiate(e,t)})).then((function(t){return t})).then(e,(function(t){E("failed to asynchronously prepare wasm: "+t),rt(t)}))}if(v||(tt++,d.monitorRunDependencies&&d.monitorRunDependencies(tt)),d.instantiateWasm)try{return d.instantiateWasm(t,e)}catch(t){E("Module.instantiateWasm callback failed with error: "+t),l(t)}(A||"function"!=typeof WebAssembly.instantiateStreaming||at(Y)||st(Y)||_||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,t).then(n,(function(t){return E("wasm streaming compile failed: "+t),E("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(l)}(),d.___wasm_call_ctors=function(){return(d.___wasm_call_ctors=d.asm.__wasm_call_ctors).apply(null,arguments)},d._init=function(){return(d._init=d.asm.init).apply(null,arguments)},d._init_with_threads_count=function(){return(d._init_with_threads_count=d.asm.init_with_threads_count).apply(null,arguments)},d._get_threads_count=function(){return(d._get_threads_count=d.asm.get_threads_count).apply(null,arguments)},d._register_tensor=function(){return(d._register_tensor=d.asm.register_tensor).apply(null,arguments)},d._dispose_data=function(){return(d._dispose_data=d.asm.dispose_data).apply(null,arguments)},d._dispose=function(){return(d._dispose=d.asm.dispose).apply(null,arguments)},d._Abs=function(){return(d._Abs=d.asm.Abs).apply(null,arguments)},d._Acos=function(){return(d._Acos=d.asm.Acos).apply(null,arguments)},d._Acosh=function(){return(d._Acosh=d.asm.Acosh).apply(null,arguments)},d._Add=function(){return(d._Add=d.asm.Add).apply(null,arguments)},d._AddN=function(){return(d._AddN=d.asm.AddN).apply(null,arguments)},d._All=function(){return(d._All=d.asm.All).apply(null,arguments)},d._Any=function(){return(d._Any=d.asm.Any).apply(null,arguments)},d._ArgMax=function(){return(d._ArgMax=d.asm.ArgMax).apply(null,arguments)},d._ArgMin=function(){return(d._ArgMin=d.asm.ArgMin).apply(null,arguments)},d._Asin=function(){return(d._Asin=d.asm.Asin).apply(null,arguments)},d._Asinh=function(){return(d._Asinh=d.asm.Asinh).apply(null,arguments)},d._Atan=function(){return(d._Atan=d.asm.Atan).apply(null,arguments)},d._Atan2=function(){return(d._Atan2=d.asm.Atan2).apply(null,arguments)},d._Atanh=function(){return(d._Atanh=d.asm.Atanh).apply(null,arguments)},d._AvgPool=function(){return(d._AvgPool=d.asm.AvgPool).apply(null,arguments)},d._AvgPool3D=function(){return(d._AvgPool3D=d.asm.AvgPool3D).apply(null,arguments)},d._AvgPool3DGrad=function(){return(d._AvgPool3DGrad=d.asm.AvgPool3DGrad).apply(null,arguments)},d._BatchMatMul=function(){return(d._BatchMatMul=d.asm.BatchMatMul).apply(null,arguments)},d._Bincount=function(){return(d._Bincount=d.asm.Bincount).apply(null,arguments)},d._Ceil=function(){return(d._Ceil=d.asm.Ceil).apply(null,arguments)},d._ClipByValue=function(){return(d._ClipByValue=d.asm.ClipByValue).apply(null,arguments)},d._Conv2D=function(){return(d._Conv2D=d.asm.Conv2D).apply(null,arguments)},d._Conv2DBackpropInput=function(){return(d._Conv2DBackpropInput=d.asm.Conv2DBackpropInput).apply(null,arguments)},d._Conv3D=function(){return(d._Conv3D=d.asm.Conv3D).apply(null,arguments)},d._Conv3DBackpropFilterV2=function(){return(d._Conv3DBackpropFilterV2=d.asm.Conv3DBackpropFilterV2).apply(null,arguments)},d._Conv3DBackpropInputV2=function(){return(d._Conv3DBackpropInputV2=d.asm.Conv3DBackpropInputV2).apply(null,arguments)},d._Cos=function(){return(d._Cos=d.asm.Cos).apply(null,arguments)},d._Cosh=function(){return(d._Cosh=d.asm.Cosh).apply(null,arguments)},d._CropAndResize=function(){return(d._CropAndResize=d.asm.CropAndResize).apply(null,arguments)},d._Cumprod=function(){return(d._Cumprod=d.asm.Cumprod).apply(null,arguments)},d._Cumsum=function(){return(d._Cumsum=d.asm.Cumsum).apply(null,arguments)},d._DenseBincount=function(){return(d._DenseBincount=d.asm.DenseBincount).apply(null,arguments)},d._DepthToSpace=function(){return(d._DepthToSpace=d.asm.DepthToSpace).apply(null,arguments)},d._DepthwiseConv2dNative=function(){return(d._DepthwiseConv2dNative=d.asm.DepthwiseConv2dNative).apply(null,arguments)},d._Diag=function(){return(d._Diag=d.asm.Diag).apply(null,arguments)},d._Dilation2D=function(){return(d._Dilation2D=d.asm.Dilation2D).apply(null,arguments)},d._Dilation2DBackpropFilter=function(){return(d._Dilation2DBackpropFilter=d.asm.Dilation2DBackpropFilter).apply(null,arguments)},d._Dilation2DBackpropInput=function(){return(d._Dilation2DBackpropInput=d.asm.Dilation2DBackpropInput).apply(null,arguments)},d._Elu=function(){return(d._Elu=d.asm.Elu).apply(null,arguments)},d._EluGrad=function(){return(d._EluGrad=d.asm.EluGrad).apply(null,arguments)},d._Equal=function(){return(d._Equal=d.asm.Equal).apply(null,arguments)},d._Exp=function(){return(d._Exp=d.asm.Exp).apply(null,arguments)},d._Expm1=function(){return(d._Expm1=d.asm.Expm1).apply(null,arguments)},d._FlipLeftRight=function(){return(d._FlipLeftRight=d.asm.FlipLeftRight).apply(null,arguments)},d._Floor=function(){return(d._Floor=d.asm.Floor).apply(null,arguments)},d._FloorDiv=function(){return(d._FloorDiv=d.asm.FloorDiv).apply(null,arguments)},d._FusedBatchNorm=function(){return(d._FusedBatchNorm=d.asm.FusedBatchNorm).apply(null,arguments)},d._FusedConv2D=function(){return(d._FusedConv2D=d.asm.FusedConv2D).apply(null,arguments)},d._FusedDepthwiseConv2D=function(){return(d._FusedDepthwiseConv2D=d.asm.FusedDepthwiseConv2D).apply(null,arguments)},d._Gather=function(){return(d._Gather=d.asm.Gather).apply(null,arguments)},d._GatherNd=function(){return(d._GatherNd=d.asm.GatherNd).apply(null,arguments)},d._Greater=function(){return(d._Greater=d.asm.Greater).apply(null,arguments)},d._GreaterEqual=function(){return(d._GreaterEqual=d.asm.GreaterEqual).apply(null,arguments)},d._IsFinite=function(){return(d._IsFinite=d.asm.IsFinite).apply(null,arguments)},d._IsInf=function(){return(d._IsInf=d.asm.IsInf).apply(null,arguments)},d._IsNan=function(){return(d._IsNan=d.asm.IsNan).apply(null,arguments)},d._LRN=function(){return(d._LRN=d.asm.LRN).apply(null,arguments)},d._LRNGrad=function(){return(d._LRNGrad=d.asm.LRNGrad).apply(null,arguments)},d._LeakyRelu=function(){return(d._LeakyRelu=d.asm.LeakyRelu).apply(null,arguments)},d._Less=function(){return(d._Less=d.asm.Less).apply(null,arguments)},d._LessEqual=function(){return(d._LessEqual=d.asm.LessEqual).apply(null,arguments)},d._LinSpace=function(){return(d._LinSpace=d.asm.LinSpace).apply(null,arguments)},d._Log=function(){return(d._Log=d.asm.Log).apply(null,arguments)},d._Log1p=function(){return(d._Log1p=d.asm.Log1p).apply(null,arguments)},d._LogicalAnd=function(){return(d._LogicalAnd=d.asm.LogicalAnd).apply(null,arguments)},d._LogicalNot=function(){return(d._LogicalNot=d.asm.LogicalNot).apply(null,arguments)},d._LogicalOr=function(){return(d._LogicalOr=d.asm.LogicalOr).apply(null,arguments)},d._LogicalXor=function(){return(d._LogicalXor=d.asm.LogicalXor).apply(null,arguments)},d._Max=function(){return(d._Max=d.asm.Max).apply(null,arguments)},d._MaxPool=function(){return(d._MaxPool=d.asm.MaxPool).apply(null,arguments)},d._MaxPool3D=function(){return(d._MaxPool3D=d.asm.MaxPool3D).apply(null,arguments)},d._MaxPool3DGrad=function(){return(d._MaxPool3DGrad=d.asm.MaxPool3DGrad).apply(null,arguments)},d._Maximum=function(){return(d._Maximum=d.asm.Maximum).apply(null,arguments)},d._Mean=function(){return(d._Mean=d.asm.Mean).apply(null,arguments)},d._Min=function(){return(d._Min=d.asm.Min).apply(null,arguments)},d._Minimum=function(){return(d._Minimum=d.asm.Minimum).apply(null,arguments)},d._MirrorPad=function(){return(d._MirrorPad=d.asm.MirrorPad).apply(null,arguments)},d._Multinomial=function(){return(d._Multinomial=d.asm.Multinomial).apply(null,arguments)},d._Multiply=function(){return(d._Multiply=d.asm.Multiply).apply(null,arguments)},d._Neg=function(){return(d._Neg=d.asm.Neg).apply(null,arguments)},d._NonMaxSuppressionV3=function(){return(d._NonMaxSuppressionV3=d.asm.NonMaxSuppressionV3).apply(null,arguments)},d._NonMaxSuppressionV4=function(){return(d._NonMaxSuppressionV4=d.asm.NonMaxSuppressionV4).apply(null,arguments)},d._NonMaxSuppressionV5=function(){return(d._NonMaxSuppressionV5=d.asm.NonMaxSuppressionV5).apply(null,arguments)},d._NotEqual=function(){return(d._NotEqual=d.asm.NotEqual).apply(null,arguments)},d._OneHot=function(){return(d._OneHot=d.asm.OneHot).apply(null,arguments)},d._PadV2=function(){return(d._PadV2=d.asm.PadV2).apply(null,arguments)},d._Pow=function(){return(d._Pow=d.asm.Pow).apply(null,arguments)},d._Prelu=function(){return(d._Prelu=d.asm.Prelu).apply(null,arguments)},d._Prod=function(){return(d._Prod=d.asm.Prod).apply(null,arguments)},d._RealDiv=function(){return(d._RealDiv=d.asm.RealDiv).apply(null,arguments)},d._Reciprocal=function(){return(d._Reciprocal=d.asm.Reciprocal).apply(null,arguments)},d._Relu=function(){return(d._Relu=d.asm.Relu).apply(null,arguments)},d._Relu6=function(){return(d._Relu6=d.asm.Relu6).apply(null,arguments)},d._ResizeBilinear=function(){return(d._ResizeBilinear=d.asm.ResizeBilinear).apply(null,arguments)},d._ResizeBilinearGrad=function(){return(d._ResizeBilinearGrad=d.asm.ResizeBilinearGrad).apply(null,arguments)},d._ResizeNearestNeighbor=function(){return(d._ResizeNearestNeighbor=d.asm.ResizeNearestNeighbor).apply(null,arguments)},d._ResizeNearestNeighborGrad=function(){return(d._ResizeNearestNeighborGrad=d.asm.ResizeNearestNeighborGrad).apply(null,arguments)},d._Reverse=function(){return(d._Reverse=d.asm.Reverse).apply(null,arguments)},d._RotateWithOffset=function(){return(d._RotateWithOffset=d.asm.RotateWithOffset).apply(null,arguments)},d._Round=function(){return(d._Round=d.asm.Round).apply(null,arguments)},d._Rsqrt=function(){return(d._Rsqrt=d.asm.Rsqrt).apply(null,arguments)},d._ScatterNd=function(){return(d._ScatterNd=d.asm.ScatterNd).apply(null,arguments)},d._SearchSorted=function(){return(d._SearchSorted=d.asm.SearchSorted).apply(null,arguments)},d._SelectV2=function(){return(d._SelectV2=d.asm.SelectV2).apply(null,arguments)},d._Selu=function(){return(d._Selu=d.asm.Selu).apply(null,arguments)},d._Sigmoid=function(){return(d._Sigmoid=d.asm.Sigmoid).apply(null,arguments)},d._Sign=function(){return(d._Sign=d.asm.Sign).apply(null,arguments)},d._Sin=function(){return(d._Sin=d.asm.Sin).apply(null,arguments)},d._Softmax=function(){return(d._Softmax=d.asm.Softmax).apply(null,arguments)},d._Softplus=function(){return(d._Softplus=d.asm.Softplus).apply(null,arguments)},d._SparseFillEmptyRows=function(){return(d._SparseFillEmptyRows=d.asm.SparseFillEmptyRows).apply(null,arguments)},d._SparseReshape=function(){return(d._SparseReshape=d.asm.SparseReshape).apply(null,arguments)},d._SparseSegmentReduction=function(){return(d._SparseSegmentReduction=d.asm.SparseSegmentReduction).apply(null,arguments)},d._SparseToDense=function(){return(d._SparseToDense=d.asm.SparseToDense).apply(null,arguments)},d._Sqrt=function(){return(d._Sqrt=d.asm.Sqrt).apply(null,arguments)},d._Square=function(){return(d._Square=d.asm.Square).apply(null,arguments)},d._SquaredDifference=function(){return(d._SquaredDifference=d.asm.SquaredDifference).apply(null,arguments)},d._Step=function(){return(d._Step=d.asm.Step).apply(null,arguments)},d._StridedSlice=function(){return(d._StridedSlice=d.asm.StridedSlice).apply(null,arguments)},d._Sub=function(){return(d._Sub=d.asm.Sub).apply(null,arguments)},d._Sum=function(){return(d._Sum=d.asm.Sum).apply(null,arguments)},d._Tan=function(){return(d._Tan=d.asm.Tan).apply(null,arguments)},d._Tanh=function(){return(d._Tanh=d.asm.Tanh).apply(null,arguments)},d._TensorScatterUpdate=function(){return(d._TensorScatterUpdate=d.asm.TensorScatterUpdate).apply(null,arguments)},d._Tile=function(){return(d._Tile=d.asm.Tile).apply(null,arguments)},d._TopK=function(){return(d._TopK=d.asm.TopK).apply(null,arguments)},d._Transform=function(){return(d._Transform=d.asm.Transform).apply(null,arguments)},d._Transpose=function(){return(d._Transpose=d.asm.Transpose).apply(null,arguments)},d.__FusedMatMul=function(){return(d.__FusedMatMul=d.asm._FusedMatMul).apply(null,arguments)},d._malloc=function(){return(d._malloc=d.asm.malloc).apply(null,arguments)},d._free=function(){return(d._free=d.asm.free).apply(null,arguments)},d.__emscripten_tls_init=function(){return(d.__emscripten_tls_init=d.asm._emscripten_tls_init).apply(null,arguments)},d._pthread_self=function(){return(Mt=d._pthread_self=d.asm.pthread_self).apply(null,arguments)}),Lt=(d.___errno_location=function(){return(d.___errno_location=d.asm.__errno_location).apply(null,arguments)},d.__emscripten_thread_init=function(){return(Lt=d.__emscripten_thread_init=d.asm._emscripten_thread_init).apply(null,arguments)}),zt=(d.__emscripten_thread_crashed=function(){return(d.__emscripten_thread_crashed=d.asm._emscripten_thread_crashed).apply(null,arguments)},d._emscripten_main_thread_process_queued_calls=function(){return(d._emscripten_main_thread_process_queued_calls=d.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},d._emscripten_main_browser_thread_id=function(){return(d._emscripten_main_browser_thread_id=d.asm.emscripten_main_browser_thread_id).apply(null,arguments)},d._emscripten_run_in_main_runtime_thread_js=function(){return(zt=d._emscripten_run_in_main_runtime_thread_js=d.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),Vt=(d._emscripten_dispatch_to_thread_=function(){return(d._emscripten_dispatch_to_thread_=d.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},d.__emscripten_proxy_execute_task_queue=function(){return(Vt=d.__emscripten_proxy_execute_task_queue=d.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),Bt=d.__emscripten_thread_free_data=function(){return(Bt=d.__emscripten_thread_free_data=d.asm._emscripten_thread_free_data).apply(null,arguments)},Ut=d.__emscripten_thread_exit=function(){return(Ut=d.__emscripten_thread_exit=d.asm._emscripten_thread_exit).apply(null,arguments)},Wt=d._emscripten_stack_set_limits=function(){return(Wt=d._emscripten_stack_set_limits=d.asm.emscripten_stack_set_limits).apply(null,arguments)},jt=d.stackSave=function(){return(jt=d.stackSave=d.asm.stackSave).apply(null,arguments)},qt=d.stackRestore=function(){return(qt=d.stackRestore=d.asm.stackRestore).apply(null,arguments)},Ht=d.stackAlloc=function(){return(Ht=d.stackAlloc=d.asm.stackAlloc).apply(null,arguments)};function Gt(t){if(t=t||y,!(tt>0)){if(v)return u(d),Z(),void startWorker(d);!function(){if(d.preRun)for("function"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)t=d.preRun.shift(),Q.unshift(t);var t;ft(Q)}(),tt>0||(d.setStatus?(d.setStatus("Running..."),setTimeout((function(){setTimeout((function(){d.setStatus("")}),1),e()}),1)):e())}function e(){Ft||(Ft=!0,d.calledRun=!0,B||(Z(),u(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),function(){if(!v){if(d.postRun)for("function"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;)t=d.postRun.shift(),J.unshift(t);var t;ft(J)}}()))}}if(d.dynCall_iijjiiii=function(){return(d.dynCall_iijjiiii=d.asm.dynCall_iijjiiii).apply(null,arguments)},d.dynCall_jiji=function(){return(d.dynCall_jiji=d.asm.dynCall_jiji).apply(null,arguments)},d.keepRuntimeAlive=K,d.wasmMemory=P,d.cwrap=function(t,e,n,r){var a=(n=n||[]).every((t=>"number"===t||"boolean"===t));return"string"!==e&&a&&!r?Et(t):function(){return Pt(t,e,n,arguments)}},d.ExitStatus=ut,d.PThread=mt,nt=function t(){Ft||Gt(),Ft||(nt=t)},d.preInit)for("function"==typeof d.preInit&&(d.preInit=[d.preInit]);d.preInit.length>0;)d.preInit.pop()();if(Gt(),c&&($t={uncaughtException:process.listeners("uncaughtException").filter((function(t){return!c.uncaughtException.indexOf(t)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(t){return!c.unhandledRejection.indexOf(t)>-1}))}),"undefined"!=typeof WasmBackendModule)Ot=WasmBackendModule;else{if("undefined"==typeof t)throw new Error("Could not find wasm module in post.js");Ot=t}if($t){var Qt=Ot._dispose;Ot._dispose=function(){Qt(),$t.uncaughtException.forEach((function(t){process.removeListener("uncaughtException",t)})),$t.unhandledRejection.forEach((function(t){process.removeListener("unhandledRejection",t)}))}}return t.ready});t.exports=a},269:t=>{t.exports.$='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'},33:(t,e,n)=>{var r,a=(r=(r="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,a,s,o="undefined"!=typeof(t=t||{})?t:{};o.ready=new Promise((function(t,n){e=t,a=n})),"undefined"!=typeof process&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i,u,l,c=Object.assign({},o),d=[],p="object"==typeof window,m="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(f){var y=n(465),b=n(981);h=m?b.dirname(h)+"/":"//",i=(t,e)=>(t=B(t)?new URL(t):b.normalize(t),y.readFileSync(t,e?void 0:"utf8")),l=t=>{var e=i(t,!0);return e.buffer||(e=new Uint8Array(e)),e},u=(t,e,n)=>{t=B(t)?new URL(t):b.normalize(t),y.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),d=process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof W))throw t})),process.on("unhandledRejection",(function(t){throw t})),o.inspect=function(){return"[Emscripten Module object]"}}else(p||m)&&(m?h=self.location.href:"undefined"!=typeof document&&document.currentScript&&(h=document.currentScript.src),r&&(h=r),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},m&&(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),u=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,w=o.print||console.log.bind(console),_=o.printErr||console.warn.bind(console);Object.assign(o,c),c=null,o.arguments&&(d=o.arguments),o.thisProgram&&o.thisProgram,o.quit&&o.quit,o.wasmBinary&&(g=o.wasmBinary);var v;o.noExitRuntime;"object"!=typeof WebAssembly&&z("no native wasm support detected");var T,S,N,x,k=!1,C="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function A(t,e,n){for(var r=(e>>>=0)+n,a=e;t[a]&&!(a>=r);)++a;if(a-e>16&&t.buffer&&C)return C.decode(t.subarray(e,a));for(var s="";e<a;){var o=t[e++];if(128&o){var i=63&t[e++];if(192!=(224&o)){var u=63&t[e++];if((o=224==(240&o)?(15&o)<<12|i<<6|u:(7&o)<<18|i<<12|u<<6|63&t[e++])<65536)s+=String.fromCharCode(o);else{var l=o-65536;s+=String.fromCharCode(55296|l>>10,56320|1023&l)}}else s+=String.fromCharCode((31&o)<<6|i)}else s+=String.fromCharCode(o)}return s}function D(t,e){return(t>>>=0)?A(N,t,e):""}function E(t){T=t,o.HEAP8=S=new Int8Array(t),o.HEAP16=new Int16Array(t),o.HEAP32=new Int32Array(t),o.HEAPU8=N=new Uint8Array(t),o.HEAPU16=new Uint16Array(t),o.HEAPU32=x=new Uint32Array(t),o.HEAPF32=new Float32Array(t),o.HEAPF64=new Float64Array(t)}o.INITIAL_MEMORY;var P,F,$=[],O=[],R=[],I=0,M=null,L=null;function z(t){o.onAbort&&o.onAbort(t),_(t="Aborted("+t+")"),k=!0,t+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(t);throw a(e),e}function V(t){return t.startsWith("data:application/octet-stream;base64,")}function B(t){return t.startsWith("file://")}function U(t){try{if(t==P&&g)return new Uint8Array(g);if(l)return l(t);throw"both async and sync fetching of the wasm failed"}catch(t){z(t)}}function W(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function j(t){for(;t.length>0;)t.shift()(o)}function q(t){try{return v.grow(t-T.byteLength+65535>>>16),E(v.buffer),1}catch(t){}}V(P="tfjs-backend-wasm.wasm")||(F=P,P=o.locateFile?o.locateFile(F,h):h+F);var H=[null,[],[]];function G(t,e){var n=H[t];0===e||10===e?((1===t?w:_)(A(n,0)),n.length=0):n.push(e)}function Q(t){return o["_"+t]}function X(t,e,n,r,a){var s={string:t=>{var e=0;if(null!=t&&0!==t){var n=1+(t.length<<2);!function(t,e,n){!function(t,e,n,r){if(!(r>0))return 0;n>>>=0;for(var a=n+r-1,s=0;s<t.length;++s){var o=t.charCodeAt(s);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++s)),o<=127){if(n>=a)break;e[n++>>>0]=o}else if(o<=2047){if(n+1>=a)break;e[n++>>>0]=192|o>>6,e[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=a)break;e[n++>>>0]=224|o>>12,e[n++>>>0]=128|o>>6&63,e[n++>>>0]=128|63&o}else{if(n+3>=a)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63,e[n++>>>0]=128|o>>6&63,e[n++>>>0]=128|63&o}}e[n>>>0]=0}(t,N,e,n)}(t,e=nt(n),n)}return e},array:t=>{var e=nt(t.length);return function(t,e){S.set(t,e>>>0)}(t,e),e}},o=Q(t),i=[],u=0;if(r)for(var l=0;l<r.length;l++){var c=s[n[l]];c?(0===u&&(u=tt()),i[l]=c(r[l])):i[l]=r[l]}var d=o.apply(null,i);return d=function(t){return 0!==u&&et(u),function(t){return"string"===e?D(t):"boolean"===e?Boolean(t):t}(t)}(d)}var J,K,Z,Y={abort:function(){z("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(t,e,n){N.copyWithin(t>>>0,e>>>0,e+n>>>0)},emscripten_resize_heap:function(t){var e,n,r=N.length,a=4294901760;if((t>>>=0)>a)return!1;for(var s=1;s<=4;s*=2){var o=r*(1+.2/s);if(o=Math.min(o,t+100663296),q(Math.min(a,(e=Math.max(t,o))+((n=65536)-e%n)%n)))return!0}return!1},fd_close:function(t){return 52},fd_seek:function(t,e,n,r,a){return 70},fd_write:function(t,e,n,r){for(var a=0,s=0;s<n;s++){var o=x[e>>>2],i=x[e+4>>>2];e+=8;for(var u=0;u<i;u++)G(t,N[o+u>>>0]);a+=i}return x[r>>>2]=a,0}},tt=(function(){var t={env:Y,wasi_snapshot_preview1:Y};function e(t,e){var n,r=t.exports;o.asm=r,E((v=o.asm.memory).buffer),o.asm.__indirect_function_table,n=o.asm.__wasm_call_ctors,O.unshift(n),function(){if(I--,o.monitorRunDependencies&&o.monitorRunDependencies(I),0==I&&(null!==M&&(clearInterval(M),M=null),L)){var t=L;L=null,t()}}()}function n(t){e(t.instance)}function r(e){return function(){if(!g&&(p||m)){if("function"==typeof fetch&&!B(P))return fetch(P,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at '"+P+"'";return t.arrayBuffer()})).catch((function(){return U(P)}));if(u)return new Promise((function(t,e){u(P,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return U(P)}))}().then((function(e){return WebAssembly.instantiate(e,t)})).then((function(t){return t})).then(e,(function(t){_("failed to asynchronously prepare wasm: "+t),z(t)}))}if(I++,o.monitorRunDependencies&&o.monitorRunDependencies(I),o.instantiateWasm)try{return o.instantiateWasm(t,e)}catch(t){_("Module.instantiateWasm callback failed with error: "+t),a(t)}(g||"function"!=typeof WebAssembly.instantiateStreaming||V(P)||B(P)||f||"function"!=typeof fetch?r(n):fetch(P,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,t).then(n,(function(t){return _("wasm streaming compile failed: "+t),_("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),o.___wasm_call_ctors=function(){return(o.___wasm_call_ctors=o.asm.__wasm_call_ctors).apply(null,arguments)},o._init=function(){return(o._init=o.asm.init).apply(null,arguments)},o._init_with_threads_count=function(){return(o._init_with_threads_count=o.asm.init_with_threads_count).apply(null,arguments)},o._get_threads_count=function(){return(o._get_threads_count=o.asm.get_threads_count).apply(null,arguments)},o._register_tensor=function(){return(o._register_tensor=o.asm.register_tensor).apply(null,arguments)},o._dispose_data=function(){return(o._dispose_data=o.asm.dispose_data).apply(null,arguments)},o._dispose=function(){return(o._dispose=o.asm.dispose).apply(null,arguments)},o._Abs=function(){return(o._Abs=o.asm.Abs).apply(null,arguments)},o._Acos=function(){return(o._Acos=o.asm.Acos).apply(null,arguments)},o._Acosh=function(){return(o._Acosh=o.asm.Acosh).apply(null,arguments)},o._Add=function(){return(o._Add=o.asm.Add).apply(null,arguments)},o._AddN=function(){return(o._AddN=o.asm.AddN).apply(null,arguments)},o._All=function(){return(o._All=o.asm.All).apply(null,arguments)},o._Any=function(){return(o._Any=o.asm.Any).apply(null,arguments)},o._ArgMax=function(){return(o._ArgMax=o.asm.ArgMax).apply(null,arguments)},o._ArgMin=function(){return(o._ArgMin=o.asm.ArgMin).apply(null,arguments)},o._Asin=function(){return(o._Asin=o.asm.Asin).apply(null,arguments)},o._Asinh=function(){return(o._Asinh=o.asm.Asinh).apply(null,arguments)},o._Atan=function(){return(o._Atan=o.asm.Atan).apply(null,arguments)},o._Atan2=function(){return(o._Atan2=o.asm.Atan2).apply(null,arguments)},o._Atanh=function(){return(o._Atanh=o.asm.Atanh).apply(null,arguments)},o._AvgPool=function(){return(o._AvgPool=o.asm.AvgPool).apply(null,arguments)},o._AvgPool3D=function(){return(o._AvgPool3D=o.asm.AvgPool3D).apply(null,arguments)},o._AvgPool3DGrad=function(){return(o._AvgPool3DGrad=o.asm.AvgPool3DGrad).apply(null,arguments)},o._BatchMatMul=function(){return(o._BatchMatMul=o.asm.BatchMatMul).apply(null,arguments)},o._Bincount=function(){return(o._Bincount=o.asm.Bincount).apply(null,arguments)},o._Ceil=function(){return(o._Ceil=o.asm.Ceil).apply(null,arguments)},o._ClipByValue=function(){return(o._ClipByValue=o.asm.ClipByValue).apply(null,arguments)},o._Conv2D=function(){return(o._Conv2D=o.asm.Conv2D).apply(null,arguments)},o._Conv2DBackpropInput=function(){return(o._Conv2DBackpropInput=o.asm.Conv2DBackpropInput).apply(null,arguments)},o._Conv3D=function(){return(o._Conv3D=o.asm.Conv3D).apply(null,arguments)},o._Conv3DBackpropFilterV2=function(){return(o._Conv3DBackpropFilterV2=o.asm.Conv3DBackpropFilterV2).apply(null,arguments)},o._Conv3DBackpropInputV2=function(){return(o._Conv3DBackpropInputV2=o.asm.Conv3DBackpropInputV2).apply(null,arguments)},o._Cos=function(){return(o._Cos=o.asm.Cos).apply(null,arguments)},o._Cosh=function(){return(o._Cosh=o.asm.Cosh).apply(null,arguments)},o._CropAndResize=function(){return(o._CropAndResize=o.asm.CropAndResize).apply(null,arguments)},o._Cumprod=function(){return(o._Cumprod=o.asm.Cumprod).apply(null,arguments)},o._Cumsum=function(){return(o._Cumsum=o.asm.Cumsum).apply(null,arguments)},o._DenseBincount=function(){return(o._DenseBincount=o.asm.DenseBincount).apply(null,arguments)},o._DepthToSpace=function(){return(o._DepthToSpace=o.asm.DepthToSpace).apply(null,arguments)},o._DepthwiseConv2dNative=function(){return(o._DepthwiseConv2dNative=o.asm.DepthwiseConv2dNative).apply(null,arguments)},o._Diag=function(){return(o._Diag=o.asm.Diag).apply(null,arguments)},o._Dilation2D=function(){return(o._Dilation2D=o.asm.Dilation2D).apply(null,arguments)},o._Dilation2DBackpropFilter=function(){return(o._Dilation2DBackpropFilter=o.asm.Dilation2DBackpropFilter).apply(null,arguments)},o._Dilation2DBackpropInput=function(){return(o._Dilation2DBackpropInput=o.asm.Dilation2DBackpropInput).apply(null,arguments)},o._Elu=function(){return(o._Elu=o.asm.Elu).apply(null,arguments)},o._EluGrad=function(){return(o._EluGrad=o.asm.EluGrad).apply(null,arguments)},o._Equal=function(){return(o._Equal=o.asm.Equal).apply(null,arguments)},o._Exp=function(){return(o._Exp=o.asm.Exp).apply(null,arguments)},o._Expm1=function(){return(o._Expm1=o.asm.Expm1).apply(null,arguments)},o._FlipLeftRight=function(){return(o._FlipLeftRight=o.asm.FlipLeftRight).apply(null,arguments)},o._Floor=function(){return(o._Floor=o.asm.Floor).apply(null,arguments)},o._FloorDiv=function(){return(o._FloorDiv=o.asm.FloorDiv).apply(null,arguments)},o._FusedBatchNorm=function(){return(o._FusedBatchNorm=o.asm.FusedBatchNorm).apply(null,arguments)},o._FusedConv2D=function(){return(o._FusedConv2D=o.asm.FusedConv2D).apply(null,arguments)},o._FusedDepthwiseConv2D=function(){return(o._FusedDepthwiseConv2D=o.asm.FusedDepthwiseConv2D).apply(null,arguments)},o._Gather=function(){return(o._Gather=o.asm.Gather).apply(null,arguments)},o._GatherNd=function(){return(o._GatherNd=o.asm.GatherNd).apply(null,arguments)},o._Greater=function(){return(o._Greater=o.asm.Greater).apply(null,arguments)},o._GreaterEqual=function(){return(o._GreaterEqual=o.asm.GreaterEqual).apply(null,arguments)},o._IsFinite=function(){return(o._IsFinite=o.asm.IsFinite).apply(null,arguments)},o._IsInf=function(){return(o._IsInf=o.asm.IsInf).apply(null,arguments)},o._IsNan=function(){return(o._IsNan=o.asm.IsNan).apply(null,arguments)},o._LRN=function(){return(o._LRN=o.asm.LRN).apply(null,arguments)},o._LRNGrad=function(){return(o._LRNGrad=o.asm.LRNGrad).apply(null,arguments)},o._LeakyRelu=function(){return(o._LeakyRelu=o.asm.LeakyRelu).apply(null,arguments)},o._Less=function(){return(o._Less=o.asm.Less).apply(null,arguments)},o._LessEqual=function(){return(o._LessEqual=o.asm.LessEqual).apply(null,arguments)},o._LinSpace=function(){return(o._LinSpace=o.asm.LinSpace).apply(null,arguments)},o._Log=function(){return(o._Log=o.asm.Log).apply(null,arguments)},o._Log1p=function(){return(o._Log1p=o.asm.Log1p).apply(null,arguments)},o._LogicalAnd=function(){return(o._LogicalAnd=o.asm.LogicalAnd).apply(null,arguments)},o._LogicalNot=function(){return(o._LogicalNot=o.asm.LogicalNot).apply(null,arguments)},o._LogicalOr=function(){return(o._LogicalOr=o.asm.LogicalOr).apply(null,arguments)},o._LogicalXor=function(){return(o._LogicalXor=o.asm.LogicalXor).apply(null,arguments)},o._Max=function(){return(o._Max=o.asm.Max).apply(null,arguments)},o._MaxPool=function(){return(o._MaxPool=o.asm.MaxPool).apply(null,arguments)},o._MaxPool3D=function(){return(o._MaxPool3D=o.asm.MaxPool3D).apply(null,arguments)},o._MaxPool3DGrad=function(){return(o._MaxPool3DGrad=o.asm.MaxPool3DGrad).apply(null,arguments)},o._Maximum=function(){return(o._Maximum=o.asm.Maximum).apply(null,arguments)},o._Mean=function(){return(o._Mean=o.asm.Mean).apply(null,arguments)},o._Min=function(){return(o._Min=o.asm.Min).apply(null,arguments)},o._Minimum=function(){return(o._Minimum=o.asm.Minimum).apply(null,arguments)},o._MirrorPad=function(){return(o._MirrorPad=o.asm.MirrorPad).apply(null,arguments)},o._Multinomial=function(){return(o._Multinomial=o.asm.Multinomial).apply(null,arguments)},o._Multiply=function(){return(o._Multiply=o.asm.Multiply).apply(null,arguments)},o._Neg=function(){return(o._Neg=o.asm.Neg).apply(null,arguments)},o._NonMaxSuppressionV3=function(){return(o._NonMaxSuppressionV3=o.asm.NonMaxSuppressionV3).apply(null,arguments)},o._NonMaxSuppressionV4=function(){return(o._NonMaxSuppressionV4=o.asm.NonMaxSuppressionV4).apply(null,arguments)},o._NonMaxSuppressionV5=function(){return(o._NonMaxSuppressionV5=o.asm.NonMaxSuppressionV5).apply(null,arguments)},o._NotEqual=function(){return(o._NotEqual=o.asm.NotEqual).apply(null,arguments)},o._OneHot=function(){return(o._OneHot=o.asm.OneHot).apply(null,arguments)},o._PadV2=function(){return(o._PadV2=o.asm.PadV2).apply(null,arguments)},o._Pow=function(){return(o._Pow=o.asm.Pow).apply(null,arguments)},o._Prelu=function(){return(o._Prelu=o.asm.Prelu).apply(null,arguments)},o._Prod=function(){return(o._Prod=o.asm.Prod).apply(null,arguments)},o._RealDiv=function(){return(o._RealDiv=o.asm.RealDiv).apply(null,arguments)},o._Reciprocal=function(){return(o._Reciprocal=o.asm.Reciprocal).apply(null,arguments)},o._Relu=function(){return(o._Relu=o.asm.Relu).apply(null,arguments)},o._Relu6=function(){return(o._Relu6=o.asm.Relu6).apply(null,arguments)},o._ResizeBilinear=function(){return(o._ResizeBilinear=o.asm.ResizeBilinear).apply(null,arguments)},o._ResizeBilinearGrad=function(){return(o._ResizeBilinearGrad=o.asm.ResizeBilinearGrad).apply(null,arguments)},o._ResizeNearestNeighbor=function(){return(o._ResizeNearestNeighbor=o.asm.ResizeNearestNeighbor).apply(null,arguments)},o._ResizeNearestNeighborGrad=function(){return(o._ResizeNearestNeighborGrad=o.asm.ResizeNearestNeighborGrad).apply(null,arguments)},o._Reverse=function(){return(o._Reverse=o.asm.Reverse).apply(null,arguments)},o._RotateWithOffset=function(){return(o._RotateWithOffset=o.asm.RotateWithOffset).apply(null,arguments)},o._Round=function(){return(o._Round=o.asm.Round).apply(null,arguments)},o._Rsqrt=function(){return(o._Rsqrt=o.asm.Rsqrt).apply(null,arguments)},o._ScatterNd=function(){return(o._ScatterNd=o.asm.ScatterNd).apply(null,arguments)},o._SearchSorted=function(){return(o._SearchSorted=o.asm.SearchSorted).apply(null,arguments)},o._SelectV2=function(){return(o._SelectV2=o.asm.SelectV2).apply(null,arguments)},o._Selu=function(){return(o._Selu=o.asm.Selu).apply(null,arguments)},o._Sigmoid=function(){return(o._Sigmoid=o.asm.Sigmoid).apply(null,arguments)},o._Sign=function(){return(o._Sign=o.asm.Sign).apply(null,arguments)},o._Sin=function(){return(o._Sin=o.asm.Sin).apply(null,arguments)},o._Softmax=function(){return(o._Softmax=o.asm.Softmax).apply(null,arguments)},o._Softplus=function(){return(o._Softplus=o.asm.Softplus).apply(null,arguments)},o._SparseFillEmptyRows=function(){return(o._SparseFillEmptyRows=o.asm.SparseFillEmptyRows).apply(null,arguments)},o._SparseReshape=function(){return(o._SparseReshape=o.asm.SparseReshape).apply(null,arguments)},o._SparseSegmentReduction=function(){return(o._SparseSegmentReduction=o.asm.SparseSegmentReduction).apply(null,arguments)},o._SparseToDense=function(){return(o._SparseToDense=o.asm.SparseToDense).apply(null,arguments)},o._Sqrt=function(){return(o._Sqrt=o.asm.Sqrt).apply(null,arguments)},o._Square=function(){return(o._Square=o.asm.Square).apply(null,arguments)},o._SquaredDifference=function(){return(o._SquaredDifference=o.asm.SquaredDifference).apply(null,arguments)},o._Step=function(){return(o._Step=o.asm.Step).apply(null,arguments)},o._StridedSlice=function(){return(o._StridedSlice=o.asm.StridedSlice).apply(null,arguments)},o._Sub=function(){return(o._Sub=o.asm.Sub).apply(null,arguments)},o._Sum=function(){return(o._Sum=o.asm.Sum).apply(null,arguments)},o._Tan=function(){return(o._Tan=o.asm.Tan).apply(null,arguments)},o._Tanh=function(){return(o._Tanh=o.asm.Tanh).apply(null,arguments)},o._TensorScatterUpdate=function(){return(o._TensorScatterUpdate=o.asm.TensorScatterUpdate).apply(null,arguments)},o._Tile=function(){return(o._Tile=o.asm.Tile).apply(null,arguments)},o._TopK=function(){return(o._TopK=o.asm.TopK).apply(null,arguments)},o._Transform=function(){return(o._Transform=o.asm.Transform).apply(null,arguments)},o._Transpose=function(){return(o._Transpose=o.asm.Transpose).apply(null,arguments)},o.__FusedMatMul=function(){return(o.__FusedMatMul=o.asm._FusedMatMul).apply(null,arguments)},o._malloc=function(){return(o._malloc=o.asm.malloc).apply(null,arguments)},o._free=function(){return(o._free=o.asm.free).apply(null,arguments)},o.___errno_location=function(){return(o.___errno_location=o.asm.__errno_location).apply(null,arguments)},o.stackSave=function(){return(tt=o.stackSave=o.asm.stackSave).apply(null,arguments)}),et=o.stackRestore=function(){return(et=o.stackRestore=o.asm.stackRestore).apply(null,arguments)},nt=o.stackAlloc=function(){return(nt=o.stackAlloc=o.asm.stackAlloc).apply(null,arguments)};function rt(t){function n(){J||(J=!0,o.calledRun=!0,k||(j(O),e(o),o.onRuntimeInitialized&&o.onRuntimeInitialized(),function(){if(o.postRun)for("function"==typeof o.postRun&&(o.postRun=[o.postRun]);o.postRun.length;)t=o.postRun.shift(),R.unshift(t);var t;j(R)}()))}t=t||d,I>0||(function(){if(o.preRun)for("function"==typeof o.preRun&&(o.preRun=[o.preRun]);o.preRun.length;)t=o.preRun.shift(),$.unshift(t);var t;j($)}(),I>0||(o.setStatus?(o.setStatus("Running..."),setTimeout((function(){setTimeout((function(){o.setStatus("")}),1),n()}),1)):n()))}if(o.dynCall_iijjiiii=function(){return(o.dynCall_iijjiiii=o.asm.dynCall_iijjiiii).apply(null,arguments)},o.dynCall_jiji=function(){return(o.dynCall_jiji=o.asm.dynCall_jiji).apply(null,arguments)},o.cwrap=function(t,e,n,r){var a=(n=n||[]).every((t=>"number"===t||"boolean"===t));return"string"!==e&&a&&!r?Q(t):function(){return X(t,e,n,arguments)}},L=function t(){J||rt(),J||(L=t)},o.preInit)for("function"==typeof o.preInit&&(o.preInit=[o.preInit]);o.preInit.length>0;)o.preInit.pop()();if(rt(),s&&(K={uncaughtException:process.listeners("uncaughtException").filter((function(t){return!s.uncaughtException.indexOf(t)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(t){return!s.unhandledRejection.indexOf(t)>-1}))}),"undefined"!=typeof t)Z=t;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");Z=WasmBackendModuleThreadedSimd}if(K){var at=Z._dispose;Z._dispose=function(){at(),K.uncaughtException.forEach((function(t){process.removeListener("uncaughtException",t)})),K.unhandledRejection.forEach((function(t){process.removeListener("unhandledRejection",t)}))}}return t.ready});t.exports=a},710:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},s={};function o(t,e){var n,r,o;return e?(o=0<=(t>>>=0)&&t<256)&&(r=s[t])?r:(n=u(t,(0|t)<0?-1:0,!0),o&&(s[t]=n),n):(o=-128<=(t|=0)&&t<128)&&(r=a[t])?r:(n=u(t,t<0?-1:0,!1),o&&(a[t]=n),n)}function i(t,e){if(isNaN(t))return e?b:y;if(e){if(t<0)return b;if(t>=m)return T}else{if(t<=-f)return S;if(t+1>=f)return v}return t<0?i(-t,e).neg():u(t%p|0,t/p|0,e)}function u(t,e,r){return new n(t,e,r)}n.fromInt=o,n.fromNumber=i,n.fromBits=u;var l=Math.pow;function c(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return y;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(t.substring(1),e,n).neg();for(var a=i(l(n,8)),s=y,o=0;o<t.length;o+=8){var u=Math.min(8,t.length-o),d=parseInt(t.substring(o,o+u),n);if(u<8){var p=i(l(n,u));s=s.mul(p).add(i(d))}else s=(s=s.mul(a)).add(i(d))}return s.unsigned=e,s}function d(t,e){return"number"==typeof t?i(t,e):"string"==typeof t?c(t,e):u(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}n.fromString=c,n.fromValue=d;var p=4294967296,m=p*p,f=m/2,h=o(1<<24),y=o(0);n.ZERO=y;var b=o(0,!0);n.UZERO=b;var g=o(1);n.ONE=g;var w=o(1,!0);n.UONE=w;var _=o(-1);n.NEG_ONE=_;var v=u(-1,2147483647,!1);n.MAX_VALUE=v;var T=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=T;var S=u(0,-2147483648,!1);n.MIN_VALUE=S;var N=n.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},N.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var e=i(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var a=i(l(t,6),this.unsigned),s=this,o="";;){var u=s.div(a),c=(s.sub(u.mul(a)).toInt()>>>0).toString(t);if((s=u).isZero())return c+o;for(;c.length<6;)c="0"+c;o=""+c+o}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&!(t&1<<e);e--);return 0!=this.high?e+33:e+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return!(1&~this.low)},N.isEven=function(){return!(1&this.low)},N.equals=function(t){return r(t)||(t=d(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&(this.high===t.high&&this.low===t.low)},N.eq=N.equals,N.notEquals=function(t){return!this.eq(t)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(t){return this.comp(t)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(t){return this.comp(t)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(t){return this.comp(t)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(t){return this.comp(t)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(t){if(r(t)||(t=d(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(g)},N.neg=N.negate,N.add=function(t){r(t)||(t=d(t));var e=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,o=t.high>>>16,i=65535&t.high,l=t.low>>>16,c=0,p=0,m=0,f=0;return m+=(f+=s+(65535&t.low))>>>16,p+=(m+=a+l)>>>16,c+=(p+=n+i)>>>16,c+=e+o,u((m&=65535)<<16|(f&=65535),(c&=65535)<<16|(p&=65535),this.unsigned)},N.subtract=function(t){return r(t)||(t=d(t)),this.add(t.neg())},N.sub=N.subtract,N.multiply=function(t){if(this.isZero())return y;if(r(t)||(t=d(t)),e)return u(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return y;if(this.eq(S))return t.isOdd()?S:y;if(t.eq(S))return this.isOdd()?S:y;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(h)&&t.lt(h))return i(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,s=this.low>>>16,o=65535&this.low,l=t.high>>>16,c=65535&t.high,p=t.low>>>16,m=65535&t.low,f=0,b=0,g=0,w=0;return g+=(w+=o*m)>>>16,b+=(g+=s*m)>>>16,g&=65535,b+=(g+=o*p)>>>16,f+=(b+=a*m)>>>16,b&=65535,f+=(b+=s*p)>>>16,b&=65535,f+=(b+=o*c)>>>16,f+=n*m+a*p+s*c+o*l,u((g&=65535)<<16|(w&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(t){if(r(t)||(t=d(t)),t.isZero())throw Error("division by zero");var n,a,s;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?u((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:y;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return b;if(t.gt(this.shru(1)))return w;s=b}else{if(this.eq(S))return t.eq(g)||t.eq(_)?S:t.eq(S)?g:(n=this.shr(1).div(t).shl(1)).eq(y)?t.isNegative()?g:_:(a=this.sub(t.mul(n)),s=n.add(a.div(t)));if(t.eq(S))return this.unsigned?b:y;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=y}for(a=this;a.gte(t);){n=Math.max(1,Math.floor(a.toNumber()/t.toNumber()));for(var o=Math.ceil(Math.log(n)/Math.LN2),c=o<=48?1:l(2,o-48),p=i(n),m=p.mul(t);m.isNegative()||m.gt(a);)m=(p=i(n-=c,this.unsigned)).mul(t);p.isZero()&&(p=g),s=s.add(p),a=a.sub(m)}return s},N.div=N.divide,N.modulo=function(t){return r(t)||(t=d(t)),e?u((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return u(~this.low,~this.high,this.unsigned)},N.and=function(t){return r(t)||(t=d(t)),u(this.low&t.low,this.high&t.high,this.unsigned)},N.or=function(t){return r(t)||(t=d(t)),u(this.low|t.low,this.high|t.high,this.unsigned)},N.xor=function(t){return r(t)||(t=d(t)),u(this.low^t.low,this.high^t.high,this.unsigned)},N.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):u(0,this.low<<t-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):u(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0===(t&=63))return this;var e=this.high;return t<32?u(this.low>>>t|e<<32-t,e>>>t,this.unsigned):u(32===t?e:e>>>t-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},N.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},N.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},307:(t,e,n)=>{var r=n(160),a=n(169),s=n(723),o=n(383),i=n(237),u=n(65),l=n(77);l.alea=r,l.xor128=a,l.xorwow=s,l.xorshift7=o,l.xor4096=i,l.tychei=u,t.exports=l},160:function(t,e,n){var r;!function(t,a){function s(t){var e=this,n=function(){var t=4022871197,e=function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)};return e}();e.next=function(){var t=2091639*e.s0+2.3283064365386963e-10*e.c;return e.s0=e.s1,e.s1=e.s2,e.s2=t-(e.c=0|t)},e.c=1,e.s0=n(" "),e.s1=n(" "),e.s2=n(" "),e.s0-=n(t),e.s0<0&&(e.s0+=1),e.s1-=n(t),e.s1<0&&(e.s1+=1),e.s2-=n(t),e.s2<0&&(e.s2+=1),n=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function i(t,e){var n=new s(t),r=e&&e.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&o(r,n),a.state=function(){return o(n,{})}),a}a&&a.exports?a.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,a))||(a.exports=r):this.alea=i}(0,t=n.nmd(t),n.amdD)},65:function(t,e,n){var r;!function(t,a){function s(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,a=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^a,e.a=a-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function i(t,e){var n=new s(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&o(r,n),a.state=function(){return o(n,{})}),a}a&&a.exports?a.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,a))||(a.exports=r):this.tychei=i}(0,t=n.nmd(t),n.amdD)},169:function(t,e,n){var r;!function(t,a){function s(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function i(t,e){var n=new s(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&o(r,n),a.state=function(){return o(n,{})}),a}a&&a.exports?a.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,a))||(a.exports=r):this.xor128=i}(0,t=n.nmd(t),n.amdD)},237:function(t,e,n){var r;!function(t,a){function s(t){var e=this;e.next=function(){var t,n,r=e.w,a=e.X,s=e.i;return e.w=r=r+1640531527|0,n=a[s+34&127],t=a[s=s+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=a[s]=n^t,e.i=s,n+(r^r>>>16)|0},function(t,e){var n,r,a,s,o,i=[],u=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,u=Math.max(u,e.length)),a=0,s=-32;s<u;++s)e&&(r^=e.charCodeAt((s+32)%e.length)),0===s&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(o=o+1640531527|0,a=0==(n=i[127&s]^=r+o)?a+1:0);for(a>=128&&(i[127&(e&&e.length||0)]=-1),a=127,s=512;s>0;--s)r=i[a+34&127],n=i[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[a]=r^n;t.w=o,t.X=i,t.i=a}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function i(t,e){null==t&&(t=+new Date);var n=new s(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&(r.X&&o(r,n),a.state=function(){return o(n,{})}),a}a&&a.exports?a.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,a))||(a.exports=r):this.xor4096=i}(0,t=n.nmd(t),n.amdD)},383:function(t,e,n){var r;!function(t,a){function s(t){var e=this;e.next=function(){var t,n,r=e.x,a=e.i;return t=r[a],n=(t^=t>>>7)^t<<24,n^=(t=r[a+1&7])^t>>>10,n^=(t=r[a+3&7])^t>>>3,n^=(t=r[a+4&7])^t<<7,t=r[a+7&7],n^=(t^=t<<13)^t<<9,r[a]=n,e.i=a+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function i(t,e){null==t&&(t=+new Date);var n=new s(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&(r.x&&o(r,n),a.state=function(){return o(n,{})}),a}a&&a.exports?a.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,a))||(a.exports=r):this.xorshift7=i}(0,t=n.nmd(t),n.amdD)},723:function(t,e,n){var r;!function(t,a){function s(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function i(t,e){var n=new s(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&o(r,n),a.state=function(){return o(n,{})}),a}a&&a.exports?a.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,a))||(a.exports=r):this.xorwow=i}(0,t=n.nmd(t),n.amdD)},77:function(t,e,n){var r;!function(a,s,o){var i,u=256,l=o.pow(u,6),c=o.pow(2,52),d=2*c,p=255;function m(t,e,n){var r=[],p=b(y((e=1==e?{entropy:!0}:e||{}).entropy?[t,g(s)]:null==t?function(){try{var t;return i&&(t=i.randomBytes)?t=t(u):(t=new Uint8Array(u),(a.crypto||a.msCrypto).getRandomValues(t)),g(t)}catch(t){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,g(s)]}}():t,3),r),m=new f(r),w=function(){for(var t=m.g(6),e=l,n=0;t<c;)t=(t+n)*u,e*=u,n=m.g(1);for(;t>=d;)t/=2,e/=2,n>>>=1;return(t+n)/e};return w.int32=function(){return 0|m.g(4)},w.quick=function(){return m.g(4)/4294967296},w.double=w,b(g(m.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&h(r,m),t.state=function(){return h(m,{})}),n?(o.random=t,e):t})(w,p,"global"in e?e.global:this==o,e.state)}function f(t){var e,n=t.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(t=[n++]);a<u;)o[a]=a++;for(a=0;a<u;a++)o[a]=o[s=p&s+t[a%n]+(e=o[a])],o[s]=e;(r.g=function(t){for(var e,n=0,a=r.i,s=r.j,o=r.S;t--;)e=o[a=p&a+1],n=n*u+o[p&(o[a]=o[s=p&s+e])+(o[s]=e)];return r.i=a,r.j=s,n})(u)}function h(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function y(t,e){var n,r=[],a=typeof t;if(e&&"object"==a)for(n in t)try{r.push(y(t[n],e-1))}catch(t){}return r.length?r:"string"==a?t:t+"\0"}function b(t,e){for(var n,r=t+"",a=0;a<r.length;)e[p&a]=p&(n^=19*e[p&a])+r.charCodeAt(a++);return g(e)}function g(t){return String.fromCharCode.apply(0,t)}if(b(o.random(),s),t.exports){t.exports=m;try{i=n(382)}catch(t){}}else void 0===(r=function(){return m}.call(e,n,e,t))||(t.exports=r)}("undefined"!=typeof self?self:this,[],Math)},465:()=>{},614:()=>{},981:()=>{},520:()=>{},880:()=>{},661:()=>{},282:()=>{},382:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var s=e[r]={id:r,loaded:!1,exports:{}};return t[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.nmd=t=>(t.paths=[],t.children||(t.children=[]),t),(()=>{"use strict";var t={};n.r(t),n.d(t,{browserFiles:()=>Ns,browserHTTPRequest:()=>Os,concatenateArrayBuffers:()=>ea,copyModel:()=>Ba,decodeWeights:()=>Kr,encodeWeights:()=>Jr,fromMemory:()=>Ls,fromMemorySync:()=>zs,getLoadHandlers:()=>ma,getModelArtifactsForJSON:()=>sa,getModelArtifactsForJSONSync:()=>aa,getModelArtifactsInfoForJSON:()=>oa,getSaveHandlers:()=>pa,getWeightSpecs:()=>ia,http:()=>$s,isHTTPScheme:()=>Ps,listModels:()=>za,loadWeights:()=>As,moveModel:()=>Ua,registerLoadRouter:()=>da,registerSaveRouter:()=>ca,removeModel:()=>Va,weightsLoaderFactory:()=>Ds,withSaveHandler:()=>Vs,withSaveHandlerSync:()=>Bs});var e={};n.r(e),n.d(e,{conv2d:()=>oc,depthwiseConv2d:()=>lc,matMul:()=>cc});var r={};n.r(r),n.d(r,{json:()=>Cd});var a={};n.r(a),n.d(a,{json:()=>Ad});var s={};n.r(s),n.d(s,{json:()=>Dd});var o={};n.r(o),n.d(o,{json:()=>Ed});var i={};n.r(i),n.d(i,{json:()=>Pd});var u={};n.r(u),n.d(u,{json:()=>Fd});var l={};n.r(l),n.d(l,{json:()=>$d});var c={};n.r(c),n.d(c,{json:()=>Od});var d={};n.r(d),n.d(d,{json:()=>Rd});var p={};n.r(p),n.d(p,{json:()=>Id});var m={};n.r(m),n.d(m,{json:()=>Md});var f={};n.r(f),n.d(f,{json:()=>Ld});var h={};n.r(h),n.d(h,{json:()=>zd});var y={};n.r(y),n.d(y,{json:()=>Vd});var b={};n.r(b),n.d(b,{json:()=>Bd});var g={};n.r(g),n.d(g,{json:()=>Ud});var w={};n.r(w),n.d(w,{json:()=>Wd});var _={};n.r(_),n.d(_,{json:()=>jd});var v={};n.r(v),n.d(v,{json:()=>qd});var T={};n.r(T),n.d(T,{OP_SCOPE_SUFFIX:()=>Wr,abs:()=>ys,acos:()=>Ys,acosh:()=>to,add:()=>ts,addN:()=>eo,all:()=>no,any:()=>ro,argMax:()=>ao,argMin:()=>so,asin:()=>oo,asinh:()=>io,atan:()=>uo,atan2:()=>lo,atanh:()=>co,avgPool:()=>Ao,avgPool3d:()=>Do,basicLSTMCell:()=>Ro,batchNorm:()=>Mo,batchNorm2d:()=>Lo,batchNorm3d:()=>zo,batchNorm4d:()=>Vo,batchToSpaceND:()=>Io,bincount:()=>Bo,bitwiseAnd:()=>Uo,booleanMaskAsync:()=>ql,broadcastArgs:()=>Wo,broadcastTo:()=>jo,buffer:()=>Ga,cast:()=>Qa,ceil:()=>qo,clipByValue:()=>Ho,clone:()=>Xa,complex:()=>qr,concat:()=>Eo,concat1d:()=>Go,concat2d:()=>Qo,concat3d:()=>Xo,concat4d:()=>Jo,conv1d:()=>Zo,conv2d:()=>Ko,conv2dTranspose:()=>ti,conv3d:()=>ei,conv3dTranspose:()=>ri,cos:()=>ai,cosh:()=>si,cosineWindow:()=>Yl,cumprod:()=>oi,cumsum:()=>ii,denseBincount:()=>ui,depthToSpace:()=>li,depthwiseConv2d:()=>ci,diag:()=>di,dilation2d:()=>pi,div:()=>ns,divNoNan:()=>hi,dot:()=>yi,dropout:()=>Kl,einsum:()=>bi,elu:()=>gi,enclosingPowerOfTwo:()=>Zl,ensureShape:()=>wi,equal:()=>mi,erf:()=>_i,euclideanNorm:()=>$i,exp:()=>Oi,expandDims:()=>Ri,expm1:()=>Ii,eye:()=>Li,fft:()=>_l,fill:()=>ms,floor:()=>zi,floorDiv:()=>es,fused:()=>e,gather:()=>Vi,gatherND:()=>Jl,greater:()=>Bi,greaterEqual:()=>Ui,ifft:()=>vl,imag:()=>Wi,image:()=>rd,inTopKAsync:()=>tc,irfft:()=>Tl,isFinite:()=>ji,isInf:()=>qi,isNaN:()=>Hi,leakyRelu:()=>Gi,less:()=>Qi,lessEqual:()=>Xi,linalg:()=>ad,linspace:()=>Ji,localResponseNormalization:()=>Ki,log:()=>Zi,log1p:()=>Yi,logSigmoid:()=>nu,logSoftmax:()=>ru,logSumExp:()=>au,logicalAnd:()=>su,logicalNot:()=>ou,logicalOr:()=>iu,logicalXor:()=>uu,losses:()=>sd,lowerBound:()=>du,matMul:()=>Po,max:()=>Ai,maxPool:()=>pu,maxPool3d:()=>mu,maxPoolWithArgmax:()=>fu,maximum:()=>gs,mean:()=>hu,meshgrid:()=>gu,min:()=>Di,minimum:()=>wu,mirrorPad:()=>_u,mod:()=>vu,moments:()=>Tu,movingAverage:()=>Gl,mul:()=>rs,multiRNNCell:()=>Su,multinomial:()=>Nu,neg:()=>tu,norm:()=>Fi,notEqual:()=>xu,oneHot:()=>ku,ones:()=>bu,onesLike:()=>Cu,op:()=>jr,outerProduct:()=>Au,pad:()=>Du,pad1d:()=>Eu,pad2d:()=>Pu,pad3d:()=>Fu,pad4d:()=>$u,pool:()=>Ru,pow:()=>fs,prelu:()=>Iu,print:()=>Ja,prod:()=>Mu,raggedGather:()=>Lu,raggedRange:()=>zu,raggedTensorToTensor:()=>Vu,rand:()=>Bu,randomGamma:()=>Hu,randomNormal:()=>Gu,randomStandardNormal:()=>Qu,randomUniform:()=>Xu,randomUniformInt:()=>Ju,range:()=>Ku,real:()=>Zu,reciprocal:()=>Yu,relu:()=>tl,relu6:()=>el,reshape:()=>Co,reverse:()=>nl,reverse1d:()=>rl,reverse2d:()=>al,reverse3d:()=>sl,reverse4d:()=>ol,rfft:()=>Nl,round:()=>il,rsqrt:()=>ul,scalar:()=>us,scatterND:()=>Ql,searchSorted:()=>cu,selu:()=>ll,separableConv2d:()=>cl,setdiff1dAsync:()=>dl,sigmoid:()=>Fo,sign:()=>pl,signal:()=>nd,sin:()=>ml,sinh:()=>fl,slice:()=>$o,slice1d:()=>hl,slice2d:()=>yl,slice3d:()=>bl,slice4d:()=>gl,softmax:()=>wl,softplus:()=>eu,spaceToBatchND:()=>Ou,sparse:()=>od,sparseToDense:()=>Xl,spectral:()=>ed,split:()=>Sl,sqrt:()=>as,square:()=>ss,squaredDifference:()=>xl,squeeze:()=>kl,stack:()=>Cl,step:()=>Al,stridedSlice:()=>Dl,string:()=>id,sub:()=>hs,sum:()=>Ei,tan:()=>El,tanh:()=>Oo,tensor:()=>Gr,tensor1d:()=>Pl,tensor2d:()=>Fl,tensor3d:()=>Us,tensor4d:()=>$l,tensor5d:()=>Ol,tensor6d:()=>Rl,tensorScatterUpdate:()=>Il,tile:()=>Mi,topk:()=>Ml,transpose:()=>Hl,truncatedNormal:()=>Ll,unique:()=>zl,unsortedSegmentSum:()=>Vl,unstack:()=>Bl,upperBound:()=>Ul,variable:()=>Wl,where:()=>fi,whereAsync:()=>jl,zeros:()=>yu,zerosLike:()=>os});class S{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class N{refCount(t){return x("refCount")}incRef(t){return x("incRef")}timerAvailable(){return!0}time(t){return x("time")}read(t){return x("read")}readSync(t){return x("readSync")}readToGPU(t,e){return x("readToGPU")}numDataIds(){return x("numDataIds")}disposeData(t,e){return x("disposeData")}write(t,e,n){return x("write")}move(t,e,n,r,a){return x("move")}createTensorFromGPUData(t,e,n){return x("createTensorFromGPUData")}memory(){return x("memory")}floatPrecision(){return x("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return x("dispose")}}function x(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function k(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function C(t,e,n=""){k(E(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}function A(t){k(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function D(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function E(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function P(t){return t%1==0}function F(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function $(t,e){const n=e.length;return k((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),k(t.every((t=>P(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function O(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function R(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function I(t){return"string"==typeof t||t instanceof String}function M(t){return Array.isArray(t)?M(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":"number"==typeof t?"float32":I(t)?"string":function(t){return"boolean"==typeof t}(t)?"bool":"float32"}function L(t){return!!(t&&t.constructor&&t.call&&t.apply)}function z(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function V(t,e,n,r=!1){const a=new Array;if(1===e.length){const s=e[0]*(r?2:1);for(let e=0;e<s;e++)a[e]=n[t+e]}else{const s=e[0],o=e.slice(1),i=o.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<s;e++)a[e]=V(t+e*i,o,n,r)}return a}function B(t,e,n=!1){if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return V(0,t,e,n)}function U(t,e){const n=W(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function W(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function j(t){t.forEach((e=>{k(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}function q(t){return t&&t.then&&"function"==typeof t.then}const H="tfjsflags";class G{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Q,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(X().getBool("IS_TEST")||X().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];X().getBool("IS_TEST")||X().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(q(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"==typeof this.global||"undefined"==typeof this.global.location||"undefined"==typeof this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(H in t){t[H].split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){const n=e.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:e}(0,n)}))}}}function Q(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}function X(){return K}let J,K=null;function Z(){if(null==J){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof n.g)t=n.g;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}J=t}return J}function Y(t,e){const n=function(){const t=Z();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const tt="Acos",et="Acosh",nt="Add",rt="AddN",at="All",st="Any",ot="ArgMax",it="ArgMin",ut="Asin",lt="Asinh",ct="Atan",dt="Atanh",pt="Atan2",mt="AvgPool",ft="AvgPool3D",ht="BatchMatMul",yt="BatchToSpaceND",bt="Bincount",gt="BroadcastArgs",wt="Cast",_t="Ceil",vt="ClipByValue",Tt="Concat",St="Conv2D",Nt="Conv2DBackpropInput",xt="Conv3D",kt="Conv3DBackpropFilterV2",Ct="Conv3DBackpropInputV2",At="Cosh",Dt="Cumprod",Et="Cumsum",Pt="CropAndResize",Ft="DenseBincount",$t="DepthToSpace",Ot="DepthwiseConv2dNative",Rt="Diag",It="Dilation2D",Mt="Dilation2DBackpropInput",Lt="Dilation2DBackpropFilter",zt="RealDiv",Vt="EluGrad",Bt="Equal",Ut="ExpandDims",Wt="Expm1",jt="Fill",qt="FlipLeftRight",Ht="Floor",Gt="FloorDiv",Qt="FusedBatchNorm",Xt="GatherV2",Jt="GatherNd",Kt="Greater",Zt="GreaterEqual",Yt="Identity",te="IsFinite",ee="IsInf",ne="IsNan",re="LeakyRelu",ae="Less",se="LessEqual",oe="LinSpace",ie="Log1p",ue="LogicalAnd",le="LogicalNot",ce="LogicalOr",de="LRN",pe="LRNGrad",me="Max",fe="Maximum",he="MaxPool",ye="MaxPool3D",be="Mean",ge="Min",we="Minimum",_e="MirrorPad",ve="Multinomial",Te="Multiply",Se="NotEqual",Ne="NonMaxSuppressionV3",xe="NonMaxSuppressionV4",ke="NonMaxSuppressionV5",Ce="OnesLike",Ae="OneHot",De="Pack",Ee="PadV2",Pe="Prelu",Fe="Prod",$e="Range",Oe="Reciprocal",Re="Relu",Ie="Reshape",Me="ResizeNearestNeighbor",Le="ResizeNearestNeighborGrad",ze="ResizeBilinear",Ve="ResizeBilinearGrad",Be="Relu6",Ue="Reverse",We="Round",je="Rsqrt",qe="ScatterNd",He="TensorScatterUpdate",Ge="SearchSorted",Qe="Select",Xe="Selu",Je="Slice",Ke="Sign",Ze="Sigmoid",Ye="Softplus",tn="Sqrt",en="Sum",nn="SpaceToBatchND",rn="SplitV",an="Softmax",sn="SparseFillEmptyRows",on="SparseReshape",un="SparseSegmentMean",ln="SparseSegmentSum",cn="SparseToDense",dn="SquaredDifference",pn="StridedSlice",mn="StringNGrams",fn="StringSplit",hn="StringToHashBucketFast",yn="Tanh",bn="Tile",gn="TopK",wn="Transform",_n="Transpose",vn="Unique",Tn="Unpack",Sn="ZerosLike",Nn="Step",xn="FromPixels",kn="RotateWithOffset",Cn="_FusedMatMul",An="FusedConv2D",Dn="FusedDepthwiseConv2D";function En(...t){X().getBool("IS_TEST")||X().getBool("PROD")||console.warn(...t)}const Pn=Y("kernelRegistry",(()=>new Map)),Fn=Y("gradRegistry",(()=>new Map));function $n(t,e){const n=Mn(t,e);return Pn.get(n)}function On(t){return Fn.get(t)}function Rn(t){const e=Pn.entries(),n=[];for(;;){const{done:r,value:a}=e.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===t&&n.push(o)}return n}function In(t){const{kernelName:e,backendName:n}=t,r=Mn(e,n);Pn.has(r)&&En(`The kernel '${e}' for backend '${n}' is already registered`),Pn.set(r,t)}function Mn(t,e){return`${e}_${t}`}function Ln(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var zn=n(710);const Vn=n.n(zn)()||zn;function Bn(t){return Vn.fromString(t,!0,16)}const Un=Bn("c3a5c85c97cb3127"),Wn=Bn("b492b66fbe98f273"),jn=Bn("9ae16a3b2f90404f");function qn(t){return t.xor(t.shru(47))}function Hn(t,e,n){const r=t.slice(e,e+n);return Vn.fromBytes(Array.from(r),!0,!0)}function Gn(t,e){return Hn(t,e,8)}function Qn(t,e){return Hn(t,e,4)}function Xn(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function Jn(t,e,n=Bn("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let a=e.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function Kn(t,e,n,r){return function(t,e,n,r,a,s){a=a.add(t),s=Xn(s.add(a).add(r),21);const o=a;return a=(a=a.add(e)).add(n),s=s.add(Xn(a,44)),[a.add(r),s.add(o)]}(Gn(t,e),Gn(t,e+8),Gn(t,e+16),Gn(t,e+24),n,r)}function Zn(t,e=t.length){const n=Vn.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=jn.add(2*e),r=Gn(t,0).add(jn),a=Gn(t,e-8);return Jn(Xn(a,37).mul(n).add(r),Xn(r,25).add(a).mul(n),n)}if(e>=4){const n=jn.add(2*e);return Jn(Qn(t,0).shl(3).add(e),Qn(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return qn(jn.mul(n).xor(Un.mul(r))).mul(jn)}return jn}(t,e):function(t,e=t.length){const n=jn.add(2*e),r=Gn(t,0).mul(Wn),a=Gn(t,8),s=Gn(t,e-8).mul(n),o=Gn(t,e-16).mul(jn);return Jn(Xn(r.add(a),43).add(Xn(s,30)).add(o),r.add(Xn(a.add(jn),18)).add(s),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=jn.add(2*e),r=Gn(t,0).mul(jn),a=Gn(t,8),s=Gn(t,e-8).mul(n),o=Gn(t,e-16).mul(jn),i=Xn(r.add(a),43).add(Xn(s,30)).add(o),u=Jn(i,r.add(Xn(a.add(jn),18)).add(s),n),l=Gn(t,16).mul(n),c=Gn(t,24),d=i.add(Gn(t,e-32)).mul(n),p=u.add(Gn(t,e-24)).mul(n);return Jn(Xn(l.add(c),43).add(Xn(d,30)).add(p),l.add(Xn(c.add(r),18)).add(d),n)}(t,e);let r=n,a=n.mul(Wn).add(113),s=qn(a.mul(jn).add(113)).mul(jn),o=[Vn.UZERO,Vn.UZERO],i=[Vn.UZERO,Vn.UZERO];r=r.mul(jn).add(Gn(t,0));let u=0;const l=64*(e-1>>6),c=l+(e-1&63)-63;do{r=Xn(r.add(a).add(o[0]).add(Gn(t,u+8)),37).mul(Wn),a=Xn(a.add(o[1]).add(Gn(t,u+48)),42).mul(Wn),r=r.xor(i[1]),a=a.add(o[0]).add(Gn(t,u+40)),s=Xn(s.add(i[0]),33).mul(Wn),o=Kn(t,u,o[1].mul(Wn),r.add(i[0])),i=Kn(t,u+32,s.add(i[1]),a.add(Gn(t,u+16))),[s,r]=[r,s],u+=64}while(u!==l);const d=Wn.add(s.and(255).shl(1));return u=c,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=Xn(r.add(a).add(o[0]).add(Gn(t,u+8)),37).mul(d),a=Xn(a.add(o[1]).add(Gn(t,u+48)),42).mul(d),r=r.xor(i[1].mul(9)),a=a.add(o[0].mul(9).add(Gn(t,u+40))),s=Xn(s.add(i[0]),33).mul(d),o=Kn(t,u,o[1].mul(d),r.add(i[0])),i=Kn(t,u+32,s.add(i[1]),a.add(Gn(t,u+16))),[s,r]=[r,s],Jn(Jn(o[0],i[0],d).add(qn(a).mul(Un)).add(s),Jn(o[1],i[1],d).add(r),d)}function Yn(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=ar(t)),X().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function tr(){return X().platform.now()}function er(t,e="utf-8"){return e=e||"utf-8",X().platform.encode(t,e)}function nr(t,e="utf-8"){return e=e||"utf-8",X().platform.decode(t,e)}function rr(t){return null!=X().platform.isTypedArray?X().platform.isTypedArray(t):Ln(t)}function ar(t,e=[],n=!1){if(null==e&&(e=[]),"boolean"==typeof t||"number"==typeof t||"string"==typeof t||q(t)||null==t||rr(t)&&n)e.push(t);else if(Array.isArray(t)||rr(t))for(let r=0;r<t.length;++r)ar(t[r],e,n);else{let r=-1;for(const e of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(e)&&(r=Math.max(r,Number(e)));for(let a=0;a<=r;a++)ar(t[a],e,n)}return e}class sr{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new ir)}profileKernel(t,e,n){let r;const a=()=>{r=n()};let s;const o=tr();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const t of r)t.dataSync();s=Promise.resolve({kernelMs:tr()-o})}if(X().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{or(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:a,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],a,n[2])}))}))}}function or(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class ir{logKernelProfile(t,e,n,r,a,s){const o="number"==typeof r?F(`${r}ms`,9):r.error,i=F(t,25),u=e.rank,l=e.size,c=F(e.shape.toString(),14);let d="";for(const t in a){const n=a[t];if(null!=n){const r=n.shape||e.shape,a=r.length;d+=`${t}: ${a}D ${a>0?r:""} `}}console.log(`%c${i}\t%c${o}\t%c${u}D ${c}\t%c${l}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ur(t,e,n,r){const a=z(e),s=function(t,e,n,r){const a=D(e),s=r[r.length-1],o=new Array(s).fill(0),i=e.length,u="complex64"===n?pr(t):t;if(i>1)for(let t=0;t<a/s;t++){const e=t*s;for(let t=0;t<s;t++)o[t]=Math.max(o[t],lr(u[e+t],0,n).length)}return o}(t,e,n,a),o=e.length,i=dr(t,e,n,a,s),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map((t=>"    "+t)).join("\n")),u.join("\n")}function lr(t,e,n){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:I(t)?`'${t}'`:"bool"===n?cr(t):parseFloat(t.toFixed(7)).toString(),F(r,e)}function cr(t){return 0===t?"false":"true"}function dr(t,e,n,r,a,s=!0){const o="complex64"===n?2:1,i=e[0],u=e.length;if(0===u){if("complex64"===n){return[lr(pr(t)[0],0,n)]}return"bool"===n?[cr(t[0])]:[t[0].toString()]}if(1===u){if(i>20){const e=3*o;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((i-3)*o,i*o));return"complex64"===n&&(r=pr(r),s=pr(s)),["["+r.map(((t,e)=>lr(t,a[e],n))).join(", ")+", ..., "+s.map(((t,e)=>lr(t,a[i-3+e],n))).join(", ")+"]"]}return["["+("complex64"===n?pr(t):Array.from(t)).map(((t,e)=>lr(t,a[e],n))).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),d=r[0]*o,p=[];if(i>20){for(let e=0;e<3;e++){const r=e*d,s=r+d;p.push(...dr(t.slice(r,s),l,n,c,a,!1))}p.push("...");for(let e=i-3;e<i;e++){const r=e*d,s=r+d;p.push(...dr(t.slice(r,s),l,n,c,a,e===i-1))}}else for(let e=0;e<i;e++){const r=e*d,s=r+d;p.push(...dr(t.slice(r,s),l,n,c,a,e===i-1))}const m=2===u?",":"";p[0]="["+(i>0?p[0]+m:"");for(let t=1;t<p.length-1;t++)p[t]=" "+p[t]+m;let f=",\n";for(let t=2;t<u;t++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(s?"":f),p}function pr(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class mr{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=D(t),null!=n){const t=n.length;k(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||O(e,this.size),this.strides=z(t)}set(t,...e){0===e.length&&(e=[0]),k(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return fr().makeTensor(this.values,this.shape,this.dtype)}}let fr=null,hr=null,yr=null;class br{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=D(t),this.strides=z(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return hr.buffer(this.shape,this.dtype,t)}bufferSync(){return hr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return B(this.shape,t,"complex64"===this.dtype)}arraySync(){return B(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=fr().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>nr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),fr().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=fr().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>nr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await fr().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(fr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return hr.print(this,t)}clone(){return this.throwIfDisposed(),hr.clone(this)}toString(t=!1){return ur(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),hr.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),fr().makeVariable(this,t,e,n)}}Object.defineProperty(br,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),Y("Tensor",(()=>br));class gr extends br{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!E(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);fr().disposeTensor(this),this.dataId=t.dataId,fr().incRef(this,null)}dispose(){fr().disposeVariable(this),this.isDisposedInternal=!0}}var wr,_r,vr,Tr,Sr;Object.defineProperty(gr,Symbol.hasInstance,{value:t=>t instanceof br&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(wr||(wr={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(_r||(_r={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(vr||(vr={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Tr||(Tr={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Sr||(Sr={}));const Nr={float32:Tr,int32:_r,bool:vr,complex64:Sr};function xr(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Nr[t][e]}function kr(t){return null!=t&&"object"==typeof t&&"texture"in t&&t.texture instanceof WebGLTexture}function Cr(t){return"undefined"!=typeof GPUBuffer&&null!=t&&"object"==typeof t&&"buffer"in t&&t.buffer instanceof GPUBuffer}function Ar(t,e){if(t.dtype===e.dtype)return[t,e];const n=xr(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Dr(t){const e=[];return Er(t,e,new Set),e}function Er(t,e,n){if(null==t)return;if(t instanceof br)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const a=t;for(const t in a){const r=a[t];n.has(r)||(n.add(r),Er(r,e,n))}}function Pr(t){return null!=t.kernelName}class Fr{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class $r{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Fr}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(En(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new sr(this.backendInstance),!0}setupRegisteredKernels(){Rn(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){Rn(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof N||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,En(`Initialization of backend ${t} failed`),En(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return En(`Initialization of backend ${t} failed`),En(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,a=this.readSync(e),s=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return $r.nextTensorId++}nextVariableId(){return $r.nextVariableId++}clone(t){const e=Rr.runKernel(Yt,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return Rr.runKernel(wt,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=$n(t,this.backendName)))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let a=0;n.forEach((t=>{a+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-e-a-s;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=Pr(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Pr(t)){const{kernelName:e,inputs:a,attrs:s}=t;null==this.backendName&&this.backend;const u=$n(e,this.backendName);k(null!=u,(()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`)),o=()=>{const t=this.backend.numDataIds();i=u.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const l=o.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(e,a,l);n=this.saveTensorsForBackwardMode(t)}return l}}else{const{forwardFunc:e}=t,a=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};o=()=>{const t=this.backend.numDataIds();i=this.tidy((()=>e(this.backend,a)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,t,n),n}}const{inputs:l,attrs:c}=t,d=Pr(t)?null:t.backwardsFunc;let p;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,l,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),e=p.outputs):e=o()})),r&&this.addTapeNode(u,l,e,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((t=>null!=l[t]?l[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(i)?e:e[0]}saveTensorsForBackwardMode(t){const e=t.map((t=>this.keep(this.clone(t))));return e}getTensorsForGradient(t,e,n){const r=On(t);if(null!=r){const t=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(k(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const o=n.filter(((t,e)=>a[e]));return s.concat(o)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=t;"string"===n&&I(t[0])&&(a=t.map((t=>er(t))));const s=r.write(a,e,n),o=new br(e,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const t=this.state.tensorInfo.get(s),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(a);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const a={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:a}=t,s=new br(r,a,n,this.nextTensorId());return this.trackTensor(s,e),s}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const a=new gr(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*R(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof gr||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*R(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:a},i=On(t);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=W(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],a,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Dr(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,r=!1){if(k(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));k(a instanceof br,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},a={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const s=t[n],o=s.inputs;for(const t in o){const n=o[t];let i=!1;for(let t=0;t<e.length;t++)if(r[n.id]){s.outputs.forEach((t=>r[t.id]=!0)),i=!0,a[s.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(s[n.outputs[t].id]){for(const t in r)s[r[t].id]=!0,o[n.id]=!0;break}}const i=[];for(let e=0;e<t.length;e++){const n=t[e];if(a[n.id]&&o[n.id]){const t={};for(const e in n.inputs){const a=n.inputs[e];r[a.id]&&(t[e]=a)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,i.push(e)}}return i}(this.state.activeTape,e,a);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[a.id]=null==n?function(t){const e=U(D(t),"float32");return Rr.makeTensor(e,t,"float32")}(a.shape):n,function(t,e,n,r){for(let a=e.length-1;a>=0;a--){const s=e[a],o=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const i=s.gradient(o);for(const e in s.inputs){if(!(e in i))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(i)}.`);const a=n((()=>i[e]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${a.dtype}'`);const o=s.inputs[e];if(!E(a.shape,o.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${a.shape}', which does not match the shape of the input '${o.shape}'`);if(null==t[o.id])t[o.id]=a;else{const e=t[o.id];t[o.id]=r(e,a),e.dispose()}}}}(t,s,(t=>this.tidy(t)),Ir);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(t){return k(L(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;k(e.every((t=>t instanceof br)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};e.forEach(((t,e)=>{r[e]=t}));return this.runKernelFunc({forwardFunc:(r,a)=>(n=t(...e,a),k(n.value instanceof br,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),k(L(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(t,r)=>{const a=n.gradFunc(t,r),s=Array.isArray(a)?a:[a];k(s.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),k(s.every((t=>t instanceof br)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return s.forEach(((t,e)=>{o[e]=()=>t})),o},inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=tr(),n=await this.backend.time(t);return n.wallMs=tr()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Fr;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Or(){const t=Z();if(null==t._tfengine){const e=new G(t);t._tfengine=new $r(e)}var e;return e=t._tfengine.ENV,K=e,fr=()=>t._tfengine,t._tfengine}$r.nextTensorId=0,$r.nextVariableId=0;const Rr=Or();function Ir(t,e){const n={a:t,b:e};return Rr.runKernel(nt,n)}const Mr=X();function Lr(t,e){let n=t;if(rr(t))return"string"===e?[]:[t.length];if(kr(t)){const e=t.channels||"RGBA";return[t.height,t.width*e.length]}if(Cr(t))return[t.buffer.size/(null==e?4:R(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||rr(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&X().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&zr(t,r,[]),r}function zr(t,e,n){if(n=n||[],!Array.isArray(t)&&!rr(t))return void k(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));k(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),k(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const r=e.slice(1);for(let e=0;e<t.length;++e)zr(t[e],r,n.concat(e))}function Vr(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function Br(t,e,n,r="numeric"){if(t instanceof br)return Vr(r,t.dtype,e,n),t;let a=M(t);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Vr(r,a,e,n),null==t||!rr(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const s=Lr(t,a);rr(t)||Array.isArray(t)||(t=[t]);const o="string"!==a?Yn(t,a):ar(t,[],!0);return Rr.makeTensor(o,s,a)}function Ur(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,a)=>Br(t,`${e}[${a}]`,n,r)))}Mr.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Mr.registerFlag("IS_BROWSER",(()=>"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope)),Mr.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&"undefined"!=typeof process.versions&&"undefined"!=typeof process.versions.node)),Mr.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Mr.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Mr.registerFlag("PROD",(()=>!1)),Mr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Mr.getBool("DEBUG"))),Mr.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Mr.registerFlag("IS_TEST",(()=>!1)),Mr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Mr.getBool("DEBUG"))),Mr.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Mr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Mr.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const Wr="__op";function jr(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Wr;const a=(...t)=>{Rr.startScope(n);try{const e=r(...t);return q(e)&&console.error("Cannot return a Promise inside of tidy."),Rr.endScope(e),e}catch(t){throw Rr.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const qr=jr({complex_:function(t,e){const n=Br(t,"real","complex"),r=Br(e,"imag","complex");C(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const a={real:n,imag:r};return Rr.runKernel("Complex",a)}});function Hr(t,e,n,r){if(null==r)r=M(t);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Cr(t)||kr(t)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Rr.backend.createTensorFromGPUData(t,e||n,r)}if(!rr(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){j(e);const t=D(e),r=D(n);k(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let t=0;t<n.length;++t){const r=n[t],a=t!==n.length-1||r!==D(e.slice(t));k(n[t]===e[t]||!a,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return rr(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?Yn(t,r):ar(t,[],!0),Rr.makeTensor(t,e,r)}function Gr(t,e,n){return Hr(t,e,Lr(t,n),n)}const Qr={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Xr=4;async function Jr(t,e){const n=[],r=[],a=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<a.length;++s){const o=a[s],i=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${i.dtype}`);const u={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const t=new Promise((async t=>{const e=await i.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+Xr*e.length,r=new Uint8Array(n);let a=0;for(let t=0;t<e.length;t++){const n=e[t],s=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(s,a),a+=Xr,r.set(n,a),a+=n.length}t(r)}));r.push(t)}else r.push(i.data());null!=e&&(u.group=e),n.push(u)}return{data:Zr(await Promise.all(r)),specs:n}}function Kr(t,e){const n={};let r,a=0;for(const s of e){const e=s.name,o=s.dtype,i=s.shape,u=D(i);let l;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const i=Qr[n.dtype],c=t.slice(a,a+u*i),d="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(d.length);for(let t=0;t<d.length;t++){const e=d[t];l[t]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=ua()),l=r(d)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);l=new Int32Array(d.length);for(let t=0;t<d.length;t++){const e=d[t];l[t]=Math.round(e*n.scale+n.min)}}a+=u*i}else if("string"===o){const e=D(s.shape);l=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(a,a+Xr))[0];a+=Xr;const n=new Uint8Array(t.slice(a,a+e));l.push(n),a+=e}}else{const r=Qr[o],s=t.slice(a,a+u*r);if("float32"===o)l=new Float32Array(s);else if("int32"===o)l=new Int32Array(s);else if("bool"===o)l=new Uint8Array(s);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);{l=new Float32Array(s);const t=new Float32Array(l.length/2),r=new Float32Array(l.length/2);for(let e=0;e<t.length;e++)t[e]=l[2*e],r[e]=l[2*e+1];const a=Gr(t,i,"float32"),o=Gr(r,i,"float32");n[e]=qr(a,o),a.dispose(),o.dispose()}}a+=u*r}"complex64"!==o&&(n[e]=Gr(l,i,o))}return n}function Zr(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}));const r=new Uint8Array(e);let a=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),a),a+=t.byteLength})),r.buffer}const Yr="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function ta(t){return Yr?Buffer.byteLength(t):new Blob([t]).size}function ea(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function na(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function ra(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(n.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}function aa(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(r.initializerSignature=t.initializerSignature),r}async function sa(t,e){let n,r;return null!=t.weightsManifest&&([n,r]=await e(t.weightsManifest)),aa(t,n,r)}function oa(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:ta(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:ta(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function ia(t){const e=[];for(const n of t)e.push(...n.weights);return e}function ua(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;!(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let a=0;a<r.length;a++){const o=r[a],i=t[n[o>>10]+(1023&o)]+e[o>>10];s[a]=i}return new Float32Array(a)}}class la{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==la.instance&&(la.instance=new la),la.instance}static registerSaveRouter(t){la.getInstance().saveRouters.push(t)}static registerLoadRouter(t){la.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return la.getHandlers(t,"save")}static getLoadHandlers(t,e){return la.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?la.getInstance().loadRouters:la.getInstance().saveRouters).forEach((e=>{const a=e(t,n);null!==a&&r.push(a)})),r}}const ca=t=>la.registerSaveRouter(t),da=t=>la.registerLoadRouter(t),pa=t=>la.getSaveHandlers(t),ma=(t,e)=>la.getLoadHandlers(t,e),fa="tensorflowjs",ha="models_store",ya="model_info_store";function ba(){if(!X().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function ga(t){const e=t.result;e.createObjectStore(ha,{keyPath:"modelPath"}),e.createObjectStore(ya,{keyPath:"modelPath"})}class wa{constructor(t){if(this.indexedDB=ba(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(fa,1);r.onupgradeneeded=()=>ga(r),r.onsuccess=()=>{const a=r.result;if(null==e){const e=a.transaction(ha,"readonly"),r=e.objectStore(ha).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(a.close(),n(r.error)),e.oncomplete=()=>a.close()}else{const r=oa(e),s=a.transaction(ya,"readwrite");let o,i,u=s.objectStore(ya);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(t){return n(t)}o.onsuccess=()=>{i=a.transaction(ha,"readwrite");const o=i.objectStore(ha);let l;try{l=o.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r})}catch(t){return n(t)}l.onsuccess=()=>t({modelArtifactsInfo:r}),l.onerror=t=>{u=s.objectStore(ya);const e=u.delete(this.modelPath);e.onsuccess=()=>(a.close(),n(l.error)),e.onerror=t=>(a.close(),n(l.error))}},o.onerror=t=>(a.close(),n(o.error)),s.oncomplete=()=>{null==i?a.close():i.oncomplete=()=>a.close()}}},r.onerror=t=>n(r.error)}))}}wa.URL_SCHEME="indexeddb://";const _a=t=>{return X().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(wa.URL_SCHEME)?(e=t.slice(wa.URL_SCHEME.length),new wa(e)):null;var e};la.registerSaveRouter(_a),la.registerLoadRouter(_a);class va{constructor(){this.indexedDB=ba()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(fa,1);n.onupgradeneeded=()=>ga(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(ya,"readonly"),s=a.objectStore(ya).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),a.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(wa.URL_SCHEME)?e.slice(wa.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(fa,1);r.onupgradeneeded=()=>ga(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(ya,"readwrite"),o=s.objectStore(ya),i=o.get(t);let u;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=o.delete(t),s=()=>{u=a.transaction(ha,"readwrite");const r=u.objectStore(ha).delete(t);r.onsuccess=()=>e(i.result.modelArtifactsInfo),r.onerror=t=>n(i.error)};r.onsuccess=s,r.onerror=t=>(s(),a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==u?a.close():u.oncomplete=()=>a.close()}},r.onerror=t=>n(r.error)}))}}const Ta="/",Sa="tensorflowjs_models",Na="info",xa="model_topology",ka="weight_specs",Ca="weight_data",Aa="model_metadata";function Da(t){return{info:[Sa,t,Na].join(Ta),topology:[Sa,t,xa].join(Ta),weightSpecs:[Sa,t,ka].join(Ta),weightData:[Sa,t,Ca].join(Ta),modelMetadata:[Sa,t,Aa].join(Ta)}}function Ea(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Pa(t){const e=t.split(Ta);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Ta)}class Fa{constructor(t){if(!X().getBool("IS_BROWSER")||"undefined"==typeof window||"undefined"==typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Da(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=oa(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(Yr)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let t=0,r=e.length;t<r;t++)n+=String.fromCharCode(e[t]);return btoa(n)}(t.weightData));const a={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,initializerSignature:null!=t.initializerSignature?t.initializerSignature:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(t){throw Ea(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const t=JSON.parse(a);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(e.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(Yr){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n.set([e.charCodeAt(t)],t);return n.buffer}(s),e}}Fa.URL_SCHEME="localstorage://";const $a=t=>{return X().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Fa.URL_SCHEME)?(e=t.slice(Fa.URL_SCHEME.length),new Fa(e)):null;var e};la.registerSaveRouter($a),la.registerLoadRouter($a);class Oa{constructor(){k(X().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),k("undefined"==typeof window||"undefined"!=typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=Sa+Ta,n=Ta+Na;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(e)&&a.endsWith(n)){t[Pa(a)]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){var e;const n=Da(t=(e=t).startsWith(Fa.URL_SCHEME)?e.slice(Fa.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return Ea(n),r}}const Ra="://";class Ia{constructor(){this.managers={}}static getInstance(){return null==Ia.instance&&(Ia.instance=new Ia),Ia.instance}static registerManager(t,e){k(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(Ra)&&(t=t.slice(0,t.indexOf(Ra))),k(t.length>0,(()=>"scheme must not be an empty string."));const n=Ia.getInstance();k(null==n.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),n.managers[t]=e}static getManager(t){const e=Ia.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Ia.getInstance().managers)}}function Ma(t){if(-1===t.indexOf(Ra))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ia.getSchemes().join(",")}`);return{scheme:t.split(Ra)[0],path:t.split(Ra)[1]}}async function La(t,e,n=!1){k(t!==e,(()=>`Old path and new path are the same: '${t}'`));const r=la.getLoadHandlers(t);k(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${t}.`)),k(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`));const a=r[0],s=la.getSaveHandlers(e);k(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${e}.`)),k(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`));const o=s[0],i=Ma(t).scheme,u=Ma(t).path,l=i===Ma(t).scheme,c=await a.load();n&&l&&await Ia.getManager(i).removeModel(u);const d=await o.save(c);return n&&!l&&await Ia.getManager(i).removeModel(u),d.modelArtifactsInfo}async function za(){const t=Ia.getSchemes(),e={};for(const n of t){const t=await Ia.getManager(n).listModels();for(const r in t){e[n+Ra+r]=t[r]}}return e}async function Va(t){const e=Ma(t);return Ia.getManager(e.scheme).removeModel(e.path)}async function Ba(t,e){return La(t,e,!1)}async function Ua(t,e){return La(t,e,!0)}class Wa{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!=typeof window&&X().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(t,e)}isTypedArray(t){return Ln(t)}}if(X().get("IS_BROWSER")){X().setPlatform("browser",new Wa);try{Ia.registerManager(Fa.URL_SCHEME,new Oa)}catch(t){}try{Ia.registerManager(wa.URL_SCHEME,new va)}catch(t){}}const ja=()=>n(661);let qa;class Ha{constructor(){this.util=n(282),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=X().global.fetch?X().global.fetch(t,e):(null==qa&&(qa=ja()),qa(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}function Ga(t,e="float32",n){return e=e||"float32",j(t),new mr(t,e,n)}X().get("IS_NODE")&&!X().get("IS_BROWSER")&&X().setPlatform("node",new Ha);const Qa=jr({cast_:function(t,e){const n=Br(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:e};return Rr.runKernel(wt,r,a)}});const Xa=jr({clone_:function(t){const e={x:Br(t,"x","clone","string_or_numeric")};return Rr.runKernel(Yt,e)}});function Ja(t,e=!1){console.log(t.toString(e))}Or();function Ka(t,e){return Rr.tidy(t,e)}function Za(t){Dr(t).forEach((t=>t.dispose()))}function Ya(t){return Rr.keep(t)}hr={buffer:Ga,cast:Qa,clone:Xa,print:Ja},yr=function(t){X().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const ts=jr({add_:function(t,e){let n=Br(t,"a","add"),r=Br(e,"b","add");[n,r]=Ar(n,r);const a={a:n,b:r};return Rr.runKernel(nt,a)}});const es=jr({floorDiv_:function(t,e){let n=Br(t,"a","floorDiv"),r=Br(e,"b","floorDiv");[n,r]=Ar(n,r);const a={a:n,b:r};return Rr.runKernel(Gt,a)}});const ns=jr({div_:function(t,e){let n=Br(t,"a","div"),r=Br(e,"b","div");if([n,r]=Ar(n,r),"int32"===n.dtype&&"int32"===r.dtype)return es(n,r);const a={a:n,b:r};return Rr.runKernel(zt,a,{})}});const rs=jr({mul_:function(t,e){let n=Br(t,"a","mul"),r=Br(e,"b","mul");[n,r]=Ar(n,r);const a={a:n,b:r};return Rr.runKernel(Te,a)}});const as=jr({sqrt_:function(t){const e={x:Br(t,"x","sqrt","float32")};return Rr.runKernel(tn,e)}});const ss=jr({square_:function(t){const e=Br(t,"x","square");return Rr.runKernel("Square",{x:e},{})}});const os=jr({zerosLike_:function(t){const e={x:Br(t,"x","zerosLike")};return Rr.runKernel(Sn,e)}});function is(t){return Rr.customGrad(t)}function us(t,e){if((rr(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&rr(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Hr(t,[],[],e)}class ls{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class cs{constructor(){this.classNameMap={}}static getMap(){return null==cs.instance&&(cs.instance=new cs),cs.instance}static register(t){cs.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ds(t){k(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),k("string"==typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),k(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),cs.register(t)}class ps extends ls{minimize(t,e=!1,n){const{value:r,grads:a}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:a[t.name]})));this.applyGradients(t)}else this.applyGradients(a);return Za(a),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){k(L(t),(()=>"The f passed in variableGrads(f) must be a function")),k(null==e||Array.isArray(e)&&e.every((t=>t instanceof gr)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in Rr.registeredVariables)e.push(Rr.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,a=e.length;e=e.filter((t=>t.trainable)),k(e.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));const{value:s,grads:o}=Rr.gradients(t,e,null,!0);k(o.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),k(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));const i={};return e.forEach(((t,e)=>{null!=o[e]&&(i[t.name]=o[e])})),null!=r&&r.forEach((t=>i[t.name]=null)),{value:s,grads:i}}(t,e)}dispose(){null!=this.iterations_&&Za(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:us(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(ps,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});function ms(t,e,n){j(t);const r={shape:t,value:e,dtype:n=n||M(e)};return Rr.runKernel(jt,{},r)}const fs=jr({pow_:function(t,e){let n=Br(t,"base","pow"),r=Br(e,"exp","pow");[n,r]=Ar(n,r);const a={a:n,b:r};return Rr.runKernel("Pow",a)}});const hs=jr({sub_:function(t,e){let n=Br(t,"a","sub"),r=Br(e,"b","sub");[n,r]=Ar(n,r);const a={a:n,b:r};return Rr.runKernel("Sub",a)}});const ys=jr({abs_:function(t){const e=Br(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return Rr.runKernel("ComplexAbs",t)}{const t={x:e};return Rr.runKernel("Abs",t)}}});function bs(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let a=0;a<n;a++){let s=t[t.length-a-1];null==s&&(s=1);let o=e[e.length-a-1];if(null==o&&(o=1),1===s)r[n-a-1]=o;else if(1===o)r[n-a-1]=s;else{if(s!==o){throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`)}r[n-a-1]=s}}return r}const gs=jr({maximum_:function(t,e){let n=Br(t,"a","maximum"),r=Br(e,"b","maximum");[n,r]=Ar(n,r),"bool"===n.dtype&&(n=Qa(n,"int32"),r=Qa(r,"int32")),bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(fe,a)}});class ws extends ps{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const a=Rr.registeredVariables[e];Ka((()=>{const t=ts(rs(this.c,r),a);a.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=Ya(us(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}const _s=[class extends ps{static get className(){return"Adadelta"}constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Rr.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Rr.registeredVariables[e],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:Ka((()=>os(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:Ka((()=>os(r).variable(a)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;Ka((()=>{const t=ts(rs(o,this.rho),rs(ss(s),1-this.rho)),e=rs(ns(as(ts(i,this.epsilon)),as(ts(o,this.epsilon))),s),n=ts(rs(i,this.rho),rs(ss(e),1-this.rho));o.assign(t),i.assign(n);const a=ts(rs(e,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Za(this.accumulatedGrads.map((t=>t.variable))),Za(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}},class extends ps{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Rr.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:Ka((()=>ms(r.shape,this.initialAccumulatorValue).variable(t)))}}const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable;Ka((()=>{const t=ts(s,ss(a));s.assign(t);const e=ts(rs(ns(a,as(ts(t,Rr.backend.epsilon()))),-this.learningRate),r);r.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Za(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}},class extends ps{static get className(){return"Adam"}constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ka((()=>{this.accBeta1=us(e).variable(),this.accBeta2=us(n).variable()})),null==r&&(this.epsilon=Rr.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Ka((()=>{const n=hs(1,this.accBeta1),r=hs(1,this.accBeta2);e.forEach(((e,a)=>{const s=Rr.registeredVariables[e],o=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${e}/m`,variable:Ka((()=>os(s).variable(o)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${e}/v`,variable:Ka((()=>os(s).variable(o)))});const i=Array.isArray(t)?t[a].tensor:t[e];if(null==i)return;const u=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,c=ts(rs(u,this.beta1),rs(i,1-this.beta1)),d=ts(rs(l,this.beta2),rs(ss(i),1-this.beta2)),p=ns(c,n),m=ns(d,r);u.assign(c),l.assign(d);const f=ts(rs(ns(p,ts(as(m),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(rs(this.accBeta1,this.beta1)),this.accBeta2.assign(rs(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Za(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&Za(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),Ka((()=>{this.accBeta1.assign(fs(this.beta1,this.iterations_+1)),this.accBeta2.assign(fs(this.beta2,this.iterations_+1))}));const e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}},class extends ps{static get className(){return"Adamax"}constructor(t,e,n,r=null,a=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ka((()=>{this.iteration=us(0).variable(),this.accBeta1=us(e).variable()})),null==r&&(this.epsilon=Rr.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Ka((()=>{const n=hs(1,this.accBeta1),r=ns(-this.learningRate,ts(rs(this.iteration,this.decay),1));e.forEach(((e,a)=>{const s=Rr.registeredVariables[e],o=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${e}/m`,variable:os(s).variable(o)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${e}/v`,variable:os(s).variable(o)});const i=Array.isArray(t)?t[a].tensor:t[e];if(null==i)return;const u=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,c=ts(rs(u,this.beta1),rs(i,1-this.beta1)),d=rs(l,this.beta2),p=ys(i),m=gs(d,p);u.assign(c),l.assign(m);const f=ts(rs(ns(r,n),ns(c,ts(m,this.epsilon))),s);s.assign(f)})),this.iteration.assign(ts(this.iteration,1)),this.accBeta1.assign(rs(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Za(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&Za(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}},class extends ws{static get className(){return"Momentum"}constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=us(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Rr.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:Ka((()=>os(r).variable(t)))}}const a=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&Ka((()=>{let t;const e=ts(rs(this.m,a),s);t=this.useNesterov?ts(rs(this.c,ts(s,rs(e,this.m))),r):ts(rs(this.c,e),r),a.assign(e),r.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Za(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}},class extends ps{static get className(){return"RMSProp"}constructor(t,e=.9,n=0,r=null,a=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Rr.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Rr.registeredVariables[e],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:Ka((()=>os(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:Ka((()=>os(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:Ka((()=>os(r).variable(a)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;Ka((()=>{const t=ts(rs(o,this.decay),rs(ss(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,a=ts(rs(e,this.decay),rs(s,1-this.decay)),u=ns(rs(s,this.learningRate),as(hs(t,ts(ss(a),this.epsilon)))),l=ts(rs(i,this.momentum),u);o.assign(t),e.assign(a),i.assign(l);const c=hs(r,l);r.assign(c)}else{const t=ts(rs(o,this.decay),rs(ss(s),1-this.decay)),e=ts(rs(i,this.momentum),ns(rs(s,this.learningRate),as(ts(t,this.epsilon))));o.assign(t),i.assign(e);const n=hs(r,e);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Za(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Za(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&Za(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}},ws];function vs(t){return new Promise((t=>setTimeout(t))).then(t)}class Ts{constructor(t){if(!X().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Ts.URL_SCHEME)&&(t=t.slice(Ts.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=ra(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await vs((()=>a.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await vs((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:oa(t)}}}}Ts.URL_SCHEME="downloads://";class Ss{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise(((t,e)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void t({modelTopology:a});const s=sa(r,(t=>this.loadWeights(t)));t(s)},n.onerror=t=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(t){const e=[],n=[];for(const r of t)e.push(...r.weights),n.push(...r.paths);const r=this.checkManifestAndWeightFiles(t),a=n.map((t=>this.loadWeightsFile(t,r[t])));return Promise.all(a).then((t=>[e,ea(t)]))}loadWeightsFile(t,e){return new Promise(((n,r)=>{const a=new FileReader;a.onload=t=>{const e=t.target.result;n(e)},a.onerror=e=>r(`Failed to weights data from file of path '${t}'.`),a.readAsArrayBuffer(e)}))}checkManifestAndWeightFiles(t){const e=[],n=this.weightsFiles.map((t=>na(t.name))),r={};for(const a of t)a.paths.forEach((t=>{const a=na(t);if(-1!==e.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[t]=this.weightsFiles[n.indexOf(a)]}));if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function Ns(t){return new Ss(t)}la.registerSaveRouter((t=>X().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Ts.URL_SCHEME)?function(t="model"){return new Ts(t)}(t.slice(Ts.URL_SCHEME.length)):null));class xs{constructor(t){if(this.shards=[],this.previousShardIndex=0,t instanceof Array||(t=[t]),0===(t=t.map((t=>rr(t)?t.buffer:t))).length)return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let n=0;n<t.length;n++){const r=t[n];n!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=e+r.byteLength;this.shards.push({buffer:r,start:e,end:a}),e=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),(e=Math.min(this.byteLength,e))<=t)return new ArrayBuffer(0);const n=this.findShardForByte(t);if(-1===n)throw new Error(`Could not find start shard for byte ${t}`);const r=new ArrayBuffer(e-t),a=new Uint8Array(r);let s=0;for(let r=n;r<this.shards.length;r++){const n=this.shards[r],o=t+s-n.start,i=s,u=Math.min(e,n.end)-n.start,l=new Uint8Array(n.buffer.slice(o,u));if(a.set(l,i),s+=l.length,e<n.end)break}return r}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(e){return t<e.start?-1:t>=e.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(t,e){let n=0,r=t.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,s=e(t[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,e);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function ks(t,e,n,r){!function(t){k(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){k(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`)),k(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`)),k(e>=t,(()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(t.map((s=>(s.then((s=>{const o=n+ ++a/t.length*(r-n);return e(o),s})),s))))}async function Cs(t,e){null==e&&(e={});const n=null==e.fetchFunc?X().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),a=(null==e.onProgress?await Promise.all(r):await ks(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(a):await ks(a,e.onProgress,.5,1)}async function As(t,e="",n,r){return Ds((t=>Cs(t,{requestInit:r})))(t,e,n)}function Ds(t){return async(e,n="",r)=>{const a=e.map((()=>!1)),s={},o=null!=r?r.map((()=>!1)):[],i=[];if(e.forEach(((t,e)=>{let n=0;t.weights.forEach((t=>{const u="quantization"in t?t.quantization.dtype:t.dtype,l=Qr[u]*D(t.shape),c=()=>{a[e]=!0,null==s[e]&&(s[e]=[]),s[e].push({manifestEntry:t,groupOffset:n,sizeBytes:l})};null!=r?r.forEach(((e,n)=>{e===t.name&&(c(),o[n]=!0)})):c(),i.push(t.name),n+=l}))})),!o.every((t=>t))){const t=r.filter(((t,e)=>!o[e]));throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${i.join(", ")}.`)}const u=a.reduce(((t,e,n)=>(e&&t.push(n),t)),[]),l=[];u.forEach((t=>{e[t].paths.forEach((t=>{const e=n+(n.endsWith("/")?"":"/")+t;l.push(e)}))}));const c=await t(l),d={};let p=0;return u.forEach((t=>{const n=e[t].paths.length,r=new xs(c.slice(p,p+n));s[t].forEach((t=>{const e=Kr(r.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const t in e)d[t]=e[t]})),p+=n})),d}}class Es{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(k("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=X().platform.fetch,k(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&k(2===t.length,(()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=ra(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:oa(t),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return sa(e,(t=>this.loadWeights(t)))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),a=n>e?t.substring(n):"";return[r+"/",a]}(e),a=this.weightPathPrefix||n,s=ia(t),o=[],i=[];for(const e of t)for(const t of e.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(t)):o.push(a+t+r);this.weightUrlConverter&&o.push(...await Promise.all(i));return[s,ea(await Cs(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Ps(t){return null!=t.match(Es.URL_SCHEME_REGEX)}Es.URL_SCHEME_REGEX=/^https?:\/\//;const Fs=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>Ps(t))):Ps(t),n)return $s(t,e)}return null};function $s(t,e){return new Es(t,e)}function Os(t,e){return $s(t,e)}la.registerSaveRouter(Fs),la.registerLoadRouter(Fs);class Rs{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class Is{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class Ms{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function Ls(t,e,n,r){return new Ms(zs(...arguments))}function zs(t,e,n,r){if(1===arguments.length){return null!=t.modelTopology||null!=t.weightSpecs?new Rs(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Rs({modelTopology:t}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Rs({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r})}function Vs(t){return new Is(t)}function Bs(t){return new Is(t)}function Us(t,e,n){if(A(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Lr(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Hr(t,e,r,n)}let Ws;function js(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,o=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)s=!0;else if(null!=t.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);i=!0}if(null!=$n(xn,Rr.backendName)){const n={pixels:t},r={numChannels:e};return Rr.runKernel(xn,n,r)}const[u,l]=a?[t.videoWidth,t.videoHeight]:[t.width,t.height];let c,d;if(o)c=t.getContext("2d").getImageData(0,0,u,l).data;else if(r||n)c=t.data;else if(s||a||i){if(null==Ws)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Ws=new OffscreenCanvas(1,1).getContext("2d")}else Ws=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ws.canvas.width=u,Ws.canvas.height=l,Ws.drawImage(t,0,0,u,l),c=Ws.getImageData(0,0,u,l).data}if(4===e)d=new Int32Array(c);else{const t=u*l;d=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)d[n*e+t]=c[4*n+t]}return Us(d,[l,u,e],"int32")}const qs=jr({fromPixels_:js});function Hs(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}!function(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,a=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(t.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+t.length-r)throw new Error(s+" update.rank != "+(a+t.length-r));for(let t=0;t<a;++t)if(n.shape[t]!==e.shape[t])throw new Error(s+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-a;++e)if(n.shape[e+a]!==t[e+r])throw new Error(s+` updates.shape[${e+a}] (${n.shape[e+a]}) != shape[${e+a}] (${t[e+a]})`)}(n,e,t)}function Gs(t,e,n){const r=e.shape.length,a=r>1?e.shape[r-1]:1,s=n.length;let o=1;for(let t=a;t<s;++t)o*=n[t];const i=a<1?1:a;return{sliceRank:a,numUpdates:D(e.shape)/i,sliceSize:o,strides:[...z(n.slice(0,a)),1],outputSize:D(n)}}function Qs(t,e,n){let r=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){r=t;break}for(let a=r+1;a<n.length;a++)if(e[a]>0||n[a]!==t[a])return!1;return!0}function Xs(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function Js(t,e,n){let r;const a=t.shape.length;let s;return r="number"==typeof e?[e,...new Array(a-1).fill(0)]:e.length<a?e.concat(new Array(a-e.length).fill(0)):e.slice(),r.forEach((t=>{k(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"==typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(k(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-r[n]))),[r,s]}function Ks(t,e,n,r,a,s,o,i,u){let l;if(null==r?(l=new Array(e.length),l.fill(1)):l=r,null!=o&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:l.slice(),beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let t=0;t<d.dims;t++)c&&1<<t&i&&d.numAddAxisAfterEllipsis++,1<<t&o&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=null!=t.begin,e.endValid=null!=t.end,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const a=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<a;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(-2),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);null!=t.begin&&(e.begin[n]=t.begin[r]),null!=t.end&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(-1),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}(d,p);let m=!0,f=!0,h=!0;const y=[],b=[];for(let e=0;e<t.length;++e){if(0===p.strides[e])throw Error(`strides[${e}] must be non-zero`);const n=!!(p.shrinkAxisMask&1<<e),r=t[e];if(-1===r){y.push(n?1:-1);continue}const a=[p.beginMask&1<<e,p.endMask&1<<e],s=[p.strides[e]>0?0:-1,p.strides[e]>0?r:r-1];if(n&&p.strides[e]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&1===p.strides[e];const o=!!(p.beginMask&1<<e&&p.endMask&1<<e);if(p.beginValid&&p.endValid){if(n){const t=p.begin[e]<0?r+p.begin[e]:p.begin[e];if(p.begin[e]=t,p.end[e]=p.begin[e]+1,t<0||t>=r)throw Error(`slice index ${p.begin[e]} of dimension ${e} out of bounds.`)}else p.begin[e]=Zs(p.begin[e],0,p.strides[e],r,a,s),p.end[e]=Zs(p.end[e],1,p.strides[e],r,a,s);const t=1===p.strides[e]&&0===p.begin[e]&&p.end[e]===r;m=m&&t,f=f&&(0===e&&1===p.strides[e]||t)}else m=m&&1===p.strides[e]&&o,f=f&&(0===e&&1===p.strides[e]||o);let i,u=!1;if(p.beginValid&&p.endValid?(i=p.end[e]-p.begin[e],u=!0):n?(i=1,u=!0):o&&r>=0&&(i=p.strides[e]<0?-r:r,u=!0),u){let t;t=0===i||i<0!=p.strides[e]<0?0:Math.trunc(i/p.strides[e])+(i%p.strides[e]!=0?1:0),y.push(t)}else y.push(-1)}for(let t=0;t<p.finalShapeGatherIndices.length;++t){const e=p.finalShapeGatherIndices[t];e>=0?b.push(y[e]):-2===e&&b.push(1)}return{finalShapeSparse:b.filter(((t,e)=>-2!==p.finalShapeGatherIndices[e])),finalShape:b,isIdentity:m,sliceDim0:f,isSimpleSlice:h,begin:p.begin,end:p.end,strides:p.strides}}function Zs(t,e,n,r,a,s){if(a[e])return n>0?s[e]:s[e+1&1];{const e=t<0?r+t:t;return e<s[0]?s[0]:e>s[1]?s[1]:e}}const Ys=jr({acos_:function(t){const e={x:Br(t,"x","acos")};return Rr.runKernel(tt,e)}});const to=jr({acosh_:function(t){const e={x:Br(t,"x","acosh")};return Rr.runKernel(et,e)}});const eo=jr({addN_:function(t){k(Array.isArray(t),(()=>"The argument passed to tf.addN() must be a list of tensors")),k(t.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`));const e=t.map(((t,e)=>Br(t,`tensors${e}`,"addN"))),n=e[0];e.forEach((t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),e.forEach((t=>{if(!E(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=e;return Rr.runKernel(rt,r)}});const no=jr({all_:function(t,e=null,n=!1){const r={x:Br(t,"x","all","bool")},a={axis:e,keepDims:n};return Rr.runKernel(at,r,a)}});const ro=jr({any_:function(t,e=null,n=!1){const r={x:Br(t,"x","any","bool")},a={axis:e,keepDims:n};return Rr.runKernel(st,r,a)}});const ao=jr({argMax_:function(t,e=0){const n={x:Br(t,"x","argMax")},r={axis:e};return Rr.runKernel(ot,n,r)}});const so=jr({argMin_:function(t,e=0){const n={x:Br(t,"x","argMin")},r={axis:e};return Rr.runKernel(it,n,r)}});const oo=jr({asin_:function(t){const e={x:Br(t,"x","asin")};return Rr.runKernel(ut,e)}});const io=jr({asinh_:function(t){const e={x:Br(t,"x","asinh")};return Rr.runKernel(lt,e)}});const uo=jr({atan_:function(t){const e={x:Br(t,"x","atan")};return Rr.runKernel(ct,e)}});const lo=jr({atan2_:function(t,e){let n=Br(t,"a","atan2"),r=Br(e,"b","atan2");[n,r]=Ar(n,r);const a={a:n,b:r};return Rr.runKernel(pt,a)}});const co=jr({atanh_:function(t){const e={x:Br(t,"x","atanh")};return Rr.runKernel(dt,e)}});function po(t,e,n,r,a="NHWC",s){return ho(t,[...e,t[3]],n,s,r,null,null,xo(a))}function mo(t,e,n,r,a,s,o="channelsLast"){const[i,u]=go(e);let l;if("channelsLast"===o)l=[i,u,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);l=[i,u,t[1],t[1]]}return ho(t,l,n,r,a,s,!1,o)}function fo(t,e,n,r,a,s,o="NDHWC"){const[i,u,l]=wo(e);let c,d;if("NDHWC"===o)d="channelsLast",c=[i,u,l,t[4],t[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",c=[i,u,l,t[1],t[1]]}return yo(t,c,n,r,a,!1,d,s)}function ho(t,e,n,r,a,s,o=!1,i="channelsLast"){let[u,l,c,d]=[-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,d]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,l,c]=t}const[p,m,,f]=e,[h,y]=go(n),[b,g]=go(r),w=_o(p,b),_=_o(m,g),{padInfo:v,outHeight:T,outWidth:S}=function(t,e,n,r,a,s,o,i,u){let l,c,d;if("number"==typeof t){l={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,r,a){null==r&&(r=bo(t,e,n));const s=t[0],o=t[1],i=vo((s-e+2*r)/n+1,a),u=vo((o-e+2*r)/n+1,a);return[i,u]}([e,n],s,r,t,i);c=a[0],d=a[1]}else if("same"===t){c=Math.ceil(e/r),d=Math.ceil(n/a);const t=Math.max(0,(c-1)*r+s-e),i=Math.max(0,(d-1)*a+o-n),u=Math.floor(t/2),p=t-u,m=Math.floor(i/2);l={top:u,bottom:p,left:m,right:i-m,type:"SAME"}}else if("valid"===t)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-s+1)/r),d=Math.ceil((n-o+1)/a);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const p="channelsLast"===u?t[1][0]:t[2][0],m="channelsLast"===u?t[1][1]:t[2][1],f="channelsLast"===u?t[2][0]:t[3][0],h="channelsLast"===u?t[2][1]:t[3][1];l={top:p,bottom:m,left:f,right:h,type:0===p&&0===m&&0===f&&0===h?"VALID":"EXPLICIT"},c=vo((e-s+p+m)/r+1,i),d=vo((n-o+f+h)/a+1,i)}}return{padInfo:l,outHeight:c,outWidth:d}}(a,l,c,h,y,w,_,s,i),N=o?f*d:f;let x;return"channelsFirst"===i?x=[u,N,T,S]:"channelsLast"===i&&(x=[u,T,S,N]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:d,outHeight:T,outWidth:S,outChannels:N,padInfo:v,strideHeight:h,strideWidth:y,filterHeight:p,filterWidth:m,effectiveFilterHeight:w,effectiveFilterWidth:_,dilationHeight:b,dilationWidth:g,inShape:t,outShape:x,filterShape:e}}function yo(t,e,n,r,a,s=!1,o="channelsLast",i){let[u,l,c,d,p]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,d,p]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,p,l,c,d]=t}const[m,f,h,,y]=e,[b,g,w]=wo(n),[_,v,T]=wo(r),S=_o(m,_),N=_o(f,v),x=_o(h,T),{padInfo:k,outDepth:C,outHeight:A,outWidth:D}=function(t,e,n,r,a,s,o,i,u,l,c){let d,p,m,f;"valid"===t&&(t=0);if("number"==typeof t){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const h=function(t,e,n,r,a,s){null==a&&(a=bo(t,e[0],r[0]));const o=[0,0,0,n];for(let n=0;n<3;n++)t[n]+2*a>=e[n]&&(o[n]=vo((t[n]-e[n]+2*a)/r[n]+1,s));return o}([e,n,r,1],[i,u,l],1,[a,s,o],t,c);p=h[0],m=h[1],f=h[2]}else{if("same"!==t)throw Error(`Unknown padding parameter: ${t}`);{p=Math.ceil(e/a),m=Math.ceil(n/s),f=Math.ceil(r/o);const t=(p-1)*a+i-e,c=(m-1)*s+u-n,h=(f-1)*o+l-r,y=Math.floor(t/2),b=t-y,g=Math.floor(c/2),w=c-g,_=Math.floor(h/2);d={top:g,bottom:w,left:_,right:h-_,front:y,back:b,type:"SAME"}}}return{padInfo:d,outDepth:p,outHeight:m,outWidth:f}}(a,l,c,d,b,g,w,S,N,x,i),E=s?y*p:y;let P;return"channelsFirst"===o?P=[u,E,C,A,D]:"channelsLast"===o&&(P=[u,C,A,D,E]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:c,inWidth:d,inChannels:p,outDepth:C,outHeight:A,outWidth:D,outChannels:E,padInfo:k,strideDepth:b,strideHeight:g,strideWidth:w,filterDepth:m,filterHeight:f,filterWidth:h,effectiveFilterDepth:S,effectiveFilterHeight:N,effectiveFilterWidth:x,dilationDepth:_,dilationHeight:v,dilationWidth:T,inShape:t,outShape:P,filterShape:e}}function bo(t,e,n,r=1){const a=_o(e,r);return Math.floor((t[0]*(n-1)-n+a)/2)}function go(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function wo(t){return"number"==typeof t?[t,t,t]:t}function _o(t,e){return e<=1?t:t+(t-1)*(e-1)}function vo(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function To(t){const[e,n,r]=go(t);return 1===e&&1===n&&1===r}function So(t,e){return To(t)||To(e)}function No(t){return go(t).every((t=>t>0))}function xo(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function ko(t,e,n){if(null!=n){if("string"==typeof e)throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if("number"==typeof e)k(P(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`));else{if("object"!=typeof e)throw Error(`Error in ${t}: Unknown padding parameter: ${e}`);e.forEach((e=>{e.forEach((e=>{k(P(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`))}))}))}}}const Co=jr({reshape_:function(t,e){const n={x:Br(t,"x","reshape","string_or_numeric")},r={shape:e};return Rr.runKernel(Ie,n,r)}});const Ao=jr({avgPool_:function(t,e,n,r,a){const s=Br(t,"x","avgPool","float32");k(So(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let o=s,i=!1;3===s.rank&&(i=!0,o=Co(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),ko("avgPool",r,a);const u={x:o},l={filterSize:e,strides:n,pad:r,dimRoundingMode:a};let c=Rr.runKernel(mt,u,l);return c=Qa(c,s.dtype),i?Co(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Do=jr({avgPool3d_:function(t,e,n,r,a,s="NDHWC"){const o=Br(t,"x","avgPool3d","float32");let i=o,u=!1;4===o.rank&&(u=!0,i=Co(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),k(5===i.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`)),k("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),k("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),ko("avgPool3d",r,a);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let d=Rr.runKernel(ft,l,c);return d=Qa(d,i.dtype),u?Co(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Eo=jr({concat_:function(t,e=0){k(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=Ur(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)})),1===n.length)return Xa(n[0]);const r=n,a={axis:e};return Rr.runKernel(Tt,r,a)}});const Po=jr({matMul_:function(t,e,n=!1,r=!1){let a=Br(t,"a","matMul"),s=Br(e,"b","matMul");[a,s]=Ar(a,s);const o={a,b:s},i={transposeA:n,transposeB:r};return Rr.runKernel(ht,o,i)}});const Fo=jr({sigmoid_:function(t){const e={x:Br(t,"x","sigmoid","float32")};return Rr.runKernel(Ze,e)}});const $o=jr({slice_:function(t,e,n){const r=Br(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:e,size:n};return Rr.runKernel(Je,a,s)}});const Oo=jr({tanh_:function(t){const e={x:Br(t,"x","tanh","float32")};return Rr.runKernel(yn,e)}});const Ro=jr({basicLSTMCell_:function(t,e,n,r,a,s){const o=Br(t,"forgetBias","basicLSTMCell"),i=Br(e,"lstmKernel","basicLSTMCell"),u=Br(n,"lstmBias","basicLSTMCell"),l=Br(r,"data","basicLSTMCell"),c=Br(a,"c","basicLSTMCell"),d=Br(s,"h","basicLSTMCell"),p=Eo([l,d],1),m=Po(p,i),f=ts(m,u),h=f.shape[0],y=f.shape[1]/4,b=[h,y],g=$o(f,[0,0],b),w=$o(f,[0,y],b),_=$o(f,[0,2*y],b),v=$o(f,[0,3*y],b),T=ts(rs(Fo(g),Oo(w)),rs(c,Fo(ts(o,_))));return[T,rs(Oo(T),Fo(v))]}});const Io=jr({batchToSpaceND_:function(t,e,n){const r=Br(t,"x","batchToSpaceND"),a=e.reduce(((t,e)=>t*e));k(r.rank>=1+e.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`)),k(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),k(r.shape[0]%a==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${a}`));const s={x:r},o={blockShape:e,crops:n};return Rr.runKernel(yt,s,o)}});const Mo=jr({batchNorm_:function(t,e,n,r,a,s){null==s&&(s=.001);const o=Br(t,"x","batchNorm"),i=Br(e,"mean","batchNorm"),u=Br(n,"variance","batchNorm");let l,c;null!=a&&(l=Br(a,"scale","batchNorm")),null!=r&&(c=Br(r,"offset","batchNorm")),k(i.rank===u.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),k(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),k(null==l||i.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:function(t){let e;return e=0===t.rank||1===t.rank?Co(t,[1,1,1,t.size]):2===t.rank?Co(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?Co(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),scale:l,offset:c,mean:i,variance:u},p={varianceEpsilon:s},m=Rr.runKernel(Qt,d,p);return Co(m,o.shape)}});const Lo=jr({batchNorm2d_:function(t,e,n,r,a,s){const o=Br(t,"x","batchNorm"),i=Br(e,"mean","batchNorm"),u=Br(n,"variance","batchNorm");let l,c;return null!=a&&(l=Br(a,"scale","batchNorm")),null!=r&&(c=Br(r,"offset","batchNorm")),k(2===o.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`)),k(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`)),k(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=l&&k(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=c&&k(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),Mo(o,i,u,c,l,s)}});const zo=jr({batchNorm3d_:function(t,e,n,r,a,s){const o=Br(t,"x","batchNorm"),i=Br(e,"mean","batchNorm"),u=Br(n,"variance","batchNorm");let l,c;return null!=a&&(l=Br(a,"scale","batchNorm")),null!=r&&(c=Br(r,"offset","batchNorm")),k(3===o.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`)),k(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`)),k(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=l&&k(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=c&&k(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),Mo(o,i,u,c,l,s)}});const Vo=jr({batchNorm4d_:function(t,e,n,r,a,s){const o=Br(t,"x","batchNorm"),i=Br(e,"mean","batchNorm"),u=Br(n,"variance","batchNorm");let l,c;return null!=a&&(l=Br(a,"scale","batchNorm")),null!=r&&(c=Br(r,"offset","batchNorm")),k(4===o.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`)),k(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`)),k(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=l&&k(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=c&&k(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),Mo(o,i,u,c,l,s)}});const Bo=jr({bincount_:function(t,e,n){const r=Br(t,"x","bincount"),a=Br(e,"weights","bincount");k("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),k(n>=0,(()=>`size must be non-negative, but got ${n}.`)),k(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));const s={x:r,weights:a},o={size:n};return Rr.runKernel(bt,s,o)}});const Uo=jr({bitwiseAnd_:function(t,e){const n=Br(t,"x","bitwiseAnd"),r=Br(e,"y","bitwiseAnd");if(!E(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const a={a:n,b:r};return Rr.runKernel("BitwiseAnd",a)}});const Wo=jr({broadcastArgs_:function(t,e){const n=Br(t,"s0","broadcastArgs","int32"),r=Br(e,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const a={s0:n,s1:r};return Rr.runKernel(gt,a)}});const jo=jr({broadcastTo_:function(t,e){let n=Br(t,"broadcastTo","x");const r=n.shape;if(j(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=Co(n,t)}const a=n.shape,s=Array.from(e);for(let t=e.length-1;t>=0;t--)if(a[t]===e[t])s[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(0===s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return Xa(n);const o={x:n},i={reps:s};return Rr.runKernel(bn,o,i)}});const qo=jr({ceil_:function(t){const e={x:Br(t,"x","ceil","float32")};return Rr.runKernel(_t,e)}});const Ho=jr({clipByValue_:function(t,e,n){const r=Br(t,"x","clipByValue");if(k(e<=n,(()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`)),e===n)return ms(r.shape,e,r.dtype);const a={x:r},s={clipValueMin:e,clipValueMax:n};return Rr.runKernel(vt,a,s)}});const Go=jr({concat1d_:function(t){return Eo(t,0)}});const Qo=jr({concat2d_:function(t,e){return Eo(t,e)}});const Xo=jr({concat3d_:function(t,e){return Eo(t,e)}});const Jo=jr({concat4d_:function(t,e){return Eo(t,e)}});const Ko=jr({conv2d_:function(t,e,n,r,a="NHWC",s=[1,1],o){const i=Br(t,"x","conv2d","float32"),u=Br(e,"filter","conv2d","float32");let l=i,c=!1;3===i.rank&&(c=!0,l=Co(i,[1,i.shape[0],i.shape[1],i.shape[2]])),k(4===l.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`)),k(4===u.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`)),ko("conv2d",r,o);const d="NHWC"===a?l.shape[3]:l.shape[1];k(d===u.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`)),k(So(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),k(No(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),k(No(n),(()=>"Error in conv2D: Strides should be larger than 0."));const p={x:l,filter:u},m={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Rr.runKernel(St,p,m);return c?Co(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Zo=jr({conv1d_:function(t,e,n,r,a="NWC",s=1,o){const i=Br(t,"x","conv1d"),u=Br(e,"filter","conv1d");let l=i,c=!1;2===i.rank&&(c=!0,l=Co(i,[1,i.shape[0],i.shape[1]])),k(3===l.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`)),k(3===u.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`)),ko("conv1d",r,o),k(l.shape[2]===u.shape[1],(()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`)),k(So(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),k(No(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),k(No(n),(()=>"Error in conv1D: Stride should be larger than 0.")),k("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));const d=Co(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=Co(l,[l.shape[0],1,l.shape[1],l.shape[2]]),m=Ko(p,d,[1,n],r,"NHWC",[1,s],o);return Co(m,c?[m.shape[2],m.shape[3]]:[m.shape[0],m.shape[2],m.shape[3]])}});const Yo=jr({conv2DBackpropInput_:function(t,e,n,r,a,s="NHWC",o){k(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let i=t,u=e,l=!1;3===e.rank&&(l=!0,u=Co(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),k(4===i.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`)),k(4===u.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`)),k(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===s?i[3]:i[1],d="NHWC"===s?u.shape[3]:u.shape[1];k(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),k(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),ko("conv2dDerInput",a,o);const p={dy:u,filter:n},m={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i},f=Rr.runKernel(Nt,p,m);return l?Co(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const ti=jr({conv2dTranspose_:function(t,e,n,r,a,s){const o=Br(t,"x","conv2dTranspose"),i=Br(e,"filter","conv2dTranspose");return Yo(n,o,i,r,a,"NHWC",s)}});const ei=jr({conv3d_:function(t,e,n,r,a="NDHWC",s=[1,1,1]){const o=Br(t,"x","conv3d"),i=Br(e,"filter","conv3d");let u=o,l=!1;4===o.rank&&(l=!0,u=Co(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),k(5===u.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`)),k(5===i.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`)),k(u.shape[4]===i.shape[3],(()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`)),k(So(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),k("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),k(No(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),k(No(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:u,filter:i},d={strides:n,pad:r,dataFormat:a,dilations:s},p=Rr.runKernel(xt,c,d);return l?Co(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});const ni=jr({conv3DBackpropInput_:function(t,e,n,r,a){k(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let s=t,o=e,i=!1;4===e.rank&&(i=!0,o=Co(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const u=s[4],l=o.shape[4];k(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),k(5===o.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`)),k(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),k(u===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`)),k(l===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`));const c={dy:o,filter:n},d={pad:a,strides:r,inputShape:s},p=Rr.runKernel(Ct,c,d);return i?Co(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});const ri=jr({conv3dTranspose_:function(t,e,n,r,a){const s=Br(t,"x","conv3dTranspose"),o=Br(e,"filter","conv3dTranspose");return ni(n,s,o,r,a)}});const ai=jr({cos_:function(t){const e={x:Br(t,"x","cos","float32")};return Rr.runKernel("Cos",e)}});const si=jr({cosh_:function(t){const e={x:Br(t,"x","cosh","float32")};return Rr.runKernel(At,e)}});const oi=jr({cumprod_:function(t,e=0,n=!1,r=!1){const a={x:Br(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:r};return Rr.runKernel(Dt,a,s)}});const ii=jr({cumsum_:function(t,e=0,n=!1,r=!1){const a={x:Br(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return Rr.runKernel(Et,a,s)}});const ui=jr({denseBincount_:function(t,e,n,r=!1){const a=Br(t,"x","denseBincount"),s=Br(e,"weights","denseBincount");k("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),k(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),k(n>=0,(()=>`size must be non-negative, but got ${n}.`)),k(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));const o={x:a,weights:s},i={size:n,binaryOutput:r};return Rr.runKernel(Ft,o,i)}});const li=jr({depthToSpace_:function(t,e,n="NHWC"){const r=Br(t,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],o="NHWC"===n?r.shape[3]:r.shape[1];k(e>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`)),k(a*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${e}  for depthToSpace with input shape\n    ${r.shape}`)),k(s*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${e} for depthToSpace with input shape\n        ${r.shape}`)),k(o%(e*e)==0,(()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`));const i={x:r},u={blockSize:e,dataFormat:n};return Rr.runKernel($t,i,u)}});const ci=jr({depthwiseConv2d_:function(t,e,n,r,a="NHWC",s=[1,1],o){const i=Br(t,"x","depthwiseConv2d","float32"),u=Br(e,"filter","depthwiseConv2d","float32");let l=i,c=!1;3===i.rank&&(c=!0,l=Co(i,[1,i.shape[0],i.shape[1],i.shape[2]])),k(4===l.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`)),k(4===u.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`));const d="NHWC"===a?l.shape[3]:l.shape[1];k(d===u.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${u.shape[2]}.`)),ko("depthwiseConv2d",r,o);const p={x:l,filter:u},m={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Rr.runKernel(Ot,p,m);return c?Co(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const di=jr({diag_:function(t){const e={x:Br(t,"x","diag")};return Rr.runKernel(Rt,e)}});const pi=jr({dilation2d_:function(t,e,n,r,a=[1,1],s="NHWC"){const o=Br(t,"x","dilation2d"),i=Br(e,"filter","dilation2d");k(3===o.rank||4===o.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`)),k(3===i.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`)),k("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let u=o,l=!1;3===o.rank&&(u=Co(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0),k(u.shape[3]===i.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${i.shape[2]}`));const c={x:u,filter:i},d={strides:n,pad:r,dilations:a},p=Rr.runKernel(It,c,d);return l?Co(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});const mi=jr({equal_:function(t,e){let n=Br(t,"a","equal","string_or_numeric"),r=Br(e,"b","equal","string_or_numeric");[n,r]=Ar(n,r),bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(Bt,a)}});const fi=jr({where_:function(t,e,n){const r=Br(e,"a","where"),a=Br(n,"b","where"),s=Br(t,"condition","where","bool"),o=bs(bs(s.shape,r.shape),a.shape),i={condition:jo(s,o),t:jo(r,o),e:jo(a,o)};return Rr.runKernel(Qe,i)}});const hi=jr({divNoNan_:function(t,e){let n=Br(t,"a","div"),r=Br(e,"b","div");[n,r]=Ar(n,r);const a=ns(n,r),s=os(a),o=mi(r,s);return fi(o,s,a)}});const yi=jr({dot_:function(t,e){const n=Br(t,"t1","dot"),r=Br(e,"t2","dot");k(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(k(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){const t=Co(n,[1,-1]),e=Co(r,[-1,1]),a=Po(t,e);return Co(a,[])}if(1===n.rank&&2===r.rank){const t=Co(n,[1,-1]),e=Co(r,[r.shape[0],r.shape[1]]),a=Po(t,e);return Co(a,[a.size])}if(2===n.rank&&1===r.rank){const t=Co(r,[-1,1]),e=Po(n,t);return Co(e,[e.size])}{const t=Co(r,[r.shape[0],r.shape[1]]);return Po(n,t)}}});const bi=jr({einsum_:function(t,...e){const n=e.map(((t,e)=>Br(t,`tensors${e}`,"einsum"))),r={equation:t};return Rr.runKernel("Einsum",n,r)}});const gi=jr({elu_:function(t){const e={x:Br(t,"x","elu","float32")};return Rr.runKernel("Elu",e)}});const wi=jr({ensureShape_:function(t,e){const n=Br(t,"x","ensureShape","string_or_numeric");if(!function(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(null!==t[n]&&null!==e[n]&&t[n]!==e[n])return!1;return!0}(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}});const _i=jr({erf_:function(t){let e=Br(t,"x","erf");k("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=Qa(e,"float32"));const n={x:e};return Rr.runKernel("Erf",n)}});function vi(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function Ti(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)-1===e.indexOf(a)&&n.push(t[a]);return[n,e.map((e=>t[e]))]}function Si(t,e){return function(t,e,n){const r=t.length+e.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(t[s++]):a.push(e[o++]);return a}(t,e.map((t=>1)),e)}function Ni(t,e,n){k(vi(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function xi(t,e){if(vi(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function ki(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function Ci(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const Ai=jr({max_:function(t,e=null,n=!1){const r={x:Br(t,"x","max")},a={reductionIndices:e,keepDims:n};return Rr.runKernel(me,r,a)}});const Di=jr({min_:function(t,e=null,n=!1){const r={x:Br(t,"x","min")},a={axis:e,keepDims:n};return Rr.runKernel(ge,r,a)}});const Ei=jr({sum_:function(t,e=null,n=!1){let r=Br(t,"x","sum");"bool"===r.dtype&&(r=Qa(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return Rr.runKernel(en,a,s)}});function Pi(t,e,n=null){if(0===t.rank)return ys(t);if(1!==t.rank&&null===n)return Pi(Co(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return Ei(ys(t),n);if(e===1/0)return Ai(ys(t),n);if(e===-1/0)return Di(ys(t),n);if("euclidean"===e||2===e)return as(Ei(fs(ys(t),us(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return Ai(Ei(ys(t),n[0]),n[1]-1);if(e===1/0)return Ai(Ei(ys(t),n[1]),n[0]);if(e===-1/0)return Di(Ei(ys(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return as(Ei(ss(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Fi=jr({norm_:function(t,e="euclidean",n=null,r=!1){const a=Pi(t=Br(t,"x","norm"),e,n);let s=a.shape;if(r){const e=$(n,t.shape);s=Si(a.shape,e)}return Co(a,s)}});const $i=jr({euclideanNorm_:function(t,e=null,n=!1){return Fi(t,"euclidean",e,n)}});const Oi=jr({exp_:function(t){const e={x:Br(t,"x","exp")};return Rr.runKernel("Exp",e)}});const Ri=jr({expandDims_:function(t,e=0){const n=Br(t,"x","expandDims","string_or_numeric");k(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:e};return Rr.runKernel(Ut,r,a)}});const Ii=jr({expm1_:function(t){const e={x:Br(t,"x","expm1")};return Rr.runKernel(Wt,e)}});const Mi=jr({tile_:function(t,e){const n=Br(t,"x","tile","string_or_numeric");k(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const r={x:n},a={reps:e};return Rr.runKernel(bn,r,a)}});const Li=jr({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const a=Ga([t,e],r),s=t<=e?t:e;for(let t=0;t<s;++t)a.set(1,t,t);const o=Co(a.toTensor(),[t,e]);if(null==n)return o;if(1===n.length)return Mi(Ri(o,0),[n[0],1,1]);if(2===n.length)return Mi(Ri(Ri(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Mi(Ri(Ri(Ri(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const zi=jr({floor_:function(t){const e={x:Br(t,"x","floor","float32")};return Rr.runKernel(Ht,e)}});const Vi=jr({gather_:function(t,e,n=0,r=0){const a={x:Br(t,"x","gather"),indices:Br(e,"indices","gather","int32")},s={axis:n,batchDims:r};return Rr.runKernel(Xt,a,s)}});const Bi=jr({greater_:function(t,e){let n=Br(t,"a","greater","string_or_numeric"),r=Br(e,"b","greater","string_or_numeric");[n,r]=Ar(n,r),bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(Kt,a)}});const Ui=jr({greaterEqual_:function(t,e){let n=Br(t,"a","greaterEqual","string_or_numeric"),r=Br(e,"b","greaterEqual","string_or_numeric");[n,r]=Ar(n,r),bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(Zt,a)}});const Wi=jr({imag_:function(t){const e={input:Br(t,"input","imag")};return Rr.runKernel("Imag",e)}});const ji=jr({isFinite_:function(t){const e={x:Br(t,"x","isFinite")};return Rr.runKernel(te,e)}});const qi=jr({isInf_:function(t){const e={x:Br(t,"x","isInf")};return Rr.runKernel(ee,e)}});const Hi=jr({isNaN_:function(t){const e={x:Br(t,"x","isNaN")};return Rr.runKernel(ne,e)}});const Gi=jr({leakyRelu_:function(t,e=.2){const n={x:Br(t,"x","leakyRelu")},r={alpha:e};return Rr.runKernel(re,n,r)}});const Qi=jr({less_:function(t,e){let n=Br(t,"a","less","string_or_numeric"),r=Br(e,"b","less","string_or_numeric");[n,r]=Ar(n,r),bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(ae,a)}});const Xi=jr({lessEqual_:function(t,e){let n=Br(t,"a","lessEqual","string_or_numeric"),r=Br(e,"b","lessEqual","string_or_numeric");[n,r]=Ar(n,r),bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(se,a)}});function Ji(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return Rr.runKernel(oe,{},r)}const Ki=jr({localResponseNormalization_:function(t,e=5,n=1,r=1,a=.5){const s=Br(t,"x","localResponseNormalization");k(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),k(P(e),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`));let o=s,i=!1;3===s.rank&&(i=!0,o=Co(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const u={x:o},l={depthRadius:e,bias:n,alpha:r,beta:a},c=Rr.runKernel(de,u,l);return i?Co(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Zi=jr({log_:function(t){const e={x:Br(t,"x","log","float32")};return Rr.runKernel("Log",e)}});const Yi=jr({log1p_:function(t){const e={x:Br(t,"x","log1p")};return Rr.runKernel(ie,e)}});const tu=jr({neg_:function(t){const e={x:Br(t,"x","neg")};return Rr.runKernel("Neg",e)}});const eu=jr({softplus_:function(t){const e={x:Br(t,"x","softplus")};return Rr.runKernel(Ye,e)}});const nu=jr({logSigmoid_:function(t){const e=Br(t,"x","logSigmoid");return is((t=>({value:tu(eu(tu(t))),gradFunc:e=>rs(e,Fo(tu(t)))})))(e)}});const ru=jr({logSoftmax_:function(t,e=-1){const n=Br(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);const r=is(((t,n)=>{const r=Ai(t,e,!0),a=hs(t,r),s=hs(Qa(a,"float32"),Zi(Ei(Oi(a),e,!0)));n([s]);return{value:s,gradFunc:(t,n)=>{const[r]=n,a=Oi(r);return hs(t,rs(Ei(t,e,!0),a))}}}));return r(n)}});const au=jr({logSumExp_:function(t,e=null,n=!1){const r=Br(t,"x","logSumExp"),a=$(e,r.shape),s=Ai(r,a,!0),o=hs(r,s),i=Oi(o),u=Ei(i,a),l=Zi(u),c=ts(Co(s,l.shape),l);if(n){const t=Si(c.shape,a);return Co(c,t)}return c}});const su=jr({logicalAnd_:function(t,e){const n=Br(t,"a","logicalAnd","bool"),r=Br(e,"b","logicalAnd","bool");bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(ue,a)}});const ou=jr({logicalNot_:function(t){const e={x:Br(t,"x","logicalNot","bool")};return Rr.runKernel(le,e)}});const iu=jr({logicalOr_:function(t,e){const n=Br(t,"a","logicalOr","bool"),r=Br(e,"b","logicalOr","bool");bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(ce,a)}});const uu=jr({logicalXor_:function(t,e){const n=Br(t,"a","logicalXor","bool"),r=Br(e,"b","logicalXor","bool");return bs(n.shape,r.shape),su(iu(t,e),ou(su(t,e)))}}),lu=2147483648;const cu=jr({searchSorted_:function(t,e,n="left"){const r=Br(t,"sortedSequence","searchSorted"),a=Br(e,"values","searchSorted"),s=r.shape[r.shape.length-1],o=a.shape[a.shape.length-1],i=Co(r,[-1,s]),u=Co(a,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(D(u.shape)>=lu)throw new Error("values tensor size must less than 2147483648");if(i.shape[1]>=lu)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${i.shape[1]}`);const l={sortedSequence:i,values:u},c={side:n};return Rr.runKernel(Ge,l,c)}});function du(t,e){return cu(t,e,"left")}const pu=jr({maxPool_:function(t,e,n,r,a){const s=Br(t,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=Co(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),k(So(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),ko("maxPool",r,a);const u={x:o},l={filterSize:e,strides:n,pad:r,dimRoundingMode:a},c=Rr.runKernel(he,u,l);return i?Co(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const mu=jr({maxPool3d_:function(t,e=[1,1,1],n,r,a,s="NDHWC"){const o=Br(t,"x","maxPool3d");let i=o,u=!1;4===o.rank&&(u=!0,i=Co(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),k(5===i.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`)),k("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),ko("maxPool3d",r,a);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=Rr.runKernel(ye,l,c);return u?Co(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const fu=jr({maxPoolWithArgmax_:function(t,e,n,r,a=!1){const s={x:Br(t,"x","maxPoolWithArgmax")},o={filterSize:e,strides:n,pad:r,includeBatchInIndex:a},i=Rr.runKernel("MaxPoolWithArgmax",s,o);return{result:i[0],indexes:i[1]}}});const hu=jr({mean_:function(t,e=null,n=!1){const r={x:Br(t,"x","mean")},a={axis:e,keepDims:n};return Rr.runKernel(be,r,a)}});function yu(t,e="float32"){if(j(t),"complex64"===e){const e=yu(t,"float32"),n=yu(t,"float32");return qr(e,n)}const n=W(D(t),e);return Rr.makeTensor(n,t,e)}function bu(t,e="float32"){if(j(t),"complex64"===e){const e=bu(t,"float32"),n=yu(t,"float32");return qr(e,n)}const n=U(D(t),e);return Rr.makeTensor(n,t,e)}function gu(t,e,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===t)return[];let r=Br(t,"x","meshgrid",t instanceof br?t.dtype:"float32");if(void 0===e)return[r];let a=Br(e,"y","meshgrid",e instanceof br?e.dtype:"float32");const s=D(r.shape),o=D(a.shape);return"xy"===n?(r=Co(r,[1,-1]),a=Co(a,[-1,1]),[Po(bu([o,1],r.dtype),r),Po(a,bu([1,s],a.dtype))]):(r=Co(r,[-1,1]),a=Co(a,[1,-1]),[Po(r,bu([1,o],r.dtype)),Po(bu([s,1],a.dtype),a)])}const wu=jr({minimum_:function(t,e){let n=Br(t,"a","minimum"),r=Br(e,"b","minimum");[n,r]=Ar(n,r),"bool"===n.dtype&&(n=Qa(n,"int32"),r=Qa(r,"int32")),bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(we,a)}});const _u=jr({mirrorPad_:function(t,e,n){k("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=Br(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");k(e.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`));const a="reflect"===n?1:0;for(let t=0;t<r.rank;t++)k(2===e[t].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),k(e[t][0]>=0&&e[t][0]<=r.shape[t]-a&&e[t][1]>=0&&e[t][1]<=r.shape[t]-a,(()=>`Padding in dimension ${t} cannot be greater than or equal to ${r.shape[t]-a} or less than 0 for input of shape ${r.shape}`));const s={paddings:e,mode:n},o={x:r};return Rr.runKernel(_e,o,s)}});const vu=jr({mod_:function(t,e){let n=Br(t,"a","mod"),r=Br(e,"b","mod");[n,r]=Ar(n,r);const a={a:n,b:r};return Rr.runKernel("Mod",a)}});const Tu=jr({moments_:function(t,e=null,n=!1){const r=$(e,(t=Br(t,"x","moments")).shape),a=hu(t,r,n);let s=a.shape;n||(s=Si(a.shape,r));const o=ss(hs(Qa(t,"float32"),Co(a,s)));return{mean:a,variance:hu(o,r,n)}}});const Su=jr({multiRNNCell_:function(t,e,n,r){const a=Br(e,"data","multiRNNCell"),s=Ur(n,"c","multiRNNCell"),o=Ur(r,"h","multiRNNCell");let i=a;const u=[];for(let e=0;e<t.length;e++){const n=t[e](i,s[e],o[e]);u.push(n[0]),u.push(n[1]),i=n[1]}const l=[],c=[];for(let t=0;t<u.length;t+=2)l.push(u[t]),c.push(u[t+1]);return[l,c]}});const Nu=jr({multinomial_:function(t,e,n,r=!1){const a=Br(t,"logits","multinomial"),s=a.size,o=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const i={logits:1===o?Co(a,[1,-1]):a},u={numSamples:e,seed:n,normalized:r},l=Rr.runKernel(ve,i,u);return 1===o?Co(l,[l.size]):l}});const xu=jr({notEqual_:function(t,e){let n=Br(t,"a","notEqual","string_or_numeric"),r=Br(e,"b","notEqual","string_or_numeric");[n,r]=Ar(n,r),bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(Se,a)}});const ku=jr({oneHot_:function(t,e,n=1,r=0,a="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const s={indices:Br(t,"indices","oneHot","int32")},o={dtype:a,depth:e,onValue:n,offValue:r};return Rr.runKernel(Ae,s,o)}});const Cu=jr({onesLike_:function(t){const e={x:Br(t,"x","onesLike")};return Rr.runKernel(Ce,e)}});const Au=jr({outerProduct_:function(t,e){const n=Br(t,"v1","outerProduct"),r=Br(e,"v2","outerProduct");k(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const a=Co(n,[-1,1]),s=Co(r,[1,-1]);return Po(a,s)}});const Du=jr({pad_:function(t,e,n=0){const r=Br(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:e,constantValue:n},s={x:r};return Rr.runKernel(Ee,s,a)}});const Eu=jr({pad1d_:function(t,e,n=0){return k(2===e.length,(()=>"Invalid number of paddings. Must be length of 2.")),Du(t,[e],n)}});const Pu=jr({pad2d_:function(t,e,n=0){return k(2===e.length&&2===e[0].length&&2===e[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Du(t,e,n)}});const Fu=jr({pad3d_:function(t,e,n=0){return k(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Du(t,e,n)}});const $u=jr({pad4d_:function(t,e,n=0){return k(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Du(t,e,n)}});const Ou=jr({spaceToBatchND_:function(t,e,n){const r=Br(t,"x","spaceToBatchND");k(r.rank>=1+e.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`)),k(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),k(r.shape.reduce(((t,r,a)=>a>0&&a<=e.length?t&&(r+n[a-1][0]+n[a-1][1])%e[a-1]==0:t),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const a={x:r},s={blockShape:e,paddings:n};return Rr.runKernel(nn,a,s)}});const Ru=jr({pool_:function(t,e,n,r,a,s,o){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");const i=Br(t,"x","maxPool");let u=i,l=!1;3===i.rank&&(l=!0,u=Co(i,[1,i.shape[0],i.shape[1],i.shape[2]])),k(So(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));const c=mo(u.shape,e,s,a,r),d=[c.dilationHeight,c.dilationWidth];let p;p="same"===r?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))),r=n.map((t=>t-1)),a=r.map((t=>Math.floor(t/2))),s=r.map(((t,e)=>t-a[e]));return r.map(((t,e)=>[a[e],s[e]]))}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const m=1===d[0]&&1===d[1],[f,h]=function(t,e,n){const r=n.map((t=>t[0])),a=n.map((t=>t[1])),s=t.concat(r,a),o=e.map(((t,e)=>(t-s[e]%t)%t)),i=a.map(((t,e)=>t+o[e])),u=e.map(((t,e)=>[r[e],i[e]])),l=e.map(((t,e)=>[0,o[e]]));return[u,l]}([c.inHeight,c.inWidth],d,p),y=m?r:"valid",b=m?u:Ou(u,d,f),g=("avg"===n?()=>Ao(b,e,s,y,o):()=>pu(b,e,s,y,o))(),w=m?g:Io(g,d,h);return l?Co(w,[w.shape[1],w.shape[2],w.shape[3]]):w}});const Iu=jr({prelu_:function(t,e){const n={x:Br(t,"x","prelu"),alpha:Br(e,"alpha","prelu")};return Rr.runKernel(Pe,n)}});const Mu=jr({prod_:function(t,e=null,n=!1){let r=Br(t,"x","prod");"bool"===r.dtype&&(r=Qa(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return Rr.runKernel(Fe,a,s)}});const Lu=jr({raggedGather_:function(t,e,n,r){const a={paramsNestedSplits:t.map(((t,e)=>Br(t,`tensors${e}`,"raggedGather","int32"))),paramsDenseValues:Br(e,"paramsDenseValues","raggedGather"),indices:Br(n,"indices","raggedGather","int32")},s={outputRaggedRank:r},o=Rr.runKernel("RaggedGather",a,s);return{outputNestedSplits:o.slice(0,o.length-1),outputDenseValues:o[o.length-1]}}});const zu=jr({raggedRange_:function(t,e,n){const r=Br(t,"starts","raggedRange"),a={starts:r,limits:Br(e,"limits","raggedRange",r.dtype),deltas:Br(n,"deltas","raggedRange",r.dtype)},s=Rr.runKernel("RaggedRange",a);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});const Vu=jr({raggedTensorToTensor_:function(t,e,n,r,a){const s=Br(t,"shape","raggedTensorToTensor","int32"),o=Br(e,"values","raggedTensorToTensor"),i={shape:s,values:o,defaultValue:Br(n,"defaultValue","raggedTensorToTensor",o.dtype),rowPartitionTensors:r.map(((t,e)=>Br(t,`tensors${e}`,"raggedTensorToTensor","int32")))},u={rowPartitionTypes:a};return Rr.runKernel("RaggedTensorToTensor",i,u)}});const Bu=jr({rand_:function(t,e,n){j(t);const r=D(t);let a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let t=0;t<r;t++)a[t]=e();return Rr.makeTensor(a,t,n)}});var Uu=n(307);class Wu{constructor(t,e,n,r,a){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=Uu.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class ju{constructor(t,e,n,r){this.alpha=t,this.beta=1/e,this.dtype=n;const a=r||Math.random();this.randu=Uu.alea(a.toString()),this.randn=new Wu(0,1,n,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,t=r*r,e=1-.331*t*t,n=.5*t+this.d*(1-s+Math.log(s)),a=this.randu(),a<e||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class qu{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Uu.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Hu=jr({randomGamma_:function(t,e,n=1,r="float32",a){if(j(t),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const s=new ju(e,n,r,a),o=Ga(t,r);for(let t=0;t<o.values.length;t++)o.values[t]=s.nextValue();return o.toTensor()}});const Gu=jr({randomNormal_:function(t,e=0,n=1,r,a){if(j(t),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new Wu(e,n,r,!1,a),o=Ga(t,r);for(let t=0;t<o.values.length;t++)o.values[t]=s.nextValue();return o.toTensor()}});const Qu=jr({randomStandardNormal_:function(t,e,n){if(null!=e&&"bool"===e)throw new Error(`Unsupported data type ${e}`);return Gu(t,0,1,e,n)}});const Xu=jr({randomUniform_:function(t,e=0,n=1,r="float32",a){j(t);const s=Ga(t,r),o=new qu(e,n,null,a);for(let t=0;t<s.values.length;t++)s.values[t]=o.nextValue();return s.toTensor()}});const Ju=jr({randomUniformInt_:function(t,e,n,r){return Xu(t,e,n,"int32",r)}});function Ku(t,e,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const a={start:t,stop:e,step:n,dtype:r};return Rr.runKernel($e,{},a)}const Zu=jr({real_:function(t){const e={input:Br(t,"input","real")};return Rr.runKernel("Real",e)}});const Yu=jr({reciprocal_:function(t){const e={x:Br(t,"x","reciprocal")};return Rr.runKernel(Oe,e)}});const tl=jr({relu_:function(t){const e={x:Br(t,"x","relu")};return Rr.runKernel(Re,e)}});const el=jr({relu6_:function(t){const e={x:Br(t,"x","relu6")};return Rr.runKernel(Be,e)}});const nl=jr({reverse_:function(t,e){const n={x:Br(t,"x","reverse")},r={dims:e};return Rr.runKernel(Ue,n,r)}});const rl=jr({reverse1d_:function(t){const e=Br(t,"x","reverse");return k(1===e.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`)),nl(e,0)}});const al=jr({reverse2d_:function(t,e){const n=Br(t,"x","reverse");return k(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),nl(n,e)}});const sl=jr({reverse3d_:function(t,e){const n=Br(t,"x","reverse");return k(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),nl(n,e)}});const ol=jr({reverse4d_:function(t,e){const n=Br(t,"x","reverse");return k(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),nl(n,e)}});const il=jr({round_:function(t){const e={x:Br(t,"x","round")};return Rr.runKernel(We,e)}});const ul=jr({rsqrt_:function(t){const e={x:Br(t,"x","rsqrt","float32")};return Rr.runKernel(je,e)}});const ll=jr({selu_:function(t){const e={x:Br(t,"x","selu")};return Rr.runKernel(Xe,e)}});const cl=jr({separableConv2d_:function(t,e,n,r,a,s=[1,1],o="NHWC"){const i=Br(t,"x","separableConv2d"),u=Br(e,"depthwiseFilter","separableConv2d"),l=Br(n,"pointwiseFilter","separableConv2d");let c=i,d=!1;if(3===i.rank&&(d=!0,c=Co(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");k(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),k(4===u.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`)),k(4===l.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`)),k(1===l.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`)),k(1===l.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`));const p=u.shape[2],m=u.shape[3];k(l.shape[2]===p*m,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*m}, but got ${l.shape[2]}.`));const f=ci(c,u,r,a,o,s),h=Ko(f,l,1,"valid",o);return d?Co(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const dl=async function(t,e){const n=Br(t,"x","setdiff1d"),r=Br(e,"y","setdiff1d");k(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),k(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),k(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const a=await n.data(),s=await r.data(),o=new Set(s);let i=0;for(let t=0;t<a.length;t++)o.has(a[t])||i++;const u=new mr([i],n.dtype),l=new mr([i],"int32");for(let t=0,e=0;t<a.length;t++)o.has(a[t])||(u.values[e]=a[t],l.values[e]=t,e++);return[u.toTensor(),l.toTensor()]};const pl=jr({sign_:function(t){const e={x:Br(t,"x","sign")};return Rr.runKernel(Ke,e)}});const ml=jr({sin_:function(t){const e={x:Br(t,"x","sin","float32")};return Rr.runKernel("Sin",e)}});const fl=jr({sinh_:function(t){const e={x:Br(t,"x","sinh")};return Rr.runKernel("Sinh",e)}});const hl=jr({slice1d_:function(t,e,n){const r=Br(t,"x","slice1d");return k(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),$o(r,[e],[n])}});const yl=jr({slice2d_:function(t,e,n){const r=Br(t,"x","slice2d");return k(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),$o(r,e,n)}});const bl=jr({slice3d_:function(t,e,n){const r=Br(t,"x","slice3d");return k(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),$o(r,e,n)}});const gl=jr({slice4d_:function(t,e,n){const r=Br(t,"x","slice4d");return k(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),$o(r,e,n)}});const wl=jr({softmax_:function(t,e=-1){const n=Br(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},a={dim:e};return Rr.runKernel(an,r,a)}});const _l=jr({fft_:function(t){k("complex64"===t.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`));const e={input:t};return Rr.runKernel("FFT",e)}});const vl=jr({ifft_:function(t){k("complex64"===t.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`));const e={input:t};return Rr.runKernel("IFFT",e)}});const Tl=jr({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const a=Co(t,[n,e]);r=vl(a)}else{const a=[n,2*(e-1)],s=Co(Zu(t),[n,e]),o=Co(Wi(t),[n,e]),i=nl($o(s,[0,1],[n,e-2]),1),u=rs(nl($o(o,[0,1],[n,e-2]),1),us(-1)),l=Eo([s,i],1),c=Eo([o,u],1),d=Co(qr(l,c),[a[0],a[1]]);r=vl(d)}if(r=Zu(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=Co(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}});const Sl=jr({split_:function(t,e,n=0){const r={x:Br(t,"x","split")},a={numOrSizeSplits:e,axis:n};return Rr.runKernel(rn,r,a)}});const Nl=jr({rfft_:function(t,e){k("float32"===t.dtype,(()=>`The dtype for rfft() must be real value but got ${t.dtype}`));let n=t.shape[t.shape.length-1];const r=t.size/n;let a;if(null!=e&&e<n){const r=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,a=$o(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,a=Eo([t,yu(r)],t.shape.length-1),n=e}else a=t;const s=os(a),o=Co(qr(a,s),[r,n]),i=_l(o),u=Math.floor(n/2)+1,l=Zu(i),c=Wi(i),d=Sl(l,[u,n-u],l.shape.length-1),p=Sl(c,[u,n-u],c.shape.length-1),m=a.shape.slice();return m[a.shape.length-1]=u,Co(qr(d[0],p[0]),m)}});const xl=jr({squaredDifference_:function(t,e){let n=Br(t,"a","squaredDifference"),r=Br(e,"b","squaredDifference");[n,r]=Ar(n,r),bs(n.shape,r.shape);const a={a:n,b:r};return Rr.runKernel(dn,a,{})}});const kl=jr({squeeze_:function(t,e){const n=Br(t,"x","squeeze","string_or_numeric");return Co(n,function(t,e){const n=[],r=[],a=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||a?null:$(e,t).sort();let o=0;for(let e=0;e<t.length;++e){if(null!=s){if(s[o]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==s[o]||s[o]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),s[o]<=e&&o++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}(n.shape,e).newShape)}});const Cl=jr({stack_:function(t,e=0){const n=Ur(t,"tensors","stack","string_or_numeric");k(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&k(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:e};return Rr.runKernel(De,r,a)}});const Al=jr({step_:function(t,e=0){const n={x:Br(t,"x","step")},r={alpha:e};return Rr.runKernel(Nn,n,r)}});const Dl=jr({stridedSlice_:function(t,e,n,r,a=0,s=0,o=0,i=0,u=0){const l={x:Br(t,"x","stridedSlice","string_or_numeric")},c={begin:e,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return Rr.runKernel(pn,l,c)}});const El=jr({tan_:function(t){const e={x:Br(t,"x","tan","float32")};return Rr.runKernel("Tan",e)}});function Pl(t,e){A(t);const n=Lr(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Hr(t,null,n,e)}function Fl(t,e,n){if(A(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Lr(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Hr(t,e,r,n)}function $l(t,e,n){if(A(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Lr(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Hr(t,e,r,n)}function Ol(t,e,n){if(A(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Lr(t,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Hr(t,e,r,n)}function Rl(t,e,n){if(A(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Lr(t,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Hr(t,e=e||r,r,n)}const Il=jr({tensorScatterUpdate_:function(t,e,n){const r=Br(t,"tensor","tensorScatterupdate"),a=Br(e,"indices","tensorScatterupdate","int32"),s=Br(n,"updates","tensorScatterupdate");if(Hs(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);const o={tensor:r,indices:a,updates:s};return Rr.runKernel(He,o,{})}});const Ml=jr({topk_:function(t,e=1,n=!0){const r=Br(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${e}`);const s={x:r},o={k:e,sorted:n},[i,u]=Rr.runKernel(gn,s,o);return{values:i,indices:u}}});const Ll=jr({truncatedNormal_:function(t,e=0,n=1,r,a){if(j(t),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new Wu(e,n,r,!0,a),o=Ga(t,r);for(let t=0;t<o.values.length;t++)o.values[t]=s.nextValue();return o.toTensor()}});const zl=jr({unique_:function(t,e=0){const n=Br(t,"x","unique","string_or_numeric");k(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:e},[s,o]=Rr.runKernel(vn,r,a);return{values:s,indices:o}}});const Vl=jr({unsortedSegmentSum_:function(t,e,n){const r=Br(t,"x","unsortedSegmentSum"),a=Br(e,"segmentIds","unsortedSegmentSum","int32");k(P(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},o={numSegments:n};return Rr.runKernel("UnsortedSegmentSum",s,o)}});const Bl=jr({unstack_:function(t,e=0){const n=Br(t,"x","unstack","string_or_numeric");k(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},a={axis:e};return Rr.runKernel(Tn,r,a)}});function Ul(t,e){return cu(t,e,"right")}function Wl(t,e=!0,n,r){return Rr.makeVariable(t,e,n,r)}const jl=async function(t){const e=Br(t,"condition","whereAsync","bool"),n=await e.data(),r=function(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const r=Ga(t,"int32"),a=Ga([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const s=r.indexToLoc(n[e]),o=e*t.length;a.values.set(s,o)}return a.toTensor()}(e.shape,n);return t!==e&&e.dispose(),r};const ql=async function(t,e,n){const r=Br(t,"tensor","boolMask"),a=Br(e,"mask","boolMask","bool"),s=null==n?0:n,o=a.rank,i=r.shape;k(o>0,(()=>"mask cannot be scalar")),C(i.slice(s,s+o),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let t=s;t<s+o;t++)u*=i[t];const l=i.slice(0,s).concat([u],i.slice(s+o)),c=Co(r,l),d=Co(a,[-1]),p=await jl(d),m=kl(p,[1]),f=Vi(c,m,s);return t!==r&&r.dispose(),e!==a&&a.dispose(),m.dispose(),c.dispose(),d.dispose(),p.dispose(),f};const Hl=jr({transpose_:function(t,e,n){const r=Br(t,"x","transpose");if(null==e&&(e=r.shape.map(((t,e)=>e)).reverse()),k(r.rank===e.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`)),e.forEach((t=>{k(t>=0&&t<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${e}`))})),r.rank<=1)return r.clone();const a={x:r},s={perm:e};return"complex64"===r.dtype?Ka((()=>{let t=Zu(r),e=Wi(r);return t=Rr.runKernel(_n,{x:t},s),e=Rr.runKernel(_n,{x:e},s),n&&(e=tu(e)),qr(t,e)})):Rr.runKernel(_n,a,s)}});const Gl=jr({movingAverage_:function(t,e,n,r,a=!0){const s=Br(t,"v","movingAverage"),o=Br(e,"x","movingAverage"),i=Br(n,"decay","movingAverage");var u,l;l=o,k((u=s).dtype===l.dtype,(()=>`The dtypes of the first(${u.dtype}) and second(${l.dtype}) input must match`)),k(E(s.shape,o.shape),(()=>"Shape mismatch in v and x"));const c=us(1),d=hs(c,i);let p=rs(hs(o,s),d);if(a){k(null!=r,(()=>"When using zeroDebias: true, step is required."));const t=Br(r,"step","movingAverage");p=ns(p,hs(c,fs(i,t)))}return ts(s,p)}});const Ql=jr({scatterND_:function(t,e,n){j(n);const r=Br(t,"indices","scatterND","int32"),a=Br(e,"updates","scatterND");Hs(a,r,n);const s={indices:r,updates:a},o={shape:n};return Rr.runKernel(qe,s,o)}});const Xl=jr({sparseToDense_:function(t,e,n,r=0){j(n);const a=Br(t,"sparseIndices","sparseToDense","int32"),s=Br(e,"sparseValues","sparseToDense","string_or_numeric"),o=Br(r,"defaultValue","sparseToDense",s.dtype);!function(t,e,n,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const a=t.rank>0?t.shape[0]:1,s=t.rank>1?t.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const o=e.size;if(0!==e.rank&&(1!==e.rank||o!==a))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${a}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,s,n,o);const i={sparseIndices:a,sparseValues:s,defaultValue:o},u={outputShape:n};return Rr.runKernel(cn,i,u)}});const Jl=jr({gatherND_:function(t,e){const n=Br(e,"indices","gatherND","int32"),r={params:Br(t,"x","gatherND","string_or_numeric"),indices:n};return Rr.runKernel(Jt,r)}});const Kl=jr({dropout_:function(t,e,n,r){const a=Br(t,"x","dropout");if(k("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),k(e>=0&&e<1,(()=>`rate must be a float in the range [0, 1), but got ${e}.`)),0===e)return t instanceof br?a.clone():a;const s=function(t,e){if(null==e)return t.shape.slice();if(E(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(a,n),o=1-e,i=ns(zi(ts(Xu(s,0,1,"float32",r),o)),o);return rs(a,i)}});function Zl(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Yl(t,e,n){const r=1-t%2,a=new Float32Array(t);for(let s=0;s<t;++s){const o=2*Math.PI*s/(t+r-1);a[s]=e-n*Math.cos(o)}return Pl(a,"float32")}const tc=async function(t,e,n=1){const r=Br(t,"predictions","inTopK"),a=Br(e,"targets","inTopK");k(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),k(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),C(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];k(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));const o=await r.data(),i=await a.data(),[u,l]=[o.length/s,s],c=function(t,e){return O(t,e)}("bool",u);for(let t=0;t<u;t++){const e=t*l,r=o.subarray(e,e+l),a=[];for(let t=0;t<r.length;t++)a.push({value:r[t],index:t});a.sort(((t,e)=>e.value-t.value)),c[t]=0;for(let e=0;e<n;e++)if(a[e].index===i[t]){c[t]=1;break}}return t!==r&&r.dispose(),e!==a&&a.dispose(),Gr(c,a.shape,"bool")};const ec=jr({conv2DBackpropFilter_:function(t,e,n,r,a,s="NHWC",o){let i=t;3===t.rank&&(i=Co(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;3===u.rank&&(u=Co(e,[1,e.shape[0],e.shape[1],e.shape[2]])),k(4===i.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`)),k(4===u.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`)),k(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const l="NHWC"===s?i.shape[3]:i.shape[1],c="NHWC"===s?u.shape[3]:u.shape[1];k(l===n[2],(()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`)),k(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),ko("conv2dDerFilter",a,o);const d={x:i,dy:u},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return Rr.runKernel("Conv2DBackpropFilter",d,p)}});function nc(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return rs(t,Al(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function rc(t,e){let n=e;const r=function(t,e){const n=[];for(let r=0;r<e.length;r++){const a=t[t.length-r-1],s=e.length-r-1,o=e[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}(t.shape,e.shape);return r.length>0&&(n=Ei(n,r)),Co(n,t.shape)}function ac(t,e,n,r){if("linear"===e)return t;if("relu"===e)return tl(t);if("elu"===e)return gi(t);if("relu6"===e)return el(t);if("prelu"===e)return Iu(t,n);if("leakyrelu"===e)return Gi(t,r);if("sigmoid"===e)return Fo(t);throw new Error(`Unknown fused activation ${e}.`)}const sc=(t,e)=>!(t>0)||"linear"===e;const oc=jr({fusedConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",!1===sc(Rr.state.gradientDepth,u)){k("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let d=Ko(t,e,n,r,a,s,o);return null!=i&&(d=ts(d,i)),ac(d,u,l,c)}const d=Br(t,"x","conv2d","float32"),p=Br(e,"filter","conv2d","float32");let m=d,f=!1;3===d.rank&&(f=!0,m=Co(d,[1,d.shape[0],d.shape[1],d.shape[2]])),k(4===m.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`)),k(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),ko("fused conv2d",r,o);const h="NHWC"===a?m.shape[3]:m.shape[1];k(p.shape[2]===h,(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${p.shape[2]}.`)),k(So(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));const y=ho(m.shape,p.shape,n,s,r,o);let b,g;if(null!=i&&(b=Br(i,"bias","fused conv2d"),[b]=Ar(b,d),"NHWC"===a?bs(y.outShape,b.shape):(k(b.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),k(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)))),null!=l){const t=l.shape;if(k(t.length<=1||3===t.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${t.length}.`)),1===t.length)k(1===t[0]||t[0]===y.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${t}) is not compatible with the number of output channels (${y.outChannels}).`));else if(3===t.length)try{bs(t,y.outShape)}catch(e){const n=`Error in fused conv2d: PReLU activation weights (${t}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(n)}g=Br(l,"prelu weights","fused conv2d")}const w=(t,e)=>{k("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));const[o,i,l,c]=e,d=nc(t,l,u);k(To(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));const p=[Yo(i.shape,d,o,n,r),ec(i,d,o.shape,n,r)];if(null!=c){const t=rc(c,d);p.push(t)}return p},_={x:m,filter:p,bias:b,preluActivationWeights:g},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:c};if(null==i){const t=is(((t,e,n)=>{let r=Rr.runKernel(An,_,v);return n([e,t,r]),f&&(r=Co(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}));return t(m,p)}{const t=is(((t,e,n,r)=>{let a=Rr.runKernel(An,_,v);return r([e,t,a,n]),f&&(a=Co(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:w}}));return t(m,p,b)}}});const ic=jr({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,a,s=[1,1],o){let i=t;3===t.rank&&(i=Co(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;3===u.rank&&(u=Co(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:i,dy:u},c={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return Rr.runKernel("DepthwiseConv2dNativeBackpropFilter",l,c)}});const uc=jr({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,a,s=[1,1],o){let i=e,u=!1;3===e.rank&&(u=!0,i=Co(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:i,filter:n},c={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:t},d=Rr.runKernel("DepthwiseConv2dNativeBackpropInput",l,c);return u?Co(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const lc=jr({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===sc(Rr.state.gradientDepth,u)){let d=ci(t,e,n,r,a,s,o);return null!=i&&(d=ts(d,i)),ac(d,u,l,c)}const d=Br(t,"x","depthwiseConv2d","float32"),p=Br(e,"filter","depthwiseConv2d","float32");let m=d,f=!1;3===d.rank&&(f=!0,m=Co(d,[1,d.shape[0],d.shape[1],d.shape[2]])),k(4===m.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`)),k(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),k(m.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==s&&(s=[1,1]),k(So(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),ko("fused depthwiseConv2d",r,o);const h=ho(m.shape,p.shape,n,s,r,o,!0);let y,b;null!=i&&(y=Br(i,"bias","fused conv2d"),[y]=Ar(y,d),bs(h.outShape,y.shape)),null!=l&&(b=Br(l,"prelu weights","fused depthwiseConv2d"));const g=(t,e)=>{k(To(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));const[a,i,l,c]=e,d=nc(t,l,u),p=uc(i.shape,d,a,n,r,s,o),m=ic(i,d,a.shape,n,r,s,o);if(null!=c){return[p,m,rc(y,d)]}return[p,m]},w={x:m,filter:p,bias:y,preluActivationWeights:b},_={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:c};if(null==i){const t=is(((t,e,n)=>{let r=Rr.runKernel(Dn,w,_);return n([e,t,r]),f&&(r=Co(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:g}}));return t(m,p)}{const t=is(((t,e,n,r)=>{let a=Rr.runKernel(Dn,w,_);return r([e,t,a,n]),f&&(a=Co(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:g}}));return t(m,p,y)}}});const cc=jr({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(!1===sc(Rr.state.gradientDepth,s)){let u=Po(t,e,n,r);return null!=a&&(u=ts(u,a)),ac(u,s,o,i)}let u=Br(t,"a","fused matMul"),l=Br(e,"b","fused matMul");[u,l]=Ar(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],d=r?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],m=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),h=l.shape.slice(0,-2),y=D(f),b=D(h);k(c===d,(()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`));const g=bs(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([p,m]),w=Co(u,n?[y,c,p]:[y,p,c]),_=Co(l,r?[b,m,d]:[b,d,m]);let v,T;null!=a&&(v=Br(a,"bias","fused matMul"),[v]=Ar(v,u),bs(g,v.shape)),null!=o&&(T=Br(o,"prelu weights","fused matMul"));const S=(t,e)=>{const[o,i,u,l]=e,c=nc(Co(t,u.shape),u,s);let d,p;if(n||r?!n&&r?(d=Po(c,i,!1,!1),p=Po(c,o,!0,!1)):n&&!r?(d=Po(i,c,!1,!0),p=Po(o,c,!1,!1)):(d=Po(i,c,!0,!0),p=Po(c,o,!0,!0)):(d=Po(c,i,!1,!0),p=Po(o,c,!0,!1)),null!=a){return[d,p,rc(l,c)]}return[d,p]},N={a:w,b:_,bias:v,preluActivationWeights:T},x={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:i};if(null==a){const t=is(((t,e,n)=>{const r=Rr.runKernel(Cn,N,x);return n([t,e,r]),{value:Co(r,g),gradFunc:S}}));return t(w,_)}{const t=is(((t,e,n,r)=>{const a=Rr.runKernel(Cn,N,x);return r([t,e,a,n]),{value:Co(a,g),gradFunc:S}}));return t(w,_,v)}}});const dc=jr({hammingWindow_:function(t){return Yl(t,.54,.46)}});const pc=jr({hannWindow_:function(t){return Yl(t,.5,.5)}});const mc=jr({frame_:function(t,e,n,r=!1,a=0){let s=0;const o=[];for(;s+e<=t.size;)o.push($o(t,s,e)),s+=n;if(r)for(;s<t.size;){const r=s+e-t.size,i=Eo([$o(t,s,e-r),ms([r],a)]);o.push(i),s+=n}return 0===o.length?Fl([],[0,e]):Co(Eo(o),[o.length,e])}});const fc=jr({stft_:function(t,e,n,r,a=pc){null==r&&(r=Zl(e));const s=mc(t,e,n),o=rs(s,a(e));return Nl(o,r)}});const hc=jr({cropAndResize_:function(t,e,n,r,a="bilinear",s=0){const o=Br(t,"image","cropAndResize"),i=Br(e,"boxes","cropAndResize","float32"),u=Br(n,"boxInd","cropAndResize","int32"),l=i.shape[0];k(4===o.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`)),k(2===i.rank&&4===i.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`)),k(1===u.rank&&u.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`)),k(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),k(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),k("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));const c={image:o,boxes:i,boxInd:u},d={method:a,extrapolationValue:s,cropSize:r};return Rr.runKernel(Pt,c,d)}});const yc=jr({flipLeftRight_:function(t){const e=Br(t,"image","flipLeftRight","float32");k(4===e.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`));const n={image:e};return Rr.runKernel(qt,n,{})}});const bc=jr({grayscaleToRGB_:function(t){const e=Br(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];k(e.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`)),k(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const a=new Array(e.rank);return a.fill(1,0,n),a[n]=3,Mi(e,a)}});const gc=jr({rotateWithOffset_:function(t,e,n=0,r=.5){const a=Br(t,"image","rotateWithOffset","float32");k(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));const s={image:a},o={radians:e,fillValue:n,center:r};return Rr.runKernel(kn,s,o)}});function wc(t,e,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),k(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),k(2===t.rank,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`)),k(4===t.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`)),k(1===e.rank,(()=>"scores must be a 1D tensor")),k(e.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`)),k(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const _c=jr({nonMaxSuppression_:function(t,e,n,r=.5,a=Number.NEGATIVE_INFINITY){const s=Br(t,"boxes","nonMaxSuppression","float32"),o=Br(e,"scores","nonMaxSuppression","float32"),i=wc(s,o,n,r,a),u={maxOutputSize:n=i.maxOutputSize,iouThreshold:r=i.iouThreshold,scoreThreshold:a=i.scoreThreshold};return Rr.runKernel(Ne,{boxes:s,scores:o},u)}});function vc(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,a=t.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=n(e,t[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}(t,e,n||Tc)}(t,e,n),a=r<0?-(r+1):r;t.splice(a,0,e)}function Tc(t,e){return t>e?1:t<e?-1:0}function Sc(t,e,n,r,a,s,o=!1,i=!1,u=!1){const l=[];for(let t=0;t<e.length;t++)e[t]>a&&l.push({score:e[t],boxIndex:t,suppressBeginIndex:0});l.sort(kc);const c=s>0?-.5/s:0,d=[],p=[];for(;d.length<n&&l.length>0;){const e=l.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<a)break;let i=!1;for(let n=d.length-1;n>=o;--n){const o=Nc(t,s,d[n]);if(o>=r){i=!0;break}if(e.score=e.score*xc(r,c,o),e.score<=a)break}e.suppressBeginIndex=d.length,i||(e.score===n?(d.push(s),p.push(e.score)):e.score>a&&vc(l,e,kc))}const m=d.length,f=n-m;i&&f>0&&(d.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const h={selectedIndices:d};return o&&(h.selectedScores=p),u&&(h.validOutputs=m),h}function Nc(t,e,n){const r=t.subarray(4*e,4*e+4),a=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),p=Math.max(a[1],a[3]),m=(i-s)*(u-o),f=(d-l)*(p-c);if(m<=0||f<=0)return 0;const h=Math.max(s,l),y=Math.max(o,c),b=Math.min(i,d),g=Math.min(u,p),w=Math.max(b-h,0)*Math.max(g-y,0);return w/(m+f-w)}function xc(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function kc(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const Cc=async function(t,e,n,r=.5,a=Number.NEGATIVE_INFINITY){const s=Br(t,"boxes","nonMaxSuppressionAsync"),o=Br(e,"scores","nonMaxSuppressionAsync"),i=wc(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const u=await Promise.all([s.data(),o.data()]),l=u[0],c=u[1],{selectedIndices:d}=function(t,e,n,r,a){return Sc(t,e,n,r,a,0)}(l,c,n,r,a);return s!==t&&s.dispose(),o!==e&&o.dispose(),Pl(d,"int32")};const Ac=jr({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){const o=Br(t,"boxes","nonMaxSuppression"),i=Br(e,"scores","nonMaxSuppression"),u=wc(o,i,n,r,a,s),l={boxes:o,scores:i},c={maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:a=u.scoreThreshold,softNmsSigma:s=u.softNmsSigma},d=Rr.runKernel(ke,l,c);return{selectedIndices:d[0],selectedScores:d[1]}}});const Dc=async function(t,e,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){const o=Br(t,"boxes","nonMaxSuppressionAsync"),i=Br(e,"scores","nonMaxSuppressionAsync"),u=wc(o,i,n,r,a,s);n=u.maxOutputSize,r=u.iouThreshold,a=u.scoreThreshold,s=u.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),c=l[0],d=l[1],{selectedIndices:p,selectedScores:m}=function(t,e,n,r,a,s){return Sc(t,e,n,r,a,s,!0)}(c,d,n,r,a,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:Pl(p,"int32"),selectedScores:Pl(m)}};const Ec=jr({nonMaxSuppressionPadded_:function(t,e,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){const o=Br(t,"boxes","nonMaxSuppression"),i=Br(e,"scores","nonMaxSuppression"),u=wc(o,i,n,r,a,null),l={boxes:o,scores:i},c={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:s},d=Rr.runKernel(xe,l,c);return{selectedIndices:d[0],validOutputs:d[1]}}});const Pc=async function(t,e,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){const o=Br(t,"boxes","nonMaxSuppressionAsync"),i=Br(e,"scores","nonMaxSuppressionAsync"),u=wc(o,i,n,r,a,null),l=u.maxOutputSize,c=u.iouThreshold,d=u.scoreThreshold,[p,m]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:h}=function(t,e,n,r,a,s){return Sc(t,e,n,r,a,0,!1,s,!0)}(p,m,l,c,d,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:Pl(f,"int32"),validOutputs:us(h,"int32")}};const Fc=jr({resizeBilinear_:function(t,e,n=!1,r=!1){const a=Br(t,"images","resizeBilinear");k(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),k(2===e.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`)),k(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=Co(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},u={alignCorners:n,halfPixelCenters:r,size:e},l=Rr.runKernel(ze,i,u);return o?Co(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const $c=jr({resizeNearestNeighbor_:function(t,e,n=!1,r=!1){const a=Br(t,"images","resizeNearestNeighbor");k(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),k(2===e.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`)),k("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),k(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=Co(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},u={alignCorners:n,halfPixelCenters:r,size:e},l=Rr.runKernel(Me,i,u);return o?Co(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const Oc=jr({threshold_:function(t,e="binary",n=!1,r=.5){const a=Br(t,"image","threshold"),s=a.shape[0]*a.shape[1];let o,i,u,l,c=rs(Pl([r]),255);if(k(3===a.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`)),k(3===a.shape[2]||1===a.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`)),k("int32"===a.dtype||"float32"===a.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`)),k("otsu"===e||"binary"===e,(()=>`Method must be binary or otsu, but was ${e}`)),3===a.shape[2]){[o,i,u]=Sl(a,[1,1,1],-1);const t=rs(o,.2989),e=rs(i,.587),n=rs(u,.114);l=ts(ts(t,e),n)}else l=t;if("otsu"===e){c=function(t,e){let n,r,a,s,o,i,u=Pl([-1]),l=Pl([0]),c=Pl([0]);for(let d=0;d<t.size-1;d++){n=$o(t,0,d+1),r=$o(t,d+1),o=ns(Ei(n),e),i=ns(Ei(r),e);const p=Ei(rs(n,Ku(0,n.size)));a=ns(p,Ei(n));const m=ms(r.shape,n.size),f=ts(Ku(0,r.size),m),h=rs(r,f);s=ns(Ei(h),Ei(r));const y=hs(a,s),b=hs(a,s),g=rs(o,i);c=rs(rs(g,y),b);const w=Bi(c,l);l=fi(w,c,l),u=fi(w,Pl([d]),u)}return u}(Bo(Qa(il(l),"int32"),Gr([]),256),s)}const d=n?Xi(l,c):Bi(l,c);return Qa(rs(d,255),"int32")}});const Rc=jr({transform_:function(t,e,n="nearest",r="constant",a=0,s){const o=Br(t,"image","transform","float32"),i=Br(e,"transforms","transform","float32");k(4===o.rank,(()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`)),k(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),k(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const u={image:o,transforms:i},l={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Rr.runKernel(wn,u,l)}});const Ic=jr({bandPart_:function(t,e,n){const r=Br(t,"a","bandPart");k(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const a=r.shape,[s,o]=r.shape.slice(-2);let i,u;"number"==typeof e?(k(e%1==0,(()=>`bandPart(): numLower must be an integer, got ${e}.`)),k(e<=s,(()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`)),i=Br(e<0?s:e,"numLower","bandPart")):(k("int32"===e.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=fi(Qi(e,0),s,wu(e,s))),"number"==typeof n?(k(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),k(n<=o,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`)),u=Br(n<0?o:n,"numUpper","bandPart")):(k("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),u=fi(Qi(n,0),o,wu(n,o)));const l=Co(Ku(0,s,1,"int32"),[-1,1]),c=Ku(0,o,1,"int32"),d=hs(l,c),p=su(Xi(d,i),Ui(d,tu(u))),m=yu([s,o],r.dtype);return Co(Cl(Bl(Co(r,[-1,s,o])).map((t=>fi(p,t,m)))),a)}});const Mc=jr({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,k(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)k(t[e].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`))}else e=!0,t=Sl(t,t.shape[0],0).map((t=>kl(t,[0])));k(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`));const n=[],r=t;for(let e=0;e<t.length;++e)n.push(Rr.tidy((()=>{let t=r[e];if(e>0)for(let r=0;r<e;++r){const e=rs(Ei(rs(n[r],t)),n[r]);t=hs(t,e)}return ns(t,Fi(t,"euclidean"))})));return e?Cl(n,0):n}});function Lc(t,e=!1){return Rr.tidy((()=>{k(2===t.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const n=t.shape[0],r=t.shape[1];let a=Li(n),s=Xa(t);const o=Fl([[1]],[1,1]);let i=Xa(o);const u=n>=r?r:n;for(let t=0;t<u;++t){const e=s,u=i,l=a;[i,s,a]=Rr.tidy((()=>{const e=$o(s,[t,t],[n-t,1]),u=Fi(e),l=$o(s,[t,t],[1,1]),c=fi(Bi(l,0),Fl([[-1]]),Fl([[1]])),d=hs(l,rs(c,u)),p=ns(e,d);i=1===p.shape[0]?Xa(o):Eo([o,$o(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);const m=tu(ns(Po(c,d),u)),f=$o(s,[t,0],[n-t,r]),h=rs(m,i),y=Hl(i);if(0===t)s=hs(f,Po(h,Po(y,f)));else{const e=hs(f,Po(h,Po(y,f)));s=Eo([$o(s,[0,0],[t,r]),e],0)}const b=Hl(h),g=$o(a,[0,t],[n,a.shape[1]-t]);if(0===t)a=hs(g,Po(Po(g,i),b));else{const e=hs(g,Po(Po(g,i),b));a=Eo([$o(a,[0,0],[n,t]),e],1)}return[i,s,a]})),Za([e,u,l])}return!e&&n>r&&(a=$o(a,[0,0],[n,r]),s=$o(s,[0,0],[r,r])),[a,s]}))}const zc=jr({qr_:function(t,e=!1){if(k(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`)),2===t.rank)return Lc(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=Bl(Co(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),a=[],s=[];r.forEach((t=>{const[n,r]=Lc(t,e);a.push(n),s.push(r)}));return[Co(Cl(a,0),t.shape),Co(Cl(s,0),t.shape)]}}});var Vc;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Vc||(Vc={}));const Bc=jr({computeWeightedLoss_:function(t,e,n=Vc.SUM_BY_NONZERO_WEIGHTS){const r=Br(t,"losses","computeWeightedLoss");let a=null;null!=e&&(a=Br(e,"weights","computeWeightedLoss"));const s=null==a?r:rs(r,a);if(n===Vc.NONE)return s;if(n===Vc.SUM)return Ei(s);if(n===Vc.MEAN){if(null==a)return hu(s);{const t=r.size/a.size,e=ns(Ei(s),Ei(a));return t>1?ns(e,us(t)):e}}if(n===Vc.SUM_BY_NONZERO_WEIGHTS){if(null==a)return ns(Ei(s),us(r.size));{const t=rs(a,bu(r.shape)),e=Qa(Ei(xu(t,us(0))),"float32");return ns(Ei(s),e)}}throw Error(`Unknown reduction: ${n}`)}});const Uc=jr({absoluteDifference_:function(t,e,n,r=Vc.SUM_BY_NONZERO_WEIGHTS){const a=Br(t,"labels","absoluteDifference"),s=Br(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=Br(n,"weights","absoluteDifference")),C(a.shape,s.shape,"Error in absoluteDifference: ");const i=ys(hs(a,s));return Bc(i,o,r)}});const Wc=jr({cosineDistance_:function(t,e,n,r,a=Vc.SUM_BY_NONZERO_WEIGHTS){const s=Br(t,"labels","cosineDistance"),o=Br(e,"predictions","cosineDistance");let i=null;null!=r&&(i=Br(r,"weights","cosineDistance")),C(s.shape,o.shape,"Error in cosineDistance: ");const u=us(1),l=hs(u,Ei(rs(s,o),n,!0));return Bc(l,i,a)}});const jc=jr({hingeLoss_:function(t,e,n,r=Vc.SUM_BY_NONZERO_WEIGHTS){let a=Br(t,"labels","hingeLoss");const s=Br(e,"predictions","hingeLoss");let o=null;null!=n&&(o=Br(n,"weights","hingeLoss")),C(a.shape,s.shape,"Error in hingeLoss: ");const i=us(1);a=hs(rs(us(2),a),i);const u=tl(hs(i,rs(a,s)));return Bc(u,o,r)}});const qc=jr({huberLoss_:function(t,e,n,r=1,a=Vc.SUM_BY_NONZERO_WEIGHTS){const s=Br(t,"labels","huberLoss"),o=Br(e,"predictions","huberLoss");let i=null;null!=n&&(i=Br(n,"weights","huberLoss")),C(s.shape,o.shape,"Error in huberLoss: ");const u=us(r),l=ys(hs(o,s)),c=wu(l,u),d=hs(l,c),p=ts(rs(us(.5),ss(c)),rs(u,d));return Bc(p,i,a)}});const Hc=jr({logLoss_:function(t,e,n,r=1e-7,a=Vc.SUM_BY_NONZERO_WEIGHTS){const s=Br(t,"labels","logLoss"),o=Br(e,"predictions","logLoss");let i=null;null!=n&&(i=Br(n,"weights","logLoss")),C(s.shape,o.shape,"Error in logLoss: ");const u=us(1),l=us(r),c=tu(rs(s,Zi(ts(o,l)))),d=rs(hs(u,s),Zi(ts(hs(u,o),l))),p=hs(c,d);return Bc(p,i,a)}});const Gc=jr({meanSquaredError_:function(t,e,n,r=Vc.SUM_BY_NONZERO_WEIGHTS){const a=Br(t,"labels","meanSquaredError"),s=Br(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=Br(n,"weights","meanSquaredError")),C(a.shape,s.shape,"Error in meanSquaredError: ");const i=xl(a,s);return Bc(i,o,r)}});const Qc=jr({sigmoidCrossEntropy_:function(t,e,n,r=0,a=Vc.SUM_BY_NONZERO_WEIGHTS){let s=Br(t,"multiClassLabels","sigmoidCrossEntropy");const o=Br(e,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=Br(n,"weights","sigmoidCrossEntropy")),C(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=us(r),e=us(1),n=us(.5);s=ts(rs(s,hs(e,t)),rs(n,t))}const u=function(t,e){const n=Br(t,"labels","sigmoidCrossEntropyWithLogits"),r=Br(e,"logits","sigmoidCrossEntropyWithLogits");C(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=tl(r),s=rs(r,n),o=Yi(Oi(tu(ys(r))));return ts(hs(a,s),o)}(s,o);return Bc(u,i,a)}});const Xc=jr({softmaxCrossEntropy_:function(t,e,n,r=0,a=Vc.SUM_BY_NONZERO_WEIGHTS){let s=Br(t,"onehotLabels","softmaxCrossEntropy");const o=Br(e,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=Br(n,"weights","softmaxCrossEntropy")),C(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const t=us(r),e=us(1),n=us(s.shape[1]);s=ts(rs(s,hs(e,t)),ns(t,n))}const u=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);const r=is(((t,e,r)=>{const a=au(e,[n],!0),s=hs(Qa(e,"float32"),a);r([t,s]);const o=tu(rs(s,t));return{value:Ei(o,[n]),gradFunc:(t,e)=>{const[r,a]=e,s=Si(t.shape,[n]);return[rs(Co(t,s),hs(Qa(r,"float32"),Oi(a))),rs(Co(t,s),hs(Oi(a),Qa(r,"float32")))]}}}));return r(t,e)}(s,o);return Bc(u,i,a)}});const Jc=jr({sparseFillEmptyRows_:function(t,e,n,r){const a=Br(t,"indices","sparseFillEmptyRows","int32"),s=Br(e,"values","sparseFillEmptyRows"),o=Br(n,"denseShape","sparseFillEmptyRows","int32"),i=Br(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==i.rank)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:a,values:s,denseShape:o,defaultValue:i},l=Rr.runKernel(sn,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}});const Kc=jr({sparseReshape_:function(t,e,n){const r=Br(t,"inputIndices","sparseReshape","int32"),a=Br(e,"inputShape","sparseReshape","int32"),s=Br(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:r,inputShape:a,newShape:s},i=Rr.runKernel(on,o);return{outputIndices:i[0],outputShape:i[1]}}});const Zc=jr({sparseSegmentMean_:function(t,e,n){const r=Br(t,"data","sparseSegmentMean"),a=Br(e,"indices","sparseSegmentMean","int32"),s=Br(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return Rr.runKernel(un,o)}});const Yc=jr({sparseSegmentSum_:function(t,e,n){const r=Br(t,"data","sparseSegmentSum"),a=Br(e,"indices","sparseSegmentSum","int32"),s=Br(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return Rr.runKernel(ln,o)}});const td=jr({stringNGrams_:function(t,e,n,r,a,s,o,i){const u=Br(t,"data","stringNGrams","string");if("string"!==u.dtype)throw new Error("Data must be of datatype string");if(1!==u.shape.length)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=Br(e,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:o,preserveShortSequences:i},d={data:u,dataSplits:l},p=Rr.runKernel(mn,d,c);return{nGrams:p[0],nGramsSplits:p[1]}}});const ed={fft:_l,ifft:vl,rfft:Nl,irfft:Tl},nd={hammingWindow:dc,hannWindow:pc,frame:mc,stft:fc},rd={flipLeftRight:yc,grayscaleToRGB:bc,resizeNearestNeighbor:$c,resizeBilinear:Fc,rotateWithOffset:gc,cropAndResize:hc,nonMaxSuppression:_c,nonMaxSuppressionAsync:Cc,nonMaxSuppressionWithScore:Ac,nonMaxSuppressionWithScoreAsync:Dc,nonMaxSuppressionPadded:Ec,nonMaxSuppressionPaddedAsync:Pc,threshold:Oc,transform:Rc},ad={bandPart:Ic,gramSchmidt:Mc,qr:zc},sd={absoluteDifference:Uc,computeWeightedLoss:Bc,cosineDistance:Wc,hingeLoss:jc,huberLoss:qc,logLoss:Hc,meanSquaredError:Gc,sigmoidCrossEntropy:Qc,softmaxCrossEntropy:Xc},od={sparseFillEmptyRows:Jc,sparseReshape:Kc,sparseSegmentMean:Zc,sparseSegmentSum:Yc},id={stringNGrams:td,stringSplit:jr({stringSplit_:function(t,e,n=!0){const r=Br(t,"input","stringSplit","string"),a=Br(e,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);const s={skipEmpty:n},o={input:r,delimiter:a},i=Rr.runKernel(fn,o,s);return{indices:i[0],values:i[1],shape:i[2]}}}),stringToHashBucketFast:jr({stringToHashBucketFast_:function(t,e){const n=Br(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return Rr.runKernel(hn,a,r)}}),staticRegexReplace:jr({staticRegexReplace_:function(t,e,n,r=!0){const a=Br(t,"input","staticRegexReplace","string"),s={pattern:e,rewrite:n,replaceGlobal:r};return Rr.runKernel("StaticRegexReplace",{x:a},s)}})};function ud(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}var ld;!function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"}(ld||(ld={}));function cd(t,e,n,r=!0){let a=[];if(r)a=a.concat(e.slice(0)),a.push(t[0]/n),a=a.concat(t.slice(1));else{a=a.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)a=a.concat([t[r+1]/e[r],e[r]]);a=a.concat(t.slice(n+1))}return a}function dd(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],a=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function pd(t,e,n,r=!0){const a=[];r?a.push(t[0]/n):a.push(t[0]*n);for(let n=1;n<t.length;++n)n<=e.length?r?a.push(e[n-1]*t[n]):a.push(t[n]/e[n-1]):a.push(t[n]);return a}function md(t){try{return t.map((t=>nr(t)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function fd(t){return t.map((t=>er(t)))}!function(){for(const t of _s)ds(t)}();var hd,yd;X().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"}(hd||(hd={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(yd||(yd={}));const bd={};function gd(t){return bd[t]}function wd(t,e,n,r,a){const s=e.inputParams[t];if(s&&void 0!==s.inputIndexStart){const t=s.inputIndexStart,o=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?t+1:s.inputIndexEnd,i=t<0?e.inputNames.length+t:t;if("tensor"===s.type)return _d(e.inputNames[i],n,r,a);if("tensors"===s.type){const s=e.inputs.slice(t,o);return e.inputNames.slice(t,o).filter(((t,e)=>{var n;return"NoOp"!==(null===(n=s[e])||void 0===n?void 0:n.op)})).map((t=>_d(t,n,r,a)))}const u=_d(e.inputNames[i],n,r,a),l=u.dataSync();return"number"===s.type?l[0]:B(u.shape,l)}const o=e.attrParams[t];return o&&o.value}function _d(t,e,n,r){const[a,s]=Nd(t,n);if(null!=r){const t=r.getHashTableHandleByName(a);if(null!=t)return t}const o=n.currentContextIds.find((t=>!!e[Sd(a,t)]));return void 0!==o?e[Sd(a,o)][s]:void 0}function vd(t,e,n){return e[Sd(t,n.currentContextId)]}function Td(t,e){const[n,r,a]=Nd(t,e);return[Sd(n,e&&e.currentContextId),r,a]}function Sd(t,e){return e?`${t}-${e}`:t}function Nd(t,e){if(""===t)return["",0,void 0];const n=null!=e&&null!=e.parseNodeNameCache;if(n){const n=e.parseNodeNameCache.get(t);if(null!=n)return n}const r=t.split(":");let a;if(1===r.length)a=[t,0,void 0];else{const t=r[0],e=3===r.length?r[1]:void 0;a=[t,Number(r[r.length-1]),e]}return n&&e.parseNodeNameCache.set(t,a),a}function xd(t,e,n){let r=wd("pad",t,e,n);if("explicit"===r){r=wd("explicitPaddings",t,e,n);const a=[[0,0],[0,0],[0,0],[0,0]];for(let t=0;t<4;t++)a[t][0]=r[2*t],a[t][1]=r[2*t+1];return a}return r}function kd(t){return t.kept?t:Xa(t)}const Cd=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ad=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Dd=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Ed=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Pd=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Fd=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$d=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Od=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Rd=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Id=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Md=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Ld=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],zd=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Vd=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Bd=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Ud=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Wd=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],jd=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],qd=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class Hd{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[r,a,s,o,i,u,l,c,d,p,m,f,h,y,b,g,w,_,v].map((t=>t.json)));this.opMappers=t.reduce(((t,e)=>(t[e.tfOpName]=e,t)),{})}transformGraph(t,e={}){const n=t.node,r=[],a=[],s=[],o=n.reduce(((t,e)=>(t[e.name]=this.mapNode(e),e.op.startsWith("Placeholder")?r.push(t[e.name]):"Const"===e.op?a.push(t[e.name]):null!=e.input&&0!==e.input.length||s.push(t[e.name]),t)),{});let i=[];const u=[];let l={},c={};null!=e&&(l=this.mapSignatureEntries(e.inputs),c=this.mapSignatureEntries(e.outputs));const d=Object.keys(o);d.forEach((t=>{const e=o[t];e.inputNames.forEach(((t,n)=>{const[r,,a]=Td(t),s=o[r];if(null!=s.outputs){const t=s.outputs.indexOf(a);if(-1!==t){const a=`${r}:${t}`;e.inputNames[n]=a}}e.inputs.push(s),s.children.push(e)}))})),0===Object.keys(c).length?d.forEach((t=>{const e=o[t];0===e.children.length&&u.push(e)})):Object.keys(c).forEach((t=>{const[e]=Td(t),n=o[e];null!=n&&(n.signatureKey=c[t],u.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((t=>{const[e]=Td(t),n=o[e];n&&(n.signatureKey=l[t],i.push(n))})):i=r;let p={};null!=t.library&&null!=t.library.function&&(p=t.library.function.reduce(((t,e)=>(t[e.signature.name]=this.mapFunction(e),t)),{}));const m={nodes:o,inputs:i,outputs:u,weights:a,placeholders:r,signature:e,functions:p};return s.length>0&&(m.initNodes=s),m}mapSignatureEntries(t){return Object.keys(t||{}).reduce(((e,n)=>(e[t[n].name]=n,e)),{})}mapNode(t){const e=gd(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map((t=>t.startsWith("^")?t.slice(1):t)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(n.inputParams=e.inputs.reduce(((t,e)=>(t[e.name]={type:e.type,inputIndexStart:e.start,inputIndexEnd:e.end},t)),{})),null!=e.attrs&&(n.attrParams=e.attrs.reduce(((e,n)=>{const r=n.type;let a;switch(n.type){case"string":a=Qd(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=Qd(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":a=ap(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=ap(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":a=Jd(t.attr,n.tfName,n.defaultValue||0),void 0===a&&n.tfDeprecatedName&&(a=Jd(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":a=rp(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=rp(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":a=Xd(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=Xd(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":a=op(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=op(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":a=np(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=np(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":a=sp(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=sp(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":a=Yd(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=Yd(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":a=tp(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=tp(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":a=Zd(t.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=Zd(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${t.op}`)}return e[n.name]={value:a,type:r},e}),{})),n}mapFunction(t){const e=t.nodeDef,n=[];let r={};null!=e&&(r=e.reduce(((t,e)=>(t[e.name]=this.mapNode(e),"Const"===e.op&&n.push(t[e.name]),t)),{}));const a=[],s=[];t.signature.inputArg.forEach((t=>{const[e]=Td(t.name),n={name:e,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Kd(t.type),type:"dtype"}},children:[]};n.signatureKey=t.name,a.push(n),r[e]=n}));Object.keys(r).forEach((t=>{const e=r[t];e.inputNames.forEach(((t,n)=>{const[a,,s]=Td(t),o=r[a];if(null!=o.outputs){const t=o.outputs.indexOf(s);if(-1!==t){const r=`${a}:${t}`;e.inputNames[n]=r}}e.inputs.push(o),o.children.push(e)}))}));const o=t.ret;t.signature.outputArg.forEach((t=>{const[e,n]=Td(o[t.name]),a=r[e];null!=a&&(a.defaultOutput=n,s.push(a))}));const i=this.mapArgsToSignature(t);return{nodes:r,inputs:a,outputs:s,weights:n,placeholders:[],signature:i}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce(((t,e)=>(t[e.name]=this.mapArgToTensorInfo(e),t)),{}),outputs:t.signature.outputArg.reduce(((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e)),{})}}mapArgToTensorInfo(t,e){let n=t.name;return null!=e&&(n=e[n]),{name:n,dtype:t.type}}}function Gd(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):function(t){const e=X().global;if("undefined"!=typeof e.atob)return e.atob(t);if("undefined"!=typeof Buffer)return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return e?n:n.toLowerCase()}function Qd(t,e,n,r=!1){const a=t[e];return null!=a?Gd(a.s,r):n}function Xd(t,e,n){const r=t[e];return r?r.b:n}function Jd(t,e,n){const r=t[e]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function Kd(t){switch("string"==typeof t&&(t=hd[t]),t){case hd.DT_FLOAT:case hd.DT_HALF:return"float32";case hd.DT_INT32:case hd.DT_INT64:case hd.DT_INT8:case hd.DT_UINT8:return"int32";case hd.DT_BOOL:return"bool";case hd.DT_DOUBLE:return"float32";case hd.DT_STRING:return"string";default:return null}}function Zd(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function Yd(t,e,n){const r=t[e];return r&&r.type?Kd(r.type):n}function tp(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map((t=>Kd(t))):n}function ep(t){if(!t.unknownRank)return null!=t.dim?t.dim.map((t=>"number"==typeof t.size?t.size:parseInt(t.size,10))):[]}function np(t,e,n){const r=t[e];return r&&r.shape?ep(r.shape):n}function rp(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((t=>"number"==typeof t?t:parseInt(t,10))):n}function ap(t,e,n,r=!1){const a=t[e];return a&&a.list&&a.list.s?a.list.s.map((t=>Gd(t,r))):n}function sp(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map((t=>ep(t))):n}function op(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}class ip{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map((t=>this.getInput(t))),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce(((t,e)=>(t[e]=this.getAttr(e),t)),{}))}getInput(t){return _d(t,this.tensorMap,this.context)}getAttr(t,e){const n=this.node.rawAttrs[t];if(null!=n.tensor)return _d(t,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Jd(this.node.rawAttrs,t,e);if(null!=n.s)return Qd(this.node.rawAttrs,t,e);if(null!=n.b)return Xd(this.node.rawAttrs,t,e);if(null!=n.shape)return np(this.node.rawAttrs,t,e);if(null!=n.type)return Yd(this.node.rawAttrs,t,e);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return rp(this.node.rawAttrs,t,e);if(null!=n.list.s)return ap(this.node.rawAttrs,t,e);if(null!=n.list.shape)return sp(this.node.rawAttrs,t,e);if(null!=n.list.b)return op(this.node.rawAttrs,t,e);if(null!=n.list.type)return tp(this.node.rawAttrs,t,e)}return e}}function up(t,e,n=""){if("number"!=typeof t&&"number"!=typeof e){k(t.length===e.length,(()=>n+` Shapes ${t} and ${e} must match`));for(let r=0;r<t.length;r++){const a=t[r],s=e[r];k(a<0||s<0||a===s,(()=>n+` Shapes ${t} and ${e} must match`))}}}function lp(t){return"number"!=typeof t&&!t.some((t=>t<0))}function cp(t,e,n){let r=dp(t,n);const a=!lp(r);if(a&&0===e.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&e.forEach((t=>{r=dp(t.shape,r)})),!lp(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function dp(t,e){if("number"==typeof t)return e;if("number"==typeof e)return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const a=t[r],s=e[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=a>=0?a:s}return n}class pp{constructor(t,e,n,r,a,s,o){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=us(0),Ya(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.tensor.id)||e.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map((t=>this.read(t)))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),up(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Ya(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach(((t,n)=>this.write(t,e[n])))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let e=0;e<this.size();e++)t.push(e)}if(0===t.length)return Gr([],[0].concat(this.elementShape));const n=this.readMany(t);return up(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Cl(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return Gr([],[0].concat(this.elementShape));const e=[];for(let t=0;t<this.size();t++)e.push(t);const n=this.readMany(e);return up(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Eo(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,Bl(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0;const r=t.map((t=>(n+=t,n)));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const a=0===n?0:e.size/n,s=[];Ka((()=>{e=Co(e,[1,n,a]);for(let n=0;n<t.length;++n){const o=[0,0===n?0:r[n-1],0],i=[1,t[n],a];s[n]=Co($o(e,o,i),this.elementShape)}return s}));const o=[];for(let e=0;e<t.length;e++)o[e]=e;this.writeMany(o,s)}}class mp{get id(){return this.idTensor.id}constructor(t,e,n,r=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,null!=t&&t.forEach((t=>{if(n!==t.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${t.dtype}`);up(e,t.shape,"TensorList shape mismatch: "),Ya(t)})),this.idTensor=us(0),this.maxNumElements=r,Ya(this.idTensor)}copy(){return new mp([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.id)||e.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);up(t,this.elementShape,"TensorList shape mismatch: ");const r=cp(this.elementShape,this.tensors,t);return Ka((()=>{const t=this.tensors.map((t=>Co(t,r)));return Cl(t,0)}))}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=cp(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,up(r.shape,t,"TensorList shape mismatch: "),Co(r,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(up(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ya(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new mp([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let n=0;n<Math.min(this.tensors.length,t);++n)e.tensors[n]=this.tensors[n];return e}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);up(this.tensors[t].shape,e,"TensorList shape mismatch: ");const r=cp(this.elementShape,this.tensors,e);return Co(this.tensors[t],r)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);up(this.elementShape,e.shape,"TensorList shape mismatch: "),Ya(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);up(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());const r=cp(this.elementShape,this.tensors,n);return 0===t.length?Gr([],[0].concat(r)):Ka((()=>{const e=t.map((t=>Co(this.tensors[t],r)));return Cl(e,0)}))}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);up(this.elementShape,e,"TensorList shape mismatch: ");const n=cp(this.elementShape,this.tensors,e);return 0===this.size()?Gr([],[0].concat(n)):Ka((()=>{const t=this.tensors.map((t=>Co(t,n)));return Eo(t,0)}))}}const fp=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=wd("thenBranch",t,e,n),a=wd("elseBranch",t,e,n),s=wd("cond",t,e,n),o=wd("args",t,e,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=wd("body",t,e,n),a=wd("cond",t,e,n),s=wd("args",t,e,n),o=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),i=s.map((t=>t.id));let u=await o[0].data();o.forEach((t=>{t.kept||-1!==i.indexOf(t.id)||t.dispose()}));let l=s;for(;u[0];){const t=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const e=l.map((t=>t.id));t.forEach((t=>{t.kept||-1!==i.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}));const s=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await s[0].data(),s.forEach((t=>{t.kept||-1!==i.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}))}return l}case"LoopCond":return[kd(wd("pred",t,e,n))];case"Switch":{const r=wd("pred",t,e,n);let a=wd("data",t,e,n);return a.kept||(a=kd(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const r=t.inputNames.find((t=>void 0!==_d(t,e,n)));if(r){return[kd(_d(r,e,n))]}return}case"Enter":{const r=wd("frameName",t,e,n),a=wd("tensor",t,e,n);return n.enterFrame(r),[kd(a)]}case"Exit":{const r=wd("tensor",t,e,n);return n.exitFrame(),[kd(r)]}case"NextIteration":{const r=wd("tensor",t,e,n);return n.nextIteration(),[kd(r)]}case"TensorArrayV3":{const r=wd("size",t,e,n),a=wd("dtype",t,e,n),s=wd("elementShape",t,e,n),o=wd("dynamicSize",t,e,n),i=wd("clearAfterRead",t,e,n),u=wd("identicalElementShapes",t,e,n),l=wd("name",t,e,n),c=new pp(l,a,r,s,u,o,i);return n.addTensorArray(c),[c.idTensor,us(1)]}case"TensorArrayWriteV3":{const r=wd("tensorArrayId",t,e,n),a=wd("index",t,e,n),s=wd("tensor",t,e,n),o=n.getTensorArray(r.id);return o.write(a,s),[o.idTensor]}case"TensorArrayReadV3":{const r=wd("tensorArrayId",t,e,n),a=wd("index",t,e,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{const r=wd("tensorArrayId",t,e,n),a=wd("indices",t,e,n),s=wd("dtype",t,e,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{const r=wd("tensorArrayId",t,e,n),a=wd("indices",t,e,n),s=wd("tensor",t,e,n),o=n.getTensorArray(r.id);return o.scatter(a,s),[o.idTensor]}case"TensorArrayConcatV3":{const r=wd("tensorArrayId",t,e,n),a=n.getTensorArray(r.id),s=wd("dtype",t,e,n);return[a.concat(s)]}case"TensorArraySplitV3":{const r=wd("tensorArrayId",t,e,n),a=wd("tensor",t,e,n),s=wd("lengths",t,e,n),o=n.getTensorArray(r.id);return o.split(s,a),[o.idTensor]}case"TensorArraySizeV3":{const r=wd("tensorArrayId",t,e,n);return[us(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=wd("tensorArrayId",t,e,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const r=wd("tensorListId",t,e,n),a=wd("index",t,e,n),s=wd("tensor",t,e,n),o=n.getTensorList(r.id);return o.setItem(a,s),[o.idTensor]}case"TensorListGetItem":{const r=wd("tensorListId",t,e,n),a=wd("index",t,e,n),s=wd("elementShape",t,e,n),o=wd("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(a,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=wd("indices",t,e,n),a=function(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const a=Math.max(...e);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);const s=new mp([],n,t.dtype,r),o=Bl(t,0);return e.forEach(((t,e)=>{s.setItem(t,o[e])})),s}(wd("tensor",t,e,n),r,wd("elementShape",t,e,n),wd("numElements",t,e,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=wd("elementShape",t,e,n),a=wd("elementDType",t,e,n);let s;s="TensorListReserve"===t.op?"numElements":"maxNumElements";const o=wd(s,t,e,n),i=function(t,e,n,r){return new mp([],t,e,r)}(r,a,0,"TensorListReserve"===t.op?-1:o);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const r=wd("tensorListId",t,e,n),a=wd("indices",t,e,n),s=wd("elementShape",t,e,n),o=wd("elementDType",t,e,n);return[n.getTensorList(r.id).gather(a,o,s)]}case"TensorListStack":{const r=wd("tensorListId",t,e,n),a=wd("elementShape",t,e,n),s=wd("elementDType",t,e,n),o=wd("numElements",t,e,n);return[n.getTensorList(r.id).stack(a,s,o)]}case"TensorListFromTensor":{const r=function(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);up(t.shape.slice(1),e,"TensorList shape mismatch: ");const a=Bl(t);return new mp(a,e,r)}(wd("tensor",t,e,n),wd("elementShape",t,e,n),wd("elementDType",t,e,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=wd("tensorListId",t,e,n),a=n.getTensorList(r.id),s=wd("dtype",t,e,n),o=wd("elementShape",t,e,n);return[a.concat(s,o)]}case"TensorListPushBack":{const r=wd("tensorListId",t,e,n),a=wd("tensor",t,e,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{const r=wd("tensorListId",t,e,n),a=wd("elementShape",t,e,n),s=wd("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{const r=wd("tensor",t,e,n),a=wd("elementShape",t,e,n),s=function(t,e,n){let r=0;const a=e.map((t=>(r+=t,r)));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${t.shape}`);const s=dp(t.shape.slice(1),n),o=0===r?0:t.size/r,i=Ka((()=>{const n=[];t=Co(t,[1,r,o]);for(let r=0;r<e.length;++r){const i=[0,0===r?0:a[r-1],0],u=[1,e[r],o];n[r]=Co($o(t,i,u),s)}return t.dispose(),n})),u=new mp([],n,t.dtype,e.length);for(let t=0;t<i.length;t++)u.setItem(t,i[t]);return u}(r,wd("lengths",t,e,n),a);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{const r=wd("tensorListId",t,e,n);return[us(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=wd("tensorListId",t,e,n),a=wd("size",t,e,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};function hp(t,e,n){const[r,a]=wd("fusedOps",t,e,n),s="biasadd"===r,o=!s,i="prelu"===a,u="fusedbatchnorm"===r,l=wd("numArgs",t,e,n);if(s){if(i&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=wd("strides",t,e,n),d=xd(t,e,n),p=wd("dataFormat",t,e,n).toUpperCase(),m=wd("dilations",t,e,n);let[f,h]=wd("args",t,e,n);o&&(h=f,f=void 0);return{stride:c,pad:d,dataFormat:p,dilations:m,biasArg:f,preluArg:h,activationFunc:a,leakyreluAlpha:wd("leakyreluAlpha",t,e,n)}}function yp(t,e,n){return{boxes:wd("boxes",t,e,n),scores:wd("scores",t,e,n),maxOutputSize:wd("maxOutputSize",t,e,n),iouThreshold:wd("iouThreshold",t,e,n),scoreThreshold:wd("scoreThreshold",t,e,n),softNmsSigma:wd("softNmsSigma",t,e,n)}}class bp{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=us(0),this.tensorMap=new Map,Ya(this.handle)}clearAndClose(){this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return us(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);const n=await t.data();return this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),Ka((()=>{const t=Bl(e),r=n.length,a=t.length;k(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let e=0;e<r;e++){const r=n[e],a=t[e];Ya(a),this.tensorMap.set(r,a)}return this.handle}))}async find(t,e){this.checkKeyAndValueTensor(t,e);const n=await t.data();return Ka((()=>{const t=[];for(let r=0;r<n.length;r++){const a=n[r],s=this.findWithDefault(a,e);t.push(s)}return Cl(t)}))}findWithDefault(t,e){const n=this.tensorMap.get(t);return null!=n?n:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}function gp(t,e,n,r,a=Ka){const s=((t,e,n)=>{switch(t.category){case"arithmetic":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(wd("a",t,e,n),wd("b",t,e,n))];case"AddN":return[r.addN(wd("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(wd("a",t,e,n),wd("b",t,e,n))];case"Mul":return[r.mul(wd("a",t,e,n),wd("b",t,e,n))];case"RealDiv":case"Div":return[r.div(wd("a",t,e,n),wd("b",t,e,n))];case"DivNoNan":return[r.divNoNan(wd("a",t,e,n),wd("b",t,e,n))];case"FloorDiv":return[r.floorDiv(wd("a",t,e,n),wd("b",t,e,n))];case"Sub":return[r.sub(wd("a",t,e,n),wd("b",t,e,n))];case"Minimum":return[r.minimum(wd("a",t,e,n),wd("b",t,e,n))];case"Maximum":return[r.maximum(wd("a",t,e,n),wd("b",t,e,n))];case"Pow":return[r.pow(wd("a",t,e,n),wd("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(wd("a",t,e,n),wd("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"basic_math":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(wd("x",t,e,n))];case"Acos":return[r.acos(wd("x",t,e,n))];case"Acosh":return[r.acosh(wd("x",t,e,n))];case"Asin":return[r.asin(wd("x",t,e,n))];case"Asinh":return[r.asinh(wd("x",t,e,n))];case"Atan":return[r.atan(wd("x",t,e,n))];case"Atan2":return[r.atan2(wd("x",t,e,n),wd("y",t,e,n))];case"Atanh":return[r.atanh(wd("x",t,e,n))];case"Ceil":return[r.ceil(wd("x",t,e,n))];case"Complex":return[r.complex(wd("real",t,e,n),wd("imag",t,e,n))];case"Cos":return[r.cos(wd("x",t,e,n))];case"Cosh":return[r.cosh(wd("x",t,e,n))];case"Elu":return[r.elu(wd("x",t,e,n))];case"Erf":return[r.erf(wd("x",t,e,n))];case"Exp":return[r.exp(wd("x",t,e,n))];case"Expm1":return[r.expm1(wd("x",t,e,n))];case"Floor":return[r.floor(wd("x",t,e,n))];case"Log":return[r.log(wd("x",t,e,n))];case"Log1p":return[r.log1p(wd("x",t,e,n))];case"Imag":return[r.imag(wd("x",t,e,n))];case"Neg":return[r.neg(wd("x",t,e,n))];case"Reciprocal":return[r.reciprocal(wd("x",t,e,n))];case"Real":return[r.real(wd("x",t,e,n))];case"Relu":return[r.relu(wd("x",t,e,n))];case"Round":return[r.round(wd("x",t,e,n))];case"Selu":return[r.selu(wd("x",t,e,n))];case"Sigmoid":return[r.sigmoid(wd("x",t,e,n))];case"Sin":return[r.sin(wd("x",t,e,n))];case"Sign":return[r.sign(wd("x",t,e,n))];case"Sinh":return[r.sinh(wd("x",t,e,n))];case"Softplus":return[r.softplus(wd("x",t,e,n))];case"Sqrt":return[r.sqrt(wd("x",t,e,n))];case"Square":return[r.square(wd("x",t,e,n))];case"Tanh":return[r.tanh(wd("x",t,e,n))];case"Tan":return[r.tan(wd("x",t,e,n))];case"ClipByValue":return[r.clipByValue(wd("x",t,e,n),wd("clipValueMin",t,e,n),wd("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(wd("x",t,e,n))];case"Rsqrt":return[r.rsqrt(_d(t.inputNames[0],e,n))];case"LeakyRelu":return[r.leakyRelu(wd("x",t,e,n),wd("alpha",t,e,n))];case"Prelu":return[r.prelu(wd("x",t,e,n),wd("alpha",t,e,n))];case"IsNan":return[r.isNaN(_d(t.inputNames[0],e,n))];case"IsInf":return[r.isInf(_d(t.inputNames[0],e,n))];case"IsFinite":return[r.isFinite(_d(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"control":return fp(t,e,n);case"convolution":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"Conv1D":{const a=wd("stride",t,e,n),s=wd("pad",t,e,n),o=wd("dataFormat",t,e,n).toUpperCase(),i=wd("dilation",t,e,n);return[r.conv1d(wd("x",t,e,n),wd("filter",t,e,n),a,s,o,i)]}case"Conv2D":{const a=wd("strides",t,e,n),s=xd(t,e,n),o=wd("dataFormat",t,e,n).toUpperCase(),i=wd("dilations",t,e,n);return[r.conv2d(wd("x",t,e,n),wd("filter",t,e,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:a,pad:s,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:d}=hp(t,e,n);return[r.fused.conv2d({x:wd("x",t,e,n),filter:wd("filter",t,e,n),strides:[a[1],a[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:s,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:d}=hp(t,e,n);return[r.fused.depthwiseConv2d({x:wd("x",t,e,n),filter:wd("filter",t,e,n),strides:[a[1],a[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=wd("outputShape",t,e,n),s=wd("strides",t,e,n),o=xd(t,e,n);return[r.conv2dTranspose(wd("x",t,e,n),wd("filter",t,e,n),a,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=wd("strides",t,e,n),s=xd(t,e,n),o=wd("dilations",t,e,n),i=wd("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(wd("input",t,e,n),wd("filter",t,e,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const a=wd("strides",t,e,n),s=wd("pad",t,e,n),o=wd("dataFormat",t,e,n).toUpperCase(),i=wd("dilations",t,e,n);return[r.conv3d(wd("x",t,e,n),wd("filter",t,e,n),[a[1],a[2],a[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const a=wd("strides",t,e,n),s=wd("pad",t,e,n),o=wd("kernelSize",t,e,n);return[r.avgPool(wd("x",t,e,n),[o[1],o[2]],[a[1],a[2]],s)]}case"MaxPool":{const a=wd("strides",t,e,n),s=wd("pad",t,e,n),o=wd("kernelSize",t,e,n);return[r.maxPool(wd("x",t,e,n),[o[1],o[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{const a=wd("strides",t,e,n),s=wd("pad",t,e,n),o=wd("kernelSize",t,e,n),i=wd("includeBatchInIndex",t,e,n),{result:u,indexes:l}=r.maxPoolWithArgmax(wd("x",t,e,n),[o[1],o[2]],[a[1],a[2]],s,i);return[u,l]}case"AvgPool3D":{const a=wd("strides",t,e,n),s=wd("pad",t,e,n),o=wd("kernelSize",t,e,n);return[r.avgPool3d(wd("x",t,e,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{const a=wd("strides",t,e,n),s=wd("pad",t,e,n),o=wd("kernelSize",t,e,n);return[r.maxPool3d(wd("x",t,e,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{const a=wd("strides",t,e,n),s=wd("pad",t,e,n),o=wd("dilations",t,e,n),i=a[1],u=a[2],l=o[1],c=o[2];return[r.dilation2d(wd("x",t,e,n),wd("filter",t,e,n),[i,u],s,[l,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"creation":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"Fill":{const a=wd("shape",t,e,n),s=wd("dtype",t,e,n),o=wd("value",t,e,n);return[r.fill(a,o,s)]}case"LinSpace":{const a=wd("start",t,e,n),s=wd("stop",t,e,n),o=wd("num",t,e,n);return[r.linspace(a,s,o)]}case"Multinomial":{const a=wd("logits",t,e,n),s=wd("numSamples",t,e,n),o=wd("seed",t,e,n);return[r.multinomial(a,s,o)]}case"OneHot":{const a=wd("indices",t,e,n),s=wd("depth",t,e,n),o=wd("onValue",t,e,n),i=wd("offValue",t,e,n),u=wd("dtype",t,e,n);return[r.oneHot(a,s,o,i,u)]}case"Ones":return[r.ones(wd("shape",t,e,n),wd("dtype",t,e,n))];case"OnesLike":return[r.onesLike(wd("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(wd("shape",t,e,n),wd("dtype",t,e,n),wd("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(wd("shape",t,e,n),wd("minval",t,e,n),wd("maxval",t,e,n),wd("dtype",t,e,n))];case"RandomUniformInt":return[r.randomUniformInt(wd("shape",t,e,n),wd("minval",t,e,n),wd("maxval",t,e,n),wd("seed",t,e,n))];case"Range":{const a=wd("start",t,e,n),s=wd("stop",t,e,n),o=wd("step",t,e,n);return[r.range(a,s,o,wd("dtype",t,e,n))]}case"TruncatedNormal":{const a=wd("shape",t,e,n),s=wd("mean",t,e,n),o=wd("stdDev",t,e,n),i=wd("seed",t,e,n);return[r.truncatedNormal(a,s,o,wd("dtype",t,e,n),i)]}case"Zeros":return[r.zeros(wd("shape",t,e,n),wd("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(wd("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"dynamic":return(async(t,e,n,r,a=T)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=yp(t,e,n),c=await a.image.nonMaxSuppressionWithScoreAsync(r,s,o,i,u,l);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=yp(t,e,n),l=wd("padToMaxOutputSize",t,e,n),c=await a.image.nonMaxSuppressionPaddedAsync(r,s,o,i,u,l);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=yp(t,e,n);return[await a.image.nonMaxSuppressionAsync(r,s,o,i,u)]}case"Where":{const r=a.cast(wd("condition",t,e,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(wd("x",t,e,n),wd("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n);case"evaluation":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"LowerBound":{const a=wd("sortedSequence",t,e,n),s=wd("values",t,e,n);return[r.lowerBound(a,s)]}case"TopKV2":{const a=wd("x",t,e,n),s=wd("k",t,e,n),o=wd("sorted",t,e,n),i=r.topk(a,s,o);return[i.values,i.indices]}case"UpperBound":{const a=wd("sortedSequence",t,e,n),s=wd("values",t,e,n);return[r.upperBound(a,s)]}case"Unique":{const a=wd("x",t,e,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{const a=wd("x",t,e,n),s=wd("axis",t,e,n),o=r.unique(a,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"image":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"ResizeBilinear":{const a=wd("images",t,e,n),s=wd("size",t,e,n),o=wd("alignCorners",t,e,n),i=wd("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(a,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const a=wd("images",t,e,n),s=wd("size",t,e,n),o=wd("alignCorners",t,e,n),i=wd("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],o,i)]}case"CropAndResize":{const a=wd("image",t,e,n),s=wd("boxes",t,e,n),o=wd("boxInd",t,e,n),i=wd("cropSize",t,e,n),u=wd("method",t,e,n),l=wd("extrapolationValue",t,e,n);return[r.image.cropAndResize(a,s,o,i,u,l)]}case"ImageProjectiveTransformV3":{const a=wd("images",t,e,n),s=wd("transforms",t,e,n),o=wd("outputShape",t,e,n),i=wd("fillValue",t,e,n),u=wd("interpolation",t,e,n),l=wd("fillMode",t,e,n);return[r.image.transform(a,s,u.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"graph":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const a=wd("default",t,e,n);return[_d(t.name,e,n)||a];case"Placeholder":return[_d(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[kd(wd("x",t,e,n))];case"IdentityN":return wd("x",t,e,n).map((t=>kd(t)));case"Shape":return[r.tensor1d(wd("x",t,e,n).shape,"int32")];case"ShapeN":return wd("x",t,e,n).map((t=>r.tensor1d(t.shape)));case"Size":return[r.scalar(wd("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(wd("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const s=wd("x",t,e,n),o=wd("data",t,e,n),i=wd("message",t,e,n),u=wd("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let t=0;t<o.length;t++)console.log(Array.prototype.slice.call(o[t].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"logical":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"Equal":return[r.equal(wd("a",t,e,n),wd("b",t,e,n))];case"NotEqual":return[r.notEqual(wd("a",t,e,n),wd("b",t,e,n))];case"Greater":return[r.greater(wd("a",t,e,n),wd("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(wd("a",t,e,n),wd("b",t,e,n))];case"Less":return[r.less(wd("a",t,e,n),wd("b",t,e,n))];case"LessEqual":return[r.lessEqual(wd("a",t,e,n),wd("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(wd("a",t,e,n),wd("b",t,e,n))];case"LogicalNot":return[r.logicalNot(wd("a",t,e,n))];case"LogicalOr":return[r.logicalOr(wd("a",t,e,n),wd("b",t,e,n))];case"Select":case"SelectV2":return[r.where(wd("condition",t,e,n),wd("a",t,e,n),wd("b",t,e,n))];case"BitwiseAnd":return[r.bitwiseAnd(wd("a",t,e,n),wd("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"matrices":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(wd("a",t,e,n),wd("b",t,e,n),wd("transposeA",t,e,n),wd("transposeB",t,e,n))];case"Einsum":return[r.einsum(wd("equation",t,e,n),...wd("tensors",t,e,n))];case"Transpose":return[r.transpose(wd("x",t,e,n),wd("perm",t,e,n))];case"_FusedMatMul":const[a,s]=wd("fusedOps",t,e,n),o="biasadd"===a,i="prelu"===s,u=wd("numArgs",t,e,n),l=wd("leakyreluAlpha",t,e,n);if(o){if(i&&2!==u)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==u)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=wd("args",t,e,n);return[r.fused.matMul({a:wd("a",t,e,n),b:wd("b",t,e,n),transposeA:wd("transposeA",t,e,n),transposeB:wd("transposeB",t,e,n),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:l})];case"MatrixBandPart":return[r.linalg.bandPart(wd("a",t,e,n),wd("numLower",t,e,n),wd("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"normalization":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(wd("x",t,e,n),wd("axis",t,e,n),wd("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(wd("x",t,e,n),wd("mean",t,e,n),wd("variance",t,e,n),wd("offset",t,e,n),wd("scale",t,e,n),wd("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(wd("x",t,e,n),wd("radius",t,e,n),wd("bias",t,e,n),wd("alpha",t,e,n),wd("beta",t,e,n))];case"Softmax":return[r.softmax(wd("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(wd("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"ragged":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(wd("paramsNestedSplits",t,e,n),wd("paramsDenseValues",t,e,n),wd("indices",t,e,n),wd("outputRaggedRank",t,e,n));return a.concat(s)}case"RaggedRange":{const{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(wd("starts",t,e,n),wd("limits",t,e,n),wd("splits",t,e,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(wd("shape",t,e,n),wd("values",t,e,n),wd("defaultValue",t,e,n),wd("rowPartitionTensors",t,e,n),wd("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"reduction":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"Max":{const a=wd("axis",t,e,n),s=wd("keepDims",t,e,n);return[r.max(wd("x",t,e,n),a,s)]}case"Mean":{const a=wd("axis",t,e,n),s=wd("keepDims",t,e,n);return[r.mean(wd("x",t,e,n),a,s)]}case"Min":{const a=wd("axis",t,e,n),s=wd("keepDims",t,e,n);return[r.min(wd("x",t,e,n),a,s)]}case"Sum":{const a=wd("axis",t,e,n),s=wd("keepDims",t,e,n);return[r.sum(wd("x",t,e,n),a,s)]}case"All":{const a=wd("axis",t,e,n),s=wd("keepDims",t,e,n);return[r.all(wd("x",t,e,n),a,s)]}case"Any":{const a=wd("axis",t,e,n),s=wd("keepDims",t,e,n);return[r.any(wd("x",t,e,n),a,s)]}case"ArgMax":{const a=wd("axis",t,e,n);return[r.argMax(wd("x",t,e,n),a)]}case"ArgMin":{const a=wd("axis",t,e,n);return[r.argMin(wd("x",t,e,n),a)]}case"Prod":{const a=wd("axis",t,e,n),s=wd("keepDims",t,e,n);return[r.prod(wd("x",t,e,n),a,s)]}case"Cumprod":{const a=wd("axis",t,e,n),s=wd("exclusive",t,e,n),o=wd("reverse",t,e,n);return[r.cumprod(wd("x",t,e,n),a,s,o)]}case"Cumsum":{const a=wd("axis",t,e,n),s=wd("exclusive",t,e,n),o=wd("reverse",t,e,n);return[r.cumsum(wd("x",t,e,n),a,s,o)]}case"Bincount":const a=wd("x",t,e,n),s=wd("weights",t,e,n),o=wd("size",t,e,n);return[r.bincount(a,s,o)];case"DenseBincount":{const a=wd("x",t,e,n),s=wd("weights",t,e,n),o=wd("size",t,e,n),i=wd("binaryOutput",t,e,n);return[r.denseBincount(a,s,o,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"slice_join":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"ConcatV2":case"Concat":{const a=wd("n",t,e,n),s=wd("axis",t,e,n);let o=wd("tensors",t,e,n);return o=o.slice(0,a),[r.concat(o,s)]}case"Gather":{const a=wd("x",t,e,n),s=wd("indices",t,e,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{const a=wd("axis",t,e,n),s=wd("batchDims",t,e,n),o=wd("x",t,e,n),i=wd("indices",t,e,n);return[r.gather(o,r.cast(i,"int32"),a,s)]}case"Reverse":{const a=wd("dims",t,e,n),s=[];for(let t=0;t<a.length;t++)a[t]&&s.push(t);const o=wd("x",t,e,n);return[r.reverse(o,s)]}case"ReverseV2":{const a=wd("axis",t,e,n),s=wd("x",t,e,n);return[r.reverse(s,a)]}case"Slice":{const a=wd("begin",t,e,n),s=wd("size",t,e,n);return[r.slice(wd("x",t,e,n),a,s)]}case"StridedSlice":{const a=wd("begin",t,e,n),s=wd("end",t,e,n),o=wd("strides",t,e,n),i=wd("beginMask",t,e,n),u=wd("endMask",t,e,n),l=wd("ellipsisMask",t,e,n),c=wd("newAxisMask",t,e,n),d=wd("shrinkAxisMask",t,e,n),p=wd("x",t,e,n);return[r.stridedSlice(p,a,s,o,i,u,l,c,d)]}case"Pack":return Ka((()=>{const a=wd("axis",t,e,n),s=wd("tensors",t,e,n),o=s[0].shape,i=r.squeeze(s[0]).shape,u=s.map((t=>{const e=E(t.shape,o);if(!e&&!E(r.squeeze(t).shape,i))throw new Error("the input tensors shape does not match");return e?t:r.reshape(t,o)}));return[r.stack(u,a)]}));case"Unpack":{const a=wd("axis",t,e,n),s=wd("tensor",t,e,n);return r.unstack(s,a)}case"Tile":{const a=wd("reps",t,e,n);return[r.tile(wd("x",t,e,n),a)]}case"Split":case"SplitV":{const a=wd("axis",t,e,n),s=wd("numOrSizeSplits",t,e,n),o=wd("x",t,e,n);return r.split(o,s,a)}case"ScatterNd":{const a=wd("indices",t,e,n),s=wd("values",t,e,n),o=wd("shape",t,e,n);return[r.scatterND(a,s,o)]}case"GatherNd":{const a=wd("x",t,e,n),s=wd("indices",t,e,n);return[r.gatherND(a,s)]}case"SparseToDense":{const a=wd("sparseIndices",t,e,n),s=wd("outputShape",t,e,n),o=wd("sparseValues",t,e,n),i=wd("defaultValue",t,e,n);return[r.sparseToDense(a,o,s,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}case"TensorScatterUpdate":{const a=wd("indices",t,e,n),s=wd("values",t,e,n),o=wd("tensor",t,e,n);return[r.tensorScatterUpdate(o,a,s)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"sparse":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(wd("indices",t,e,n),wd("values",t,e,n),wd("denseShape",t,e,n),wd("defaultValue",t,e,n));return[a,s,o,i]}case"SparseReshape":{const{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(wd("inputIndices",t,e,n),wd("inputShape",t,e,n),wd("newShape",t,e,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(wd("data",t,e,n),wd("indices",t,e,n),wd("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(wd("data",t,e,n),wd("indices",t,e,n),wd("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"spectral":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"FFT":return[r.fft(wd("x",t,e,n))];case"IFFT":return[r.ifft(wd("x",t,e,n))];case"RFFT":return[r.rfft(wd("x",t,e,n))];case"IRFFT":return[r.irfft(wd("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"string":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(wd("input",t,e,n),wd("pattern",t,e,n),wd("rewrite",t,e,n),wd("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(wd("data",t,e,n),wd("dataSplits",t,e,n),wd("separator",t,e,n),wd("nGramWidths",t,e,n),wd("leftPad",t,e,n),wd("rightPad",t,e,n),wd("padWidth",t,e,n),wd("preserveShortSequences",t,e,n));return[a,s]}case"StringSplit":{const{indices:a,values:s,shape:o}=r.string.stringSplit(wd("input",t,e,n),wd("delimiter",t,e,n),wd("skipEmpty",t,e,n));return[a,s,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(wd("input",t,e,n),wd("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"transformation":return a((()=>((t,e,n,r=T)=>{switch(t.op){case"Cast":return[r.cast(wd("x",t,e,n),wd("dtype",t,e,n))];case"ExpandDims":{const a=wd("axis",t,e,n);return[r.expandDims(wd("x",t,e,n),a)]}case"Squeeze":{const a=wd("axis",t,e,n);return[r.squeeze(wd("x",t,e,n),a)]}case"Reshape":return[r.reshape(wd("x",t,e,n),wd("shape",t,e,n))];case"EnsureShape":return[r.ensureShape(wd("x",t,e,n),wd("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(wd("x",t,e,n),wd("padding",t,e,n),wd("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(wd("x",t,e,n),wd("padding",t,e,n),wd("constantValue",t,e,n))];case"SpaceToBatchND":{const a=wd("blockShape",t,e,n),s=wd("paddings",t,e,n);return[r.spaceToBatchND(wd("x",t,e,n),a,s)]}case"BatchToSpaceND":{const a=wd("blockShape",t,e,n),s=wd("crops",t,e,n);return[r.batchToSpaceND(wd("x",t,e,n),a,s)]}case"DepthToSpace":{const a=wd("blockSize",t,e,n),s=wd("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(wd("x",t,e,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(wd("x",t,e,n),wd("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(wd("s0",t,e,n),wd("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"hash_table":return(async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const a=r.getHashTableHandleByName(t.name);if(null!=a)return[a];{const a=wd("keyDType",t,e,n),s=wd("valueDType",t,e,n),o=new bp(a,s);return r.addHashTable(t.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const a=wd("tableHandle",t,e,n,r),s=wd("keys",t,e,n),o=wd("values",t,e,n),i=r.getHashTableById(a.id);return[await i.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const a=wd("tableHandle",t,e,n,r),s=wd("keys",t,e,n),o=wd("defaultValue",t,e,n),i=r.getHashTableById(a.id);return[await i.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=wd("tableHandle",t,e,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n,r);case"custom":const s=gd(t.op);if(s&&s.customExecutor)return s.customExecutor(new ip(t,e,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return q(s)?s.then((t=>[].concat(t))):[].concat(s)}class wp{constructor(t={},e={},n={},r={},a){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map((t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`)).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function _p(t,e,n,r){const a=new Set,s=[];let o=null,i=null;const u=new Set,l=new Set(Object.keys(t).map((t=>Nd(t)[0])));r=r||[];const c=new Set(r.map((t=>Nd(t.name)[0]))),d=[...e];for(;d.length>0;){const t=d.pop();(kp(t)||Cp(t)||Ap(t))&&null==o&&(o=t,i=o.children.map((t=>t.name)).filter((t=>a.has(t)))),a.add(t.name),null==n[t.name]&&(l.has(t.name)||c.has(t.name)||(0!==t.inputs.length?t.inputs.forEach((t=>{u.has(t.name)||(u.add(t.name),d.push(t))})):s.push(t.name)))}return{inputs:t,outputs:e,usedNodes:a,missingInputs:s,dynamicNode:o,syncInputs:i}}function vp(t,e){const{usedNodes:n,inputs:r}=e,a=Object.keys(r).map((t=>Nd(t)[0])).map((e=>t.nodes[e])),s=t.initNodes||[],o=t=>n.has("string"==typeof t?t:t.name);function i(t){return[...new Map(t.map((t=>[t.name,t]))).values()]}const u=i([...a,...t.weights,...s]).filter(o),l=i([...u,...Object.values(t.nodes)]).filter(o),c=new Map(l.map((t=>[t.name,t]))),d={};for(const t of l){d[t.name]=d[t.name]||0;for(const e of t.children)o(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}const p=Object.entries(d).filter((([,t])=>0===t)).map((([t])=>t)),m=[...p];for(;p.length>0;){const t=p.pop(),e=c.get(t);for(const t of e.children.filter(o))0==--d[t.name]&&(m.push(t.name),p.push(t.name))}const f=function(t,e){const n=new Map(t.map((t=>[t.name,t]))),r=e.map((t=>t.name)),a=new Set(r);for(;r.length>0;){const t=r.pop(),e=n.get(t);for(const t of e.children)n.has(t.name)&&!a.has(t.name)&&(a.add(t.name),r.push(t.name))}const s=t.filter((t=>a.has(t.name)));return s}(m.map((t=>c.get(t))),u);return function(t,e){const n=new Map(t.map(((t,e)=>[t.name,e]))),r=new Set(e.map((t=>t.name))),a=t=>r.has("string"==typeof t?t:t.name),s=new Set(t.map((t=>t.name))),o=t=>s.has("string"==typeof t?t:t.name);for(const e of t){for(const t of e.children.filter(o)){if(!n.has(t.name))throw new Tp(`Child ${t.name} of node ${e.name} is unreachable.`);if(n.get(e.name)>n.get(t.name))throw new Tp(`Node ${e.name} is scheduled to run after its child ${t.name}.`)}if(!a(e))for(const t of e.inputs){if(!n.has(t.name))throw new Tp(`Input ${t.name} of node ${e.name} is unreachable.`);if(n.get(t.name)>n.get(e.name))throw new Tp(`Node ${e.name} is scheduled to run before its input ${t.name}.`)}}}(f,u),f}class Tp extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}const Sp=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Np=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),xp=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function kp(t){return Sp.has(t.op)}function Cp(t){return Np.has(t.op)}function Ap(t){return xp.has(t.op)}class Dp{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map((e=>t[e].map((t=>t.id))));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((t=>t.signatureKey||t.name))}get outputNodes(){return this._outputs.map((t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e}))}get functions(){return Object.keys(this._functions).reduce(((t,e)=>(t[e]=this._functions[e].signature,t)),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((e=>{this._functionExecutorMap[e]=new Dp(t.functions[e],this)}))}getCompilationKey(t,e){const n=t.map((t=>t.name)).sort(),r=e.map((t=>t.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,e){const n=_p(t,e,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){const n=e.map((t=>t.name)),a=Object.keys(t);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}const o=vp(this.graph,n),i=function(t){const e=new Map(t.map(((t,e)=>[t.name,e]))),n=Number.MAX_SAFE_INTEGER,r=t.map(((t,e)=>kp(t)?n:e)),a=t=>{const n=r[e.get(t.name)];return null==n?-1:n},s=t.map(((t,e)=>t.children.map(a).reduce(((t,e)=>Math.max(t,e)),r[e]))),o=new Map;for(let e=0;e<t.length;++e){const r=s[e];if(r===n)continue;const a=t[e],i=t[r];o.has(i.name)||o.set(i.name,[]),o.get(i.name).push(a)}return o}(o);return{orderedNodes:o,nodeLiveUntilMap:i}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return Ya(e),e}cloneTensorList(t){if(!t)return null;const e=t.map((t=>this.cloneAndKeepTensor(t)));return e}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map((([t,e])=>[t,this.cloneTensorList(e)])))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const r=n.map((t=>this.graph.nodes[Nd(t)[0]])),a=e.map((t=>Nd(t)[0])),s=new Set(a);let o=a.map((t=>this.graph.nodes[t]));0===o.length&&(o=this._outputs);const i=this.getCompilationKey(r,o);let u=this.compiledMap.get(i);null==u&&(u=this.compile(t,o),this.compiledMap.set(i,u));try{this.keepIntermediateTensors=X().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(t){this.keepIntermediateTensors=!1,console.warn(t.message)}const l={},c={};return Ka((()=>{const n=new wp(this.weightMap,l,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach((e=>{const[a,s]=Nd(e,n),o=[];o[s]=t[e],r[a]=o,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(o))}));const a=this.getFrozenTensorIds(r),{orderedNodes:o,nodeLiveUntilMap:i}=u;for(const t of o){if(r[t.name])continue;const e=gp(t,r,n,this._resourceManager);if(q(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.keepIntermediateTensors&&(this.clonedTensorsMap[t.name]=this.cloneTensorList(e)),this.checkTensorForDisposalWithNodeLiveUntilInfo(t,r,n,a,s,i.get(t.name))}return null==this.parent&&n.dispose(a),e.map((t=>_d(t,r,n)))}))}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map((e=>t[e])).map((t=>t.map((t=>t.id)))));return new Set(e)}checkTensorForDisposal(t,e,n,r,a,s,o){if(!kp(e)&&!s.has(t)){for(const r of n[t])null!=r&&(o[r.id]=(o[r.id]||0)+e.children.length);for(const t of e.inputs){if(kp(t))continue;const e=vd(t.name,n,r);if(null!=e)for(const t of e){if(!t||t.kept||a.has(t.id))continue;const e=o[t.id];1===e?(t.dispose(),delete o[t.id]):null!=e&&o[t.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,n,r,a,s){function o(t){return kp(t)||a.has(t.name)}if(!kp(t)&&null!=s)for(const t of s){if(o(t))continue;const a=vd(t.name,e,n);for(const t of a)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,e,n=!1,r={},a={}){this.disposeIntermediateTensors(),n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=X().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(t){this.keepIntermediateTensors=!1,console.warn(t.message)}const s=new wp(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(t,s,e,n),i=e.map((t=>_d(t,o,s))),u=i.map((t=>t.id)),l=Object.keys(t).map((e=>t[e].id)),c=new Set([...u,...l,...this.weightIds]);return Object.values(o).forEach((t=>{t.forEach((t=>{!t||t.isDisposed||c.has(t.id)||t.dispose()}))})),null==this.parent&&s.dispose(c),i}async executeFunctionAsync(t,e,n){const r=t.reduce(((t,e,n)=>(t[this.inputs[n].name]=e,t)),{});return this._executeAsync(r,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,r){const a=Object.keys(t),s=a.map((t=>this.graph.nodes[Nd(t)[0]])),o=n.map((t=>Nd(t)[0])),i=new Set(o);let u=o.map((t=>this.graph.nodes[t]));0===u.length&&(u=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:d,syncInputs:p}=_p(t,u,this.weightMap,this._initNodes),m=[...s,...this.graph.weights,...this._initNodes||[]].map((t=>({node:t,contexts:e.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[n,r]=Nd(e),a=[];a[r]=t[e],f[n]=a}));const h={},y=this.getFrozenTensorIds(f),b={};for(;m.length>0;){const t=this.processStack(s,m,e,f,b,y,i,h,l);await Promise.all(t)}null!=d||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const g=u.filter((t=>!kp(t)&&!_d(t.name,f,e))).map((t=>t.name));if(g.length>0){let t="";throw null!=d&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${g}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${t}`)}return f}processStack(t,e,n,r,a,s,o,i,u){const l=[];for(;e.length>0;){const t=e.pop();n.currentContext=t.contexts;let c="";if("Enter"===t.node.op&&wd("isConstant",t.node,r,n)&&([c]=Td(t.node.name,n)),null==r[t.node.name]){const d=gp(t.node,r,n,this._resourceManager);c||([c]=Td(t.node.name,n));const p=n.currentContext;q(d)?l.push(d.then((l=>(r[c]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(l)),n.currentContext=p,this.checkTensorForDisposal(c,t.node,r,n,s,o,i),this.processChildNodes(t.node,e,n,r,a,u),l)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,t.node,r,n,s,o,i),this.processChildNodes(t.node,e,n,r,a,u))}else this.processChildNodes(t.node,e,n,r,a,u)}return l}processChildNodes(t,e,n,r,a,s){t.children.forEach((t=>{const[o]=Td(t.name,n);!a[o]&&s.has(t.name)&&("Merge"===t.op?t.inputNames.some((t=>!!_d(t,r,n)))&&(a[o]=!0,e.push({contexts:n.currentContext,node:t})):t.inputNames.every((t=>!!_d(t,r,n)))&&(a[o]=!0,e.push({contexts:n.currentContext,node:t})))}))}dispose(){Object.keys(this.weightMap).forEach((t=>this.weightMap[t].forEach((t=>t.dispose()))))}checkInputShapeAndType(t){Object.keys(t).forEach((e=>{const n=t[e],[r]=Nd(e),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const t=a.attrParams.shape.value;k(t.length===n.shape.length&&n.shape.every(((e,n)=>-1===t[n]||t[n]===e)),(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${t}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&k(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(t){var e,n;const r={};for(const a in t){const s=null===(n=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===n?void 0:n[a];null!=s?r[s.name]=t[a]:r[a]=t[a]}return r}checkInputs(t){const e=Object.keys(t).filter((t=>{const[e]=Nd(t);return null==this.graph.nodes[e]}));if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map((t=>{var e,n;const r=null===(n=null===(e=this._signature)||void 0===e?void 0:e.outputs)||void 0===n?void 0:n[t];return null!=r?r.name:t}),{})}checkOutputs(t){t.forEach((t=>{const[e]=Nd(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)}))}}class Ep{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class Pp{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},r=t){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,null==n&&(this.loadOptions={}),this.resourceManager=new Ep}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return q(t)?t.then((t=>this.loadSync(t))):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const t=this.artifacts.userDefinedMetadata;null!=t.signature&&(n=t.signature),null!=t.structuredOutputKeys&&(this.structuredOutputKeys=t.structuredOutputKeys)}this.signature=n,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Dp(Hd.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const e=Hd.Instance.transformGraph(t.modelInitializer);this.initializer=new Dp(e),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,e){if("string"==typeof t){const e=this.io.getSaveHandlers(t);if(0===e.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Error(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const e={};return(t instanceof br?[t]:t).forEach(((t,n)=>e[this.structuredOutputKeys[n]]=t)),e}return t}predict(t,e){const n=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(t,e){const n=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(t){var e;if(!(t instanceof br||Array.isArray(t))){const n=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=n)for(const e in n){const r=n[e];null!=r.resourceId&&(t[e]=this.resourceIdToCapturedInput[r.resourceId])}return t}t=Array.isArray(t)?t:[t];const n=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${t.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((e,n)=>{var a,s,o;const i=null===(o=null===(s=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===s?void 0:s[n])||void 0===o?void 0:o.resourceId;return e[n]=null!=i?this.resourceIdToCapturedInput[i]:t[r++],e}),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,n=Object.keys(e);for(let r=0;r<n.length;r++){const a=e[n[r]];this.resourceIdToCapturedInput[a.resourceId]=t[r]}}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce(((e,n)=>(e[n]=[t[n]],e)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Za(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}var Fp,$p;let Op;!function(t){t[t.float32=0]="float32",t[t.int32=1]="int32",t[t.bool=2]="bool",t[t.string=3]="string",t[t.complex64=4]="complex64"}(Fp||(Fp={})),function(t){t[t.linear=0]="linear",t[t.relu=1]="relu",t[t.relu6=2]="relu6",t[t.prelu=3]="prelu",t[t.leakyrelu=4]="leakyrelu",t[t.sigmoid=5]="sigmoid",t[t.elu=6]="elu"}($p||($p={}));const Rp={kernelName:Cn,backendName:"wasm",setupFunc:function(t){Op=t.wasm.cwrap(Cn,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a,b:s,bias:o,preluActivationWeights:i}=e;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r,p=n.dataIdMap.get(a.dataId).id,m=n.dataIdMap.get(s.dataId).id;let f=0;if(null!=o){const t=n.dataIdMap.get(o.dataId);if(1!==t.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${t.shape.length}.`);f=t.id}const h=null==i?0:n.dataIdMap.get(i.dataId).id,y=$p[c];if(null==y)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);const b=u?a.shape[2]:a.shape[1],g=l?s.shape[1]:s.shape[2],w=bs(a.shape.slice(0,-2),s.shape.slice(0,-2)),_=n.makeOutput([...w,b,g],a.dtype),v=n.dataIdMap.get(_.dataId).id,T=new Uint8Array(new Int32Array(a.shape).buffer),S=new Uint8Array(new Int32Array(s.shape).buffer);return Op(p,T,a.shape.length,m,S,s.shape.length,u,l,y,f,h,d||0,v),_}};function Ip(t,e){let n;return{kernelName:t,backendName:"wasm",setupFunc:function(e){n=e.wasm.cwrap(t,null,["number","number","number"])},kernelFunc:function(t){const{backend:r,inputs:{x:a}}=t,s=r.dataIdMap.get(a.dataId).id,o=r.makeOutput(a.shape,e||a.dtype),i=r.dataIdMap.get(o.dataId).id;return 0===D(o.shape)||n(s,Fp[a.dtype],i),o}}}const Mp=Ip("Abs"),Lp=Ip(tt),zp=Ip(et);function Vp(t,e,n){let r;return{kernelName:t,backendName:"wasm",setupFunc:function(e){r=e.wasm.cwrap(t,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:a}=t,{a:s,b:o}=a,i=e.dataIdMap.get(s.dataId).id,u=e.dataIdMap.get(o.dataId).id,l=null!=n?n:s.dtype,c=bs(s.shape,o.shape),d=e.makeOutput(c,l);if(0===D(c))return d;const p=new Uint8Array(new Int32Array(s.shape).buffer),m=new Uint8Array(new Int32Array(o.shape).buffer),f=e.dataIdMap.get(d.dataId).id;return r(i,p,s.shape.length,u,m,o.shape.length,Fp[s.dtype],f),d}}}const Bp=Vp(nt);let Up;const Wp={kernelName:rt,backendName:"wasm",setupFunc:function(t){Up=t.wasm.cwrap(rt,null,["array","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n}=t,r=n.makeOutput(e[0].shape,e[0].dtype);if(0===D(r.shape))return r;const a=e.map((t=>n.dataIdMap.get(t.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),o=n.dataIdMap.get(r.dataId).id;return Up(s,a.length,Fp[r.dtype],o),r}};function jp(t){const{inputs:{x:e},backend:n}=t;if("string"===e.dtype)return Gr(n.readSync(e.dataId),e.shape,e.dtype);const r=n.makeOutput(e.shape,e.dtype),a=n.typedArrayFromHeap(e);return n.typedArrayFromHeap(r).set(a),r}const qp={kernelName:Yt,backendName:"wasm",kernelFunc:jp};let Hp;function Gp(t){const{inputs:e,backend:n,attrs:r}=t,[a,s]=function(t,e){const n=[],r=[];for(let a=0;a<t.length;++a)1!==t[a]&&n.push(t[a]),1!==t[e[a]]&&r.push(e[a]);for(let t=0;t<r.length;++t){let e=-1;for(let n=0;n<r.length;++n)r[n]>=t&&(-1===e||r[e]>r[n])&&(e=n);r[e]=t}return[n,r]}(e.x.shape,r.perm);let o=!0;for(let t=0;t<s.length;t++)s[t]!==t&&(o=!1);const i=function(t,e){const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];return n}(e.x.shape,r.perm),u={dataId:e.x.dataId,shape:a,dtype:e.x.dtype};if(o){const t=jp({inputs:e,backend:n});return t.shape=i,t}const l=n.makeOutput(i,u.dtype),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(l.dataId).id,p=new Uint8Array(new Int32Array(s).buffer),m=new Uint8Array(new Int32Array(u.shape).buffer);return Hp(c,m,u.shape.length,Fp[u.dtype],d,p,s.length),l}const Qp={kernelName:_n,backendName:"wasm",kernelFunc:Gp,setupFunc:function(t){Hp=t.wasm.cwrap(_n,null,["number","array","number","number","number","array","number"])}};function Xp(t,e,n){const r=t.shape,a=t.shape.length,s=$(e,r);let o=s;const i=xi(o,a);let u=null,l=!1;if(null!=i){const e=new Array(a);for(let t=0;t<e.length;t++)e[t]=r[i[t]];o=Ci(o.length,a),u=Gp({inputs:{x:t},attrs:{perm:i},backend:n});const s=n.dataIdMap.get(t.dataId).id;n.dataIdMap.get(u.dataId).id!==s&&(l=!0)}return{transposed:u,originalAxes:s,axes:o,inputWasTransposed:l}}let Jp;const Kp={kernelName:at,backendName:"wasm",setupFunc:function(t){Jp=t.wasm.cwrap(at,null,["number, number, number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{axis:a,keepDims:s}=r,{x:o}=n;let i=e.dataIdMap.get(o.dataId).id,u=o;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:p}=Xp(o,a,e);if(p){u=l,i=e.dataIdMap.get(l.dataId).id}Ni("all",c,u.shape.length);const[m,f]=Ti(u.shape,c),h=D(f),y=e.makeOutput(m,o.dtype);if(0!==D(u.shape)){const t=e.dataIdMap.get(y.dataId).id;Jp(i,h,t)}if(p&&e.disposeData(l.dataId),s){const t=Si(y.shape,d);y.shape=t}return y}};let Zp;const Yp={kernelName:st,backendName:"wasm",setupFunc:function(t){Zp=t.wasm.cwrap(st,null,["number, number, number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{axis:a,keepDims:s}=r,{x:o}=n;let i=e.dataIdMap.get(o.dataId).id,u=o;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:p}=Xp(o,a,e);if(p){u=l,i=e.dataIdMap.get(l.dataId).id}Ni("any",c,u.shape.length);const[m,f]=Ti(u.shape,c),h=D(f),y=e.makeOutput(m,o.dtype);if(0!==D(u.shape)){const t=e.dataIdMap.get(y.dataId).id;Zp(i,h,t)}if(p&&e.disposeData(l.dataId),s){const t=Si(y.shape,d);y.shape=t}return y}};function tm(t){let e;return{kernelName:t,backendName:"wasm",setupFunc:function(n){e=n.wasm.cwrap(t,null,["number","number","number","number","number"])},kernelFunc:function(t){const{backend:n,inputs:r,attrs:a}=t,{axis:s}=a,{x:o}=r,i=n.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:d,inputWasTransposed:p}=Xp(o,s,n);if(p){const t=n.dataIdMap.get(c.dataId).id;t!==i&&(l=c,u=t)}const m=l.shape.slice(0,-1),f=n.makeOutput(m,"int32"),h=n.dataIdMap.get(f.dataId).id,y=D(f.shape),b=l.shape[d[0]];return e(u,Fp[l.dtype],y,b,h),p&&n.disposeData(c.dataId),f}}}const em=tm(ot),nm=tm(it),rm=Ip(ut),am=Ip(lt),sm=Ip(ct),om=Vp(pt),im=Ip(dt);let um;const lm={kernelName:mt,backendName:"wasm",setupFunc:function(t){um=t.wasm.cwrap(mt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,a=e.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=n,c=mo(a.shape,o,i,1,u,l),d=c.filterHeight,p=c.filterWidth,m=c.padInfo.top,f=c.padInfo.right,h=c.padInfo.bottom,y=c.padInfo.left,b=c.strideHeight,g=c.strideWidth,w=c.inChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(1!==c.dilationWidth||1!==c.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);const _=r.makeOutput(c.outShape,"float32"),v=r.dataIdMap.get(_.dataId).id;return um(s,a.shape[0],a.shape[1],a.shape[2],d,p,m,f,h,y,b,g,w,v),_}};let cm;const dm={kernelName:ft,backendName:"wasm",setupFunc:function(t){cm=t.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r,c=fo(a.shape,s,o,1,i,u,l),d=n.makeOutput(c.outShape,a.dtype);return cm(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};let pm;const mm={kernelName:"AvgPool3DGrad",backendName:"wasm",setupFunc:function(t){pm=t.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=r,c=fo(s.shape,o,i,1,u,l),d=n.makeOutput(s.shape,s.dtype);return pm(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),d}};function fm(t){const{inputs:e,attrs:n}=t,{x:r}=e,{shape:a}=n,s=D(r.shape),o=function(t,e){let n=1,r=-1;for(let e=0;e<t.length;++e)if(t[e]>=0)n*=t[e];else if(-1===t[e]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${e}`);r=e}else if(t[e]<0)throw Error(`Shapes can not be < 0. Found ${t[e]} at dim ${e}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const a=t.slice();return a[r]=e/n,a}(a,s);return k(s===D(o),(()=>`new shape: ${o}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),t.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}const hm={kernelName:Ie,backendName:"wasm",kernelFunc:fm};let ym;const bm={kernelName:ht,backendName:"wasm",setupFunc:function(t){ym=t.wasm.cwrap(ht,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a,b:s}=e,{transposeA:o,transposeB:i}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const u=a.shape.length,l=s.shape.length,c=o?a.shape[u-2]:a.shape[u-1],d=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-1]:a.shape[u-2],m=i?s.shape[l-2]:s.shape[l-1],f=a.shape.slice(0,-2),h=s.shape.slice(0,-2),y=D(f),b=D(h),g=bs(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([p,m]);k(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`));const w=i?[b,m,d]:[b,d,m],_=fm({inputs:{x:a},backend:n,attrs:{shape:o?[y,c,p]:[y,p,c]}}),v=fm({inputs:{x:s},backend:n,attrs:{shape:w}}),T=n.dataIdMap.get(_.dataId).id,S=n.dataIdMap.get(v.dataId).id,N=o?_.shape[2]:_.shape[1],x=i?v.shape[1]:v.shape[2],C=Math.max(y,b),A=n.makeOutput([C,N,x],_.dtype),E=n.dataIdMap.get(A.dataId).id,P=new Uint8Array(new Int32Array(_.shape).buffer),F=new Uint8Array(new Int32Array(v.shape).buffer);return ym(T,P,_.shape.length,S,F,v.shape.length,o,i,E),n.disposeData(_.dataId),n.disposeData(v.dataId),A.shape=g,A}};function gm(t,e,n,r,a){const s=Qs(r,e,n),o=D(n),i=z(r);if(s){const n=Xs(e,i);return"string"===a?t.slice(n,n+o):t.subarray(n,n+o)}const u=Ga(r,a,"string"===a?md(t):t),l=Ga(n,a);for(let t=0;t<l.size;++t){const n=l.indexToLoc(t),r=n.map(((t,n)=>t+e[n]));l.set(u.get(...r),...n)}return"string"===a?fd(l.values):l.values}function wm(t){const{inputs:{x:e},attrs:{begin:n,size:r},backend:a}=t,[s,o]=Js(e,n,r),i=Qs(e.shape,s,o),u=a.readSync(e.dataId),l=a.makeOutput(o,e.dtype),c=z(e.shape),d=a.dataIdMap.get(l.dataId);if(i){const t=Xs(s,c);if("string"===e.dtype)d.stringBytes=u.slice(t,t+D(o));else{a.typedArrayFromHeap(l).set(u.subarray(t,t+D(o)))}return l}if("string"===e.dtype){const t=gm(u,s,o,e.shape,e.dtype);return d.stringBytes=t,l}const p=a.typedArrayFromHeap(l),m=e.shape.length;if(2===m)!function(t,e,n,r,a){let s=0;const o=r[0],i=r[1],u=o+a[0];for(let r=o;r<u;r++){const o=r*e+i;n.set(t.subarray(o,o+a[1]),s),s+=a[1]}}(u,c[0],p,s,o);else if(3===m)!function(t,e,n,r,a,s){let o=0;const i=a[0],u=a[1],l=a[2],c=i+s[0],d=u+s[1];for(let a=i;a<c;a++)for(let i=u;i<d;i++){const u=a*e+i*n+l;r.set(t.subarray(u,u+s[2]),o),o+=s[2]}}(u,c[0],c[1],p,s,o);else if(4===m)!function(t,e,n,r,a,s,o){let i=0;const u=s[0],l=s[1],c=s[2],d=u+o[0],p=l+o[1],m=c+o[2],f=s[3];for(let s=u;s<d;s++)for(let u=l;u<p;u++)for(let l=c;l<m;l++){const c=s*e+u*n+l*r+f;a.set(t.subarray(c,c+o[3]),i),i+=o[3]}}(u,c[0],c[1],c[2],p,s,o);else{const t=gm(u,s,o,e.shape,e.dtype);p.set(t)}return l}const _m={kernelName:Je,backendName:"wasm",kernelFunc:wm};const vm={kernelName:yt,backendName:"wasm",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,crops:o}=r,i=s.reduce(((t,e)=>t*e)),u=cd(a.shape,s,i),l=dd(u.length,s.length),c=pd(a.shape,s,i),d=function(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}(o,s.length),p=function(t,e,n){const r=t.slice(0,1);for(let a=0;a<n;++a)r.push(t[a+1]-e[a][0]-e[a][1]);return r}(c,o,s.length),m=fm({inputs:{x:a},backend:n,attrs:{shape:u}}),f=Gp({inputs:{x:m},backend:n,attrs:{perm:l}}),h=wm({inputs:{x:fm({inputs:{x:f},backend:n,attrs:{shape:c}})},backend:n,attrs:{begin:d,size:p}});return n.disposeData(m.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),h}};let Tm;const Sm={kernelName:bt,backendName:"wasm",setupFunc:function(t){Tm=t.wasm.cwrap(bt,null,["number","number","boolean","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{x:a,weights:s}=n,{size:o}=r,i=0!==s.shape.reduce(((t,e)=>t*e),1),u=1===a.shape.length?[o]:[a.shape[0],o],l=e.makeOutput(u,s.dtype);function c(t){return e.dataIdMap.get(t.dataId).id}return Tm(c(a),o,i,c(s),Fp[s.dtype],c(l)),l}};const Nm={kernelName:gt,backendName:"wasm",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:a}=e,s=n.typedArrayFromHeap(r),o=n.typedArrayFromHeap(a),i=bs(Array.from(s),Array.from(o));return n.makeOutput([i.length],"int32",void 0,new Int32Array(i))}};function xm(t){const{inputs:{x:e},attrs:{dtype:n},backend:r}=t,a=r.makeOutput(e.shape,n),s=r.typedArrayFromHeap(e);return r.typedArrayFromHeap(a).set(s),a}const km={kernelName:wt,backendName:"wasm",kernelFunc:xm},Cm=Ip(_t);let Am;const Dm={kernelName:vt,backendName:"wasm",setupFunc:function(t){Am=t.wasm.cwrap(vt,null,["number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{clipValueMin:s,clipValueMax:o}=r,i=n.dataIdMap.get(a.dataId).id,u=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(u.dataId).id;return Am(i,s,o,l),u}};function Em(t){const{inputs:e,backend:n}=t,r=$(t.attrs.axis,e[0].shape)[0];!function(t,e){const n=t[0].length;t.forEach(((t,e)=>{k(t.length===n,(()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`))})),k(e>=0&&e<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=t[0];t.forEach(((t,a)=>{for(let s=0;s<n;s++)k(s===e||t[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${t}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}(e.map((t=>t.shape)),r);let a=ud(e.map((t=>t.shape)),r);const s=e.filter((t=>D(t.shape)>0));if(1===s.length)return jp({inputs:{x:s[0]},backend:n});const o=n.makeOutput(a,e[0].dtype);if(0===D(a))return o;if("string"===s[0].dtype){const t=s.map((t=>{const e=D(t.shape.slice(r));return fm({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})})),i=t.map((t=>({vals:n.readSync(t.dataId),shape:t.shape})));a=ud(t.map((t=>t.shape)),1);const u=1===t[0].shape[0],l=function(t,e,n,r){const a=O(n,D(e));if(r&&"string"!==n){let e=0;t.forEach((t=>{const n=D(t.shape);a.set(t.vals,e),e+=n}))}else{let r=0;t.forEach((t=>{const s="string"===n?md(t.vals):t.vals;let o=0;for(let n=0;n<t.shape[0];++n){const i=n*e[1]+r;for(let e=0;e<t.shape[1];++e)a[i+e]=s[o++]}r+=t.shape[1]}))}return a}(i,a,e[0].dtype,u),c=ud(s.map((t=>t.shape)),r);o.shape=c;return n.dataIdMap.get(o.dataId).stringBytes=fd(l),t.forEach((t=>n.disposeData(t.dataId))),o}const i=D(s[0].shape.slice(0,r));let u=0;const l=s.map((t=>{const e=D(t.shape.slice(r));return u+=e,e})),c=s.map((t=>n.typedArrayFromHeap(t))),d=n.typedArrayFromHeap(o);for(let t=0;t<i;t++){let e=t*u;for(let n=0;n<c.length;n++){const r=l[n],a=t*r,s=c[n].subarray(a,a+r);d.set(s,e),e+=r}}return o}const Pm={kernelName:Tt,backendName:"wasm",kernelFunc:Em};let Fm;const $m={kernelName:St,backendName:"wasm",setupFunc:function(t){Fm=t.wasm.cwrap(St,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{x:a,filter:s}=e,o=r.dataIdMap.get(a.dataId).id,i=r.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:d,dataFormat:p}=n,m=xo(p),f=ho(a.shape,s.shape,u,l,c,d,!1,m),h=f.filterHeight,y=f.filterWidth,b=f.padInfo.top,g=f.padInfo.right,w=f.padInfo.bottom,_=f.padInfo.left,v=f.dilationHeight,T=f.dilationWidth,S=f.strideHeight,N=f.strideWidth,x=f.inChannels,k=f.outChannels,C="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);const A=r.makeOutput(f.outShape,"float32"),D=r.dataIdMap.get(A.dataId).id;return Fm(o,a.shape[0],a.shape[1],a.shape[2],i,h,y,b,g,w,_,C,v,T,S,N,x,k,D),A}};let Om;const Rm={kernelName:Nt,backendName:"wasm",setupFunc:function(t){Om=t.wasm.cwrap(Nt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{dy:a,filter:s}=n,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,inputShape:c}=r,d=xo(u),p=ho(c,s.shape,o,1,i,l,!1,d),{batchSize:m,filterHeight:f,filterWidth:h,inChannels:y,inHeight:b,inWidth:g,outChannels:w,outHeight:_,outWidth:v,strideHeight:T,strideWidth:S}=p,N=f-1-p.padInfo.top,x=h-1-p.padInfo.left,k="channelsLast"===p.dataFormat,C=z(p.inShape),A=z(a.shape),[D,E,P]=z(s.shape),F=C[0],$=k?C[1]:C[2],O=k?C[2]:1,R=k?1:C[1],I=A[0],M=k?A[1]:A[2],L=k?A[2]:1,V=k?1:A[1],B=e.makeOutput(p.inShape,"float32"),U=e.dataIdMap.get(B.dataId).id,W=e.dataIdMap.get(a.dataId).id,j=e.dataIdMap.get(s.dataId).id;return Om(W,j,m,f,h,b,g,y,_,v,w,T,S,N,x,D,E,P,F,$,O,R,I,M,L,V,U),B}};let Im;const Mm={kernelName:xt,backendName:"wasm",setupFunc:function(t){Im=t.wasm.cwrap(xt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:u}=r;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);const l=yo(a.shape,s.shape,o,u,i),c=n.makeOutput(l.outShape,a.dtype);return Im(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,l.batchSize,l.inDepth,l.inHeight,l.inWidth,l.inChannels,l.outDepth,l.outHeight,l.outWidth,l.outChannels,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.filterDepth,l.filterHeight,l.filterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),c}};let Lm;const zm={kernelName:kt,backendName:"wasm",setupFunc:function(t){Lm=t.wasm.cwrap(kt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,filterShape:u}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);const l=yo(a.shape,u,o,1,i),c=n.makeOutput(l.filterShape,s.dtype);return Lm(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,l.batchSize,l.inDepth,l.inHeight,l.inWidth,l.inChannels,l.outDepth,l.outHeight,l.outWidth,l.outChannels,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.filterDepth,l.filterHeight,l.filterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),c}};let Vm;const Bm={kernelName:Ct,backendName:"wasm",setupFunc:function(t){Vm=t.wasm.cwrap(Ct,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{pad:o,strides:i,inputShape:u}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);const l=yo(u,s.shape,i,1,o),c=n.makeOutput(l.inShape,a.dtype);return Vm(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,l.batchSize,l.inDepth,l.inHeight,l.inWidth,l.inChannels,l.outDepth,l.outHeight,l.outWidth,l.outChannels,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.filterDepth,l.filterHeight,l.filterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),c}},Um=Ip("Cos"),Wm=Ip(At);var jm;let qm;!function(t){t[t.bilinear=0]="bilinear",t[t.nearest=1]="nearest"}(jm||(jm={}));const Hm={kernelName:Pt,backendName:"wasm",setupFunc:function(t){qm=t.wasm.cwrap(Pt,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{method:a,extrapolationValue:s,cropSize:o}=r,{image:i,boxes:u,boxInd:l}=n,c=u.shape[0],[d,p]=o,m=[c,d,p,i.shape[3]];let f,h=e.dataIdMap.get(i.dataId);"float32"!==i.dtype&&(f=xm({backend:e,inputs:{x:i},attrs:{dtype:"float32"}}),h=e.dataIdMap.get(f.dataId));const y=h.id,b=e.dataIdMap.get(u.dataId).id,g=e.dataIdMap.get(l.dataId).id,w=e.makeOutput(m,"float32"),_=e.dataIdMap.get(w.dataId).id,v=new Uint8Array(new Int32Array(i.shape).buffer);return qm(y,b,g,c,v,d,p,jm[a],s,_),null!=f&&e.disposeData(f.dataId),w}};let Gm;const Qm={kernelName:Dt,backendName:"wasm",setupFunc:function(t){Gm=t.wasm.cwrap(Dt,null,["number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r,u=a.shape.length;k("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));const l=xi([s],u);let c=a;null!==l&&(c=Gp({inputs:{x:a},attrs:{perm:l},backend:n}));const d=Ci(1,u)[0];Ni("cumprod",[d],u);const p=n.makeOutput(c.shape,c.dtype),m=c.shape[d],f=n.dataIdMap.get(c.dataId).id,h=n.dataIdMap.get(p.dataId).id;Gm(f,o?1:0,i?1:0,m,h,Fp[a.dtype]);let y=p;if(null!==l){y=Gp({inputs:{x:p},attrs:{perm:ki(l)},backend:n}),n.disposeData(c.dataId),n.disposeData(p.dataId)}return y}};let Xm;const Jm={kernelName:Et,backendName:"wasm",setupFunc:function(t){Xm=t.wasm.cwrap(Et,null,["number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r,u=a.shape.length;k("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));const l=xi([s],u);let c=a;null!==l&&(c=Gp({inputs:{x:a},attrs:{perm:l},backend:n}));const d=Ci(1,u)[0];Ni("cumsum",[d],u);const p=n.makeOutput(c.shape,c.dtype),m=c.shape[d],f=n.dataIdMap.get(c.dataId).id,h=n.dataIdMap.get(p.dataId).id;Xm(f,o?1:0,i?1:0,m,h,Fp[a.dtype]);let y=p;if(null!==l){y=Gp({inputs:{x:p},attrs:{perm:ki(l)},backend:n}),n.disposeData(c.dataId),n.disposeData(p.dataId)}return y}};let Km;const Zm={kernelName:Ft,backendName:"wasm",setupFunc:function(t){Km=t.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{x:a,weights:s}=n,{size:o,binaryOutput:i}=r,u=0!==s.shape.reduce(((t,e)=>t*e),1),l=1===a.shape.length?[o]:[a.shape[0],o],c=e.makeOutput(l,s.dtype);function d(t){return e.dataIdMap.get(t.dataId).id}return Km(d(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,o,u,d(s),Fp[s.dtype],i,d(c)),c}};let Ym;const tf={kernelName:$t,backendName:"wasm",setupFunc:function(t){Ym=t.wasm.cwrap($t,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{x:a}=n,{blockSize:s,dataFormat:o}=r,i=a.shape[0],u=("NHWC"===o?a.shape[1]:a.shape[2])*s,l=("NHWC"===o?a.shape[2]:a.shape[3])*s,c=("NHWC"===o?a.shape[3]:a.shape[1])/(s*s),d="NHWC"===o?[i,u,l,c]:[i,c,u,l],p=e.makeOutput(d,"float32"),m=e.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(z(a.shape)).buffer),h=new Uint8Array(new Int32Array(d).buffer),y=new Uint8Array(new Int32Array(z(d)).buffer),b=e.dataIdMap.get(p.dataId).id;return Ym(m,s,"NHWC"===o?1:0,f,a.shape.length-1,h,y,d.length,b),p}};let ef;const nf={kernelName:Ot,backendName:"wasm",setupFunc:function(t){ef=t.wasm.cwrap(Ot,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{x:a,filter:s}=e,o=r.dataIdMap.get(a.dataId).id,i=r.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:d}=n,p=null==l?[1,1]:l,m=ho(a.shape,s.shape,u,p,c,d,!0),f=m.filterHeight,h=m.filterWidth,y=m.padInfo.top,b=m.padInfo.right,g=m.padInfo.bottom,w=m.padInfo.left,_=m.dilationHeight,v=m.dilationWidth,T=m.strideHeight,S=m.strideWidth,N=m.inChannels,x=m.outChannels,k="SAME"===m.padInfo.type?1:0;if("channelsLast"!==m.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${m.dataFormat}'. Please use 'channelsLast'.`);const C=r.makeOutput(m.outShape,"float32"),A=r.dataIdMap.get(C.dataId).id;return ef(o,a.shape[0],a.shape[1],a.shape[2],i,f,h,y,b,g,w,k,_,v,T,S,N,x,A),C}};let rf;const af={kernelName:Rt,backendName:"wasm",setupFunc:function(t){rf=t.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=D(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return rf(n.dataIdMap.get(r.dataId).id,Fp[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}};let sf;const of={kernelName:It,backendName:"wasm",setupFunc:function(t){sf=t.wasm.cwrap(It,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:u}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);const l=po(a.shape,s.shape,o,i,"NHWC",u),c=n.makeOutput(l.outShape,a.dtype);return sf(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,Fp[a.dtype],l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.filterHeight,l.filterWidth,l.padInfo.top,l.padInfo.left),c}};let uf;const lf={kernelName:Lt,backendName:"wasm",setupFunc:function(t){uf=t.wasm.cwrap(Lt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,dy:o}=e,{strides:i,pad:u,dilations:l}=r;if(a.dtype!==s.dtype||a.dtype!==o.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${o.dtype}`);const c=po(a.shape,s.shape,i,u,"NHWC",l),d=n.makeOutput(s.shape,s.dtype);return uf(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(d.dataId).id,Fp[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}};let cf;const df={kernelName:Mt,backendName:"wasm",setupFunc:function(t){cf=t.wasm.cwrap(Mt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,dy:o}=e,{strides:i,pad:u,dilations:l}=r;if(a.dtype!==s.dtype||a.dtype!==o.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${o.dtype}`);const c=po(a.shape,s.shape,i,u,"NHWC",l),d=n.makeOutput(a.shape,a.dtype);return cf(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(d.dataId).id,Fp[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}},pf=Ip("Elu");let mf;const ff={kernelName:Vt,backendName:"wasm",setupFunc:function(t){mf=t.wasm.cwrap(Vt,null,["number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:r,y:a}=e,s=n.makeOutput(a.shape,"float32"),o=t=>n.dataIdMap.get(t.dataId).id;return mf(o(a),o(r),o(s)),s}},hf=Vp(Bt,0,"bool"),yf=Ip("Exp","float32");function bf(t){const{inputs:e,attrs:n,backend:r}=t,{input:a}=e,{dim:s}=n,o=a.shape.length,i=a.shape.slice();let u=s;return s<0&&(k(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),u=o+s+1),i.splice(u,0,1),fm({inputs:{x:a},backend:r,attrs:{shape:i}})}const gf={kernelName:Ut,backendName:"wasm",kernelFunc:bf},wf=Ip(Wt,"float32");function _f(t){const{attrs:{shape:e,value:n,dtype:r},backend:a}=t,s=a.makeOutput(e,r);return a.typedArrayFromHeap(s).fill(n),s}const vf={kernelName:jt,backendName:"wasm",kernelFunc:_f};let Tf;const Sf={kernelName:qt,backendName:"wasm",kernelFunc:function(t){const{inputs:e,backend:n}=t,{image:r}=e,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,[i,u,l,c]=r.shape;return Tf(s,i,u,l,c,o),a},setupFunc:function(t){Tf=t.wasm.cwrap(qt,null,["number","number","number","number","number","number"])}},Nf=Ip(Ht),xf=Vp(Gt);let kf;const Cf={kernelName:Qt,backendName:"wasm",setupFunc:function(t){kf=t.wasm.cwrap(Qt,null,["number","number","number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{varianceEpsilon:a}=r,{x:s,mean:o,variance:i,offset:u,scale:l}=n,c=e.dataIdMap.get(s.dataId).id,d=e.dataIdMap.get(o.dataId).id,p=e.dataIdMap.get(i.dataId).id,m=null!=u?e.dataIdMap.get(u.dataId).id:0,f=null!=l?e.dataIdMap.get(l.dataId).id:0,h=e.makeOutput(s.shape,s.dtype);if(0===D(s.shape))return h;const y=e.dataIdMap.get(h.dataId).id;return kf(c,d,p,m,f,a,y),h}};let Af;const Df={kernelName:An,backendName:"wasm",setupFunc:function(t){Af=t.wasm.cwrap(An,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:c,dataFormat:d,dimRoundingMode:p,activation:m,leakyreluAlpha:f}=n,h=ho(a.shape,s.shape,u,c,l,p),y=$p[m];if(null==y)throw new Error(`${m} activation not yet supported for FusedConv2D in the wasm backend.`);const b=r.dataIdMap.get(a.dataId).id,g=r.dataIdMap.get(s.dataId).id,w=h.outChannels;let _=0;if(null!=o){const t=r.dataIdMap.get(o.dataId);if(1!==t.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${t.shape.length}.`);if(t.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${t.shape}) does not match the number of output channels (${w})`);_=t.id}const v=h.filterHeight,T=h.filterWidth,S=h.padInfo.top,N=h.padInfo.right,x=h.padInfo.bottom,k=h.padInfo.left,C=h.dilationHeight,A=h.dilationWidth,D=h.strideHeight,E=h.strideWidth,P=h.inChannels,F="SAME"===h.padInfo.type?1:0,$=h.batchSize,O=h.inHeight,R=h.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const I=r.makeOutput(h.outShape,"float32"),M=r.dataIdMap.get(I.dataId).id,L=null==i?0:r.dataIdMap.get(i.dataId).id;return Af(b,$,O,R,g,v,T,_,S,N,x,k,F,C,A,D,E,P,w,y,L,f||0,M),I}};let Ef;const Pf={kernelName:Dn,backendName:"wasm",setupFunc:function(t){Ef=t.wasm.cwrap(Dn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:c,dataFormat:d,dimRoundingMode:p,activation:m,leakyreluAlpha:f}=n,h=ho(a.shape,s.shape,u,c,l,p,!0),y=$p[m];if(null==y)throw new Error(`${m} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const b=r.dataIdMap.get(a.dataId).id,g=r.dataIdMap.get(s.dataId).id,w=h.outChannels;let _=0;if(null!=o){const t=r.dataIdMap.get(o.dataId);if(1!==t.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${t.shape.length}.`);if(t.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${t.shape}) does not match the number of output channels (${w})`);_=t.id}const v=h.filterHeight,T=h.filterWidth,S=h.padInfo.top,N=h.padInfo.right,x=h.padInfo.bottom,k=h.padInfo.left,C=h.dilationHeight,A=h.dilationWidth,D=h.strideHeight,E=h.strideWidth,P=h.inChannels,F="SAME"===h.padInfo.type?1:0,$=h.batchSize,O=h.inHeight,R=h.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const I=r.makeOutput(h.outShape,"float32"),M=r.dataIdMap.get(I.dataId).id,L=null==i?0:r.dataIdMap.get(i.dataId).id;return Ef(b,$,O,R,g,v,T,_,S,N,x,k,F,C,A,D,E,P,w,y,L,f||0,M),I}};let Ff;const $f={kernelName:Jt,backendName:"wasm",setupFunc:function(t){Ff=t.wasm.cwrap(Jt,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(t){const{backend:e,inputs:n}=t,{params:r,indices:a}=n,[s,o,i,u]=function(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(0===D(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const a=e.shape,s=a[a.length-1];let o=1;for(let t=0;t<a.length-1;++t)o*=a[t];const i=t.shape,u=a.slice();u.pop();let l=1;for(let t=s;t<n;++t)l*=i[t],u.push(i[t]);const c=[...z(t.shape).map((t=>t/l)),1].slice(0,s);return[u,o,l,c]}(r,a),l=e.makeOutput(s,r.dtype);if(0===o)return l;const c=a.shape,d=c[c.length-1],p=e.dataIdMap.get(r.dataId).id,m=e.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(u).buffer),h=e.dataIdMap.get(l.dataId).id;return Ff(p,Fp[r.dtype],m,o,d,i,f,h),l}};let Of;const Rf={kernelName:Xt,backendName:"wasm",setupFunc:function(t){Of=t.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{x:a,indices:s}=n,{axis:o,batchDims:i}=r,u=$(o,a.shape)[0],l=e.readSync(s.dataId),c=a.shape[u];for(let t=0;t<l.length;++t){const e=l[t];k(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}const d=function(t,e,n,r){const a=e.shape.length,s=t.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(t.shape[n]!==e.shape[n])throw new Error(`x.shape[${n}]: ${t.shape[n]} should be equal to indices.shape[${n}]: ${e.shape[n]}.`);const o=t.shape[n],i=[];let u=1,l=1,c=1;for(let e=0;e<r;++e)i.push(t.shape[e]),u*=t.shape[e];for(let e=r;e<n;e++)i.push(t.shape[e]),l*=t.shape[e];for(let t=r;t<a;t++)i.push(e.shape[t]);for(let e=n+1;e<s;e++)i.push(t.shape[e]),c*=t.shape[e];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}(a,s,u,i),p=fm({inputs:{x:a},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:e}),m=D(s.shape),f=fm({inputs:{x:s},attrs:{shape:[d.batchSize,m/d.batchSize]},backend:e}),h=[d.batchSize,d.outerSize,m/d.batchSize,d.sliceSize],y=e.makeOutput(h,a.dtype);if(0===D(a.shape))return y;const b=p.shape.length-1,g=e.dataIdMap.get(p.dataId).id,w=e.dataIdMap.get(f.dataId).id,_=e.dataIdMap.get(y.dataId).id,v=new Uint8Array(new Int32Array(z(p.shape)).buffer),T=new Uint8Array(new Int32Array(z(h)).buffer);return Of(g,Fp[a.dtype],v,b,w,d.batchSize,T,_),e.disposeData(p.dataId),e.disposeData(f.dataId),y.shape=d.outputShape,y}},If=Vp(Kt,0,"bool"),Mf=Vp(Zt,0,"bool"),Lf=Ip(te,"bool"),zf=Ip(ee,"bool"),Vf=Ip(ne,"bool");let Bf;const Uf={kernelName:re,backendName:"wasm",setupFunc:function(t){Bf=t.wasm.cwrap(re,null,["number","number","number","number"])},kernelFunc:function(t){const{inputs:{x:e},attrs:{alpha:n},backend:r}=t,a=r.dataIdMap.get(e.dataId).id,s=r.makeOutput(e.shape,"float32");if(0!==D(e.shape)){const t=r.dataIdMap.get(s.dataId).id;Bf(a,Fp[e.dtype],n,t)}return s}},Wf=Vp(ae,0,"bool"),jf=Vp(se,0,"bool");let qf;const Hf={kernelName:oe,backendName:"wasm",setupFunc:function(t){qf=t.wasm.cwrap(oe,null,["number","number","number","number"])},kernelFunc:function(t){const{attrs:e,backend:n}=t,{start:r,stop:a,num:s}=e,o=Math.floor(s),i=n.makeOutput([o],"float32");return qf(n.dataIdMap.get(i.dataId).id,r,a,o),i}},Gf=Ip("Log"),Qf=Ip(ie),Xf=Vp(ue,0,"bool"),Jf=Ip(le),Kf=Vp(ce,0,"bool"),Zf=Vp("LogicalXor",0,"bool");let Yf;const th={kernelName:de,backendName:"wasm",setupFunc:function(t){Yf=t.wasm.cwrap(de,null,["number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{depthRadius:s,bias:o,alpha:i,beta:u}=r;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");const l=n.makeOutput(a.shape,a.dtype);return Yf(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,a.shape[3],s,o,i,u),l}};let eh;const nh={kernelName:pe,backendName:"wasm",setupFunc:function(t){eh=t.wasm.cwrap(pe,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,y:s,dy:o}=e,{depthRadius:i,bias:u,alpha:l,beta:c}=r;if("float32"!==a.dtype||"float32"!==s.dtype||"float32"!==o.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");const d=n.makeOutput(a.shape,a.dtype);return eh(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(d.dataId).id,o.shape[3],i,u,l,c),d}};let rh;const ah={kernelName:me,backendName:"wasm",setupFunc:function(t){rh=t.wasm.cwrap(me,null,["number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{reductionIndices:a,keepDims:s}=r,{x:o}=n;let i=e.dataIdMap.get(o.dataId).id,u=o;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:p}=Xp(o,a,e);if(p){u=l,i=e.dataIdMap.get(l.dataId).id}Ni("max",c,u.shape.length);const[m,f]=Ti(u.shape,c),h=D(f),y=e.makeOutput(m,o.dtype);if(0!==D(u.shape)){const t=e.dataIdMap.get(y.dataId).id;rh(i,Fp[o.dtype],h,t)}if(p&&e.disposeData(l.dataId),s){const t=Si(y.shape,d);y.shape=t}return y}},sh=Vp(fe);let oh;const ih={kernelName:he,backendName:"wasm",setupFunc:function(t){oh=t.wasm.cwrap(he,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,a=e.x,s=r.dataIdMap.get(a.dataId).id;k("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));const{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=n,c=mo(a.shape,o,i,1,u,l),d=c.filterHeight,p=c.filterWidth,m=c.padInfo.top,f=c.padInfo.right,h=c.padInfo.bottom,y=c.padInfo.left,b=c.dilationHeight,g=c.dilationWidth,w=c.strideHeight,_=c.strideWidth,v=c.inChannels,T=c.outChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);const S=r.makeOutput(c.outShape,"float32"),N=r.dataIdMap.get(S.dataId).id;return oh(s,a.shape[0],a.shape[1],a.shape[2],d,p,m,f,h,y,b,g,w,_,v,T,N),S}};let uh;const lh={kernelName:ye,backendName:"wasm",setupFunc:function(t){uh=t.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r,c=fo(a.shape,s,o,1,i,u,l),d=n.makeOutput(c.outShape,a.dtype);return uh(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};let ch;const dh={kernelName:"MaxPool3DGrad",backendName:"wasm",setupFunc:function(t){ch=t.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=r,c=fo(s.shape,o,i,1,u,l),d=n.makeOutput(s.shape,s.dtype);return ch(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};let ph;const mh={kernelName:be,backendName:"wasm",setupFunc:function(t){ph=t.wasm.cwrap(be,null,["number, number, number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{axis:a,keepDims:s}=r,{x:o}=n,i=e.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:m}=Xp(o,a,e);let f=d;if(m){const t=e.dataIdMap.get(c.dataId).id;t!==i&&(l=c,u=t,f=Ci(f.length,l.shape.length))}Ni("mean",f,l.shape.length);const[h,y]=Ti(l.shape,f),b=D(y);let g=l;"float32"!==l.dtype&&(g=xm({backend:e,inputs:{x:l},attrs:{dtype:"float32"}}),u=e.dataIdMap.get(g.dataId).id);const w=e.makeOutput(h,"float32");if(0!==D(l.shape)){const t=e.dataIdMap.get(w.dataId).id;ph(u,b,t)}if(m&&e.disposeData(c.dataId),s){const t=Si(w.shape,p);w.shape=t}return"float32"!==l.dtype&&e.disposeData(g.dataId),w}};let fh;const hh={kernelName:ge,backendName:"wasm",setupFunc:function(t){fh=t.wasm.cwrap(ge,null,["number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{axis:a,keepDims:s}=r,{x:o}=n,i=e.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:m}=Xp(o,a,e);if(m){const t=e.dataIdMap.get(c.dataId).id;t!==i&&(l=c,u=t)}Ni("min",d,l.shape.length);const[f,h]=Ti(l.shape,d),y=D(h),b=e.makeOutput(f,l.dtype);if(0!==D(l.shape)){const t=e.dataIdMap.get(b.dataId).id;fh(u,Fp[o.dtype],y,t)}if(m&&e.disposeData(c.dataId),s){const t=Si(b.shape,p);b.shape=t}return b}},yh=Vp(we);var bh;let gh;!function(t){t[t.reflect=0]="reflect",t[t.symmetric=1]="symmetric"}(bh||(bh={}));const wh={kernelName:_e,backendName:"wasm",kernelFunc:function(t){const{inputs:{x:e},backend:n,attrs:{paddings:r,mode:a}}=t,s=r.map(((t,n)=>t[0]+e.shape[n]+t[1])),o=n.dataIdMap.get(e.dataId).id,i=n.makeOutput(s,e.dtype),u=n.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),c=r.map((t=>t[0])),d=r.map((t=>t[1])),p=new Uint8Array(new Int32Array(c).buffer),m=new Uint8Array(new Int32Array(d).buffer);return gh(o,l,e.shape.length,Fp[e.dtype],p,m,bh[a],u),i},setupFunc:function(t){gh=t.wasm.cwrap(_e,null,["number","array","number","number","array","array","number","number"])}};let _h;function vh(t){const{backend:e,inputs:{logits:n},attrs:{dim:r}}=t,a=e.dataIdMap.get(n.dataId).id,s=e.makeOutput(n.shape,n.dtype),o=e.dataIdMap.get(s.dataId).id,i=n.shape[r],u=D(n.shape)/i;return 0===D(s.shape)||_h(a,o,i,u),s}const Th={kernelName:an,backendName:"wasm",setupFunc:function(t){_h=t.wasm.cwrap(an,null,["number","number","number","number"])},kernelFunc:vh};let Sh;const Nh={kernelName:ve,backendName:"wasm",setupFunc:function(t){Sh=t.wasm.cwrap(ve,null,["number","number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{numSamples:s,seed:o,normalized:i}=r;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);const u=i?a:vh({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[l,c]=u.shape,d=n.makeOutput([l,s],"int32");return Sh(n.dataIdMap.get(u.dataId).id,l,c,s,o,n.dataIdMap.get(d.dataId).id),i||n.disposeData(u.dataId),d}},xh=Vp(Te),kh=Ip("Neg");function Ch(t,e){const n=new Int32Array(t.wasm.HEAPU8.buffer,e,4),r=n[0],a=n[1],s=n[2],o=n[3];return t.wasm._free(e),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:o}}let Ah;const Dh={kernelName:Ne,backendName:"wasm",setupFunc:function(t){Ah=t.wasm.cwrap(Ne,"number",["number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{iouThreshold:a,maxOutputSize:s,scoreThreshold:o}=r,{boxes:i,scores:u}=n,l=e.dataIdMap.get(i.dataId).id,c=e.dataIdMap.get(u.dataId).id,d=Ah(l,c,s,a,o),{pSelectedIndices:p,selectedSize:m,pSelectedScores:f,pValidOutputs:h}=Ch(e,d);return e.wasm._free(f),e.wasm._free(h),e.makeOutput([m],"int32",p)}};let Eh;const Ph={kernelName:xe,backendName:"wasm",setupFunc:function(t){Eh=t.wasm.cwrap(xe,"number",["number","number","number","number","number","bool"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{iouThreshold:a,maxOutputSize:s,scoreThreshold:o,padToMaxOutputSize:i}=r,{boxes:u,scores:l}=n,c=e.dataIdMap.get(u.dataId).id,d=e.dataIdMap.get(l.dataId).id,p=Eh(c,d,s,a,o,i),{pSelectedIndices:m,selectedSize:f,pSelectedScores:h,pValidOutputs:y}=Ch(e,p);return e.wasm._free(h),[e.makeOutput([f],"int32",m),e.makeOutput([],"int32",y)]}};let Fh;const $h={kernelName:ke,backendName:"wasm",setupFunc:function(t){Fh=t.wasm.cwrap(ke,"number",["number","number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{iouThreshold:a,maxOutputSize:s,scoreThreshold:o,softNmsSigma:i}=r,{boxes:u,scores:l}=n,c=e.dataIdMap.get(u.dataId).id,d=e.dataIdMap.get(l.dataId).id,p=Fh(c,d,s,a,o,i),{pSelectedIndices:m,selectedSize:f,pSelectedScores:h,pValidOutputs:y}=Ch(e,p);return e.wasm._free(y),[e.makeOutput([f],"int32",m),e.makeOutput([f],"float32",h)]}},Oh=Vp(Se,0,"bool");let Rh;const Ih={kernelName:Ae,backendName:"wasm",setupFunc:function(t){Rh=t.wasm.cwrap(Ae,null,["number","number","number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a}=e,{dtype:s,depth:o,onValue:i,offValue:u}=r,l=n.makeOutput([...a.shape,o],s),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(a.dataId).id;return Rh(d,o,i,u,c),l}};const Mh={kernelName:Ce,backendName:"wasm",kernelFunc:function(t){const{inputs:{x:e},backend:n}=t,r=n.makeOutput(e.shape,e.dtype);return n.typedArrayFromHeap(r).fill(1),r}};const Lh={kernelName:De,backendName:"wasm",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r;if(1===e.length)return bf({inputs:{input:e[0]},backend:n,attrs:{dim:a}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{C(s,t.shape,"All tensors passed to stack must have matching shapes"),k(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],u=Em({inputs:e.map((t=>{const e=bf({inputs:{input:t},backend:n,attrs:{dim:a}});return i.push(e),e})),backend:n,attrs:{axis:a}});return i.forEach((t=>n.disposeData(t.dataId))),u}};let zh;const Vh={kernelName:Ee,backendName:"wasm",kernelFunc:function(t){const{inputs:{x:e},backend:n,attrs:{paddings:r,constantValue:a}}=t,s=r.map(((t,n)=>t[0]+e.shape[n]+t[1]));if(0===D(e.shape))return _f({backend:n,attrs:{shape:s,value:a,dtype:e.dtype}});const o=n.dataIdMap.get(e.dataId).id,i=n.makeOutput(s,e.dtype),u=n.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),c=r.map((t=>t[0])),d=r.map((t=>t[1])),p=new Uint8Array(new Int32Array(c).buffer),m=new Uint8Array(new Int32Array(d).buffer);return zh(o,l,e.shape.length,Fp[e.dtype],p,m,a,u),i},setupFunc:function(t){zh=t.wasm.cwrap(Ee,null,["number","array","number","number","array","array","number","number"])}},Bh=Vp("Pow");let Uh;const Wh={kernelName:Pe,backendName:"wasm",setupFunc:function(t){Uh=t.wasm.cwrap(Pe,null,["number","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r,alpha:a}=e,s=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id;let i=s;const u=r;let l=u;"float32"!==u.dtype&&(l=xm({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),i=n.dataIdMap.get(l.dataId).id);const c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return Uh(i,o,d),"float32"!==u.dtype&&n.disposeData(l.dataId),c}};let jh;const qh={kernelName:Fe,backendName:"wasm",setupFunc:function(t){jh=t.wasm.cwrap(Fe,null,["number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{axis:a,keepDims:s}=r,{x:o}=n,i=e.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:m}=Xp(o,a,e);let f=d;if(m){const t=e.dataIdMap.get(c.dataId).id;t!==i&&(l=c,u=t,f=Ci(f.length,l.shape.length))}Ni("prod",f,l.shape.length);const[h,y]=Ti(l.shape,f),b=D(y),g=e.makeOutput(h,l.dtype);if(0!==D(l.shape)){const t=e.dataIdMap.get(g.dataId).id;jh(u,b,Fp[g.dtype],t)}if(m&&e.disposeData(c.dataId),s){const t=Si(g.shape,p);g.shape=t}return g}};const Hh={kernelName:$e,backendName:"wasm",kernelFunc:t=>{const{backend:e,attrs:n}=t,{start:r,stop:a,step:s,dtype:o}=n,i=function(t,e,n,r){if(t===e||t<e&&n<0||e<t&&n>1)return W(0,r);const a=W(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),a[0]=t;for(let t=1;t<a.length;t++)a[t]=a[t-1]+n;return a}(r,a,s,o),u=e.makeOutput([i.length],o);return e.typedArrayFromHeap(u).set(i),u}},Gh=Vp(zt),Qh=Ip(Oe),Xh=Ip(Re),Jh=Ip(Be);let Kh;const Zh={kernelName:ze,backendName:"wasm",setupFunc:function(t){Kh=t.wasm.cwrap(ze,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{images:a}=n,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,[c,d,p,m]=a.shape,f=[c,u,l,m];let h,y=e.dataIdMap.get(a.dataId);"float32"!==y.dtype&&(h=xm({backend:e,inputs:{x:a},attrs:{dtype:"float32"}}),y=e.dataIdMap.get(h.dataId));const b=y.id,g=e.makeOutput(f,"float32");if(0===D(a.shape))return g;const w=e.dataIdMap.get(g.dataId).id;return Kh(b,c,d,p,m,u,l,s?1:0,o?1:0,w),null!=h&&e.disposeData(h.dataId),g}};let Yh;const ty={kernelName:Ve,backendName:"wasm",setupFunc:function(t){Yh=t.wasm.cwrap(Ve,null,["number","number","number","array","array","boolean"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r,i=n.makeOutput(a.shape,"float32");let u,l=n.dataIdMap.get(a.dataId);return"float32"!==l.dtype&&(u=xm({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),Yh(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),o),null!=u&&n.disposeData(u.dataId),i}};let ey;const ny={kernelName:Me,backendName:"wasm",setupFunc:function(t){ey=t.wasm.cwrap(Me,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{images:a}=n,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,[c,d,p,m]=a.shape,f=[c,u,l,m],h=e.makeOutput(f,"float32");if(0===D(a.shape))return h;let y,b=e.dataIdMap.get(a.dataId);"float32"!==b.dtype&&(y=xm({backend:e,inputs:{x:a},attrs:{dtype:"float32"}}),b=e.dataIdMap.get(y.dataId));const g=b.id,w=e.dataIdMap.get(h.dataId).id;return ey(g,c,d,p,m,u,l,s?1:0,o?1:0,w),null!=y&&e.disposeData(y.dataId),h}};let ry;const ay={kernelName:Le,backendName:"wasm",setupFunc:function(t){ry=t.wasm.cwrap(Le,null,["number","number","number","array","array","boolean"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r,i=n.makeOutput(a.shape,"float32");let u,l=n.dataIdMap.get(a.dataId);return"float32"!==l.dtype&&(u=xm({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),ry(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),o),null!=u&&n.disposeData(u.dataId),i}};let sy;const oy={kernelName:Ue,backendName:"wasm",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dims:s}=r,o=$(s,a.shape);if(0===a.shape.length)return jp({inputs:{x:a},backend:n});const i=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(o).buffer),d=new Uint8Array(new Int32Array(a.shape).buffer);sy(u,c,o.length,d,a.shape.length,l);const p=fm({inputs:{x:i},attrs:{shape:a.shape},backend:n});return n.disposeData(i.dataId),p},setupFunc:function(t){sy=t.wasm.cwrap(Ue,null,["number","array","number","array","number","number"])}};let iy;const uy={kernelName:kn,backendName:"wasm",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a}=e,{radians:s,fillValue:o,center:i}=r,u=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(u.dataId).id,[d,p,m,f]=a.shape,[h,y]=function(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}(i,p,m),b="number"==typeof o?[o,o,o,0===o?0:255]:[...o,255],g=new Uint8Array(new Int32Array(b).buffer);return iy(l,d,p,m,f,s,h,y,g,b.length,c),u},setupFunc:function(t){iy=t.wasm.cwrap(kn,null,["number","number","number","number","number","number","number","number","array","number","number"])}},ly=Ip(We),cy=Ip(je);let dy;const py={kernelName:qe,backendName:"wasm",setupFunc:function(t){dy=t.wasm.cwrap(qe,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{indices:a,updates:s}=n,{shape:o}=r,i=e.makeOutput(o,s.dtype);if(0===D(o))return i;const{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=Gs(0,a,o),m=e.dataIdMap.get(a.dataId).id,f=e.dataIdMap.get(s.dataId).id,h=new Uint8Array(new Int32Array(d).buffer),y=e.dataIdMap.get(i.dataId).id;return dy(m,f,Fp[s.dtype],u,l,c,h,p,y),i}};let my;const fy={kernelName:Ge,backendName:"wasm",setupFunc:function(t){my=t.wasm.cwrap(Ge,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:a,values:s}=e,{side:o}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);const i=n.makeOutput(s.shape,"int32");function u(t){return n.dataIdMap.get(t.dataId).id}return my(u(a),u(s),a.shape[0],a.shape[1],s.shape[1],Fp[a.dtype],"left"===o,u(i)),i}};let hy;const yy={kernelName:Qe,backendName:"wasm",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:a,e:s}=e,o=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(s.dataId).id,l=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(l.dataId).id,d=r.shape.length,p=a.shape.length,m=0===d||d>1||1===p?1:D(a.shape.slice(1));return hy(o,i,u,m,c),l},setupFunc:function(t){hy=t.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},by=Ip(Xe);let gy;const wy={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(t){gy=t.wasm.cwrap(Ze,null,["number","number"])},kernelFunc:function(t){const{backend:e,inputs:{x:n}}=t,r=e.dataIdMap.get(n.dataId).id,a=e.makeOutput(n.shape,n.dtype),s=e.dataIdMap.get(a.dataId).id;return 0===D(a.shape)||gy(r,s),a}},_y=Ip(Ke),vy=Ip("Sin"),Ty=Ip(Ye);const Sy={kernelName:nn,backendName:"wasm",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,paddings:o}=r,i=D(s),u=[[0,0]];u.push(...o);for(let t=1+s.length;t<a.shape.length;++t)u.push([0,0]);const l=Vh.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:u,constantValue:0}}),c=cd(l.shape,s,i,!1),d=dd(c.length,s.length,!1),p=pd(l.shape,s,i,!1),m=fm({inputs:{x:l},backend:n,attrs:{shape:c}}),f=Gp({inputs:{x:m},backend:n,attrs:{perm:d}}),h=fm({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeData(l.dataId),n.disposeData(m.dataId),n.disposeData(f.dataId),h}};let Ny;const xy={kernelName:sn,backendName:"wasm",setupFunc:function(t){Ny=t.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n}=t,{indices:r,values:a,denseShape:s,defaultValue:o}=n,i=r.shape[0],u=r.shape[1],l=e.readSync(s.dataId)[0],c=[i+l,u],d=e.dataIdMap.get(r.dataId).id,p=e.dataIdMap.get(a.dataId).id,m=e.dataIdMap.get(o.dataId).id,f=e.makeOutput(c,r.dtype),h=e.dataIdMap.get(f.dataId).id,y=e.makeOutput(c.slice(0,1),a.dtype),b=e.dataIdMap.get(y.dataId).id,g=e.makeOutput([l],"bool"),w=e.dataIdMap.get(g.dataId).id,_=e.makeOutput([i],r.dtype),v=e.dataIdMap.get(_.dataId).id,T=e.makeOutput([4],"int32"),S=e.dataIdMap.get(T.dataId).id,N=Ny(d,p,Fp[a.dtype],i,l,u,m,h,b,w,v,S),x=e.readSync(T.dataId);let k;switch(x[0]){case 1:k=`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${x[1]}`;break;case 2:C=x[1],A=x[2],k=`indices(${C}, 0) is invalid: ${A} < 0`;break;case 3:k=function(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}(x[1],x[2],x[3]);break;default:k=""}var C,A;if(e.disposeData(T.dataId),k)throw e.disposeData(f.dataId),e.disposeData(y.dataId),e.disposeData(g.dataId),e.disposeData(_.dataId),new Error(k);let D=f,E=y;return N!==c[0]&&(D=wm({inputs:{x:f},attrs:{begin:0,size:[N,u]},backend:e}),E=wm({inputs:{x:y},attrs:{begin:0,size:N},backend:e}),e.disposeData(f.dataId),e.disposeData(y.dataId)),[D,E,g,_]}};let ky;const Cy={kernelName:on,backendName:"wasm",setupFunc:function(t){ky=t.wasm.cwrap(on,null,["number","number","number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n}=t,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=e.dataIdMap.get(r.dataId).id,i=e.dataIdMap.get(a.dataId).id,u=e.dataIdMap.get(s.dataId).id,l=r.shape[0],c=D(s.shape),d=e.makeOutput([l,c],r.dtype),p=e.dataIdMap.get(d.dataId).id,m=e.makeOutput([c],s.dtype),f=e.dataIdMap.get(m.dataId).id,h=e.makeOutput([3],"int32"),y=e.dataIdMap.get(h.dataId).id;ky(o,i,u,l,p,f,y);const b=e.readSync(h.dataId);let g;switch(b[0]){case 0:v=b[1],T=b[2],g=`only one output dimension may be -1, not both ${v} and ${T}`;break;case 1:w=b[1],_=b[2],g=`size ${w} must be non-negative, not ${_}`;break;case 2:g="reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";break;case 3:g=function(t,e){return`Input to reshape is a SparseTensor with ${D(t)}\n  dense values, but the requested shape requires a multiple of ${D(e)}. inputShape=${t} outputShape= ${e}`}(Array.from(e.readSync(a.dataId)),Array.from(e.readSync(m.dataId)));break;case 4:g=function(t,e){return`Input to reshape is a tensor with ${D(t)} dense values, but the requested shape has ${D(e)}. inputShape=${t} outputShape=${e}`}(Array.from(e.readSync(a.dataId)),Array.from(e.readSync(m.dataId)));break;default:g=""}var w,_,v,T;if(e.disposeData(h.dataId),g)throw e.disposeData(d.dataId),e.disposeData(m.dataId),new Error(g);return[d,m]}};let Ay;function Dy(t){Ay=t.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Ey(t,e){const{backend:n,inputs:r}=t,{data:a,indices:s,segmentIds:o}=r,i=s.shape[0],u=n.readSync(o.dataId,i-1,i)[0],l=i>0?u+1:0;if(l<0)throw new Error("segment ids must be >= 0");const c=a.shape.slice();c[0]=l;const d=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,m=n.dataIdMap.get(o.dataId).id,f=n.makeOutput(c,a.dtype),h=n.dataIdMap.get(f.dataId).id,y=n.makeOutput([4],"int32"),b=n.dataIdMap.get(y.dataId).id;Ay(d,Fp[a.dtype],a.shape[0],p,m,h,b,e,0);const g=n.readSync(y.dataId);let w;switch(g[0]){case 0:w="segment ids must be >= 0";break;case 1:w="segment ids are not increasing";break;case 2:w=function(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}(g[1],g[2]);break;case 3:_=g[1],v=g[2],T=g[3],w=`Bad: indices[${_}] == ${v} out of range [0, ${T})`;break;default:w=""}var _,v,T;if(n.disposeData(y.dataId),w)throw n.disposeData(f.dataId),new Error(w);return f}const Py={kernelName:un,backendName:"wasm",setupFunc:Dy,kernelFunc:function(t){return Ey(t,!0)}};const Fy={kernelName:ln,backendName:"wasm",setupFunc:Dy,kernelFunc:function(t){return Ey(t,!1)}};let $y;const Oy={kernelName:cn,backendName:"wasm",setupFunc:function(t){$y=t.wasm.cwrap(cn,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{sparseIndices:a,sparseValues:s,defaultValue:o}=n,{outputShape:i}=r,u=e.makeOutput(i,o.dtype);if(0===D(i))return u;const{sliceRank:l,numUpdates:c,sliceSize:d,strides:p,outputSize:m}=Gs(0,a,i),f=e.dataIdMap.get(a.dataId).id,h=e.dataIdMap.get(s.dataId).id,y=e.dataIdMap.get(o.dataId).id,b=new Uint8Array(new Int32Array(p).buffer),g=e.dataIdMap.get(u.dataId).id;return $y(f,h,s.shape.length,y,Fp[o.dtype],l,c,d,b,m,g),u}};const Ry={kernelName:rn,backendName:"wasm",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{x:a}=e,{numOrSizeSplits:s,axis:o}=n,i=$(o,a.shape)[0],u=function(t,e,n=0){let r=[];if("number"==typeof e)k(t.shape[n]%e==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(e).fill(t.shape[n]/e);else{k(e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0)<=1,(()=>"There should be only one negative value in split array."));const a=e.indexOf(-1);if(-1!==a){const r=e.reduce(((t,e)=>e>0?t+e:t));e[a]=t.shape[n]-r}k(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=e}return r}(a,s,i),l=new Array(a.shape.length).fill(0),c=a.shape.slice();return u.map((t=>{const e=[...c];e[i]=t;const n=wm({inputs:{x:a},attrs:{begin:l,size:e},backend:r});return l[i]+=t,n}))}},Iy=Ip(tn),My=Ip("Square"),Ly=Vp(dn);let zy;const Vy={kernelName:Nn,backendName:"wasm",setupFunc:function(t){zy=t.wasm.cwrap(Nn,null,["number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{alpha:a}=r,{x:s}=n,o=e.dataIdMap.get(s.dataId).id,i=e.makeOutput(s.shape,s.dtype),u=e.dataIdMap.get(i.dataId).id;return zy(o,a,Fp[s.dtype],u),i}};let By;const Uy={kernelName:pn,backendName:"wasm",setupFunc:function(t){By=t.wasm.cwrap(pn,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{x:a}=n,{begin:s,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r,{finalShapeSparse:m,finalShape:f,isIdentity:h,sliceDim0:y,isSimpleSlice:b,begin:g,end:w,strides:_}=Ks(a.shape,s,o,i,u,l,c,d,p);let v;if(h)v=fm({inputs:{x:a},backend:e,attrs:{shape:f}});else if(y||b){k(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const t=function(t,e,n){const r=[];for(let a=0;a<t.length;a++)r[a]=Math.ceil((e[a]-t[a])/n[a]);return r}(g,w,_),n=wm({inputs:{x:a},backend:e,attrs:{begin:g,size:t}});v=fm({inputs:{x:n},backend:e,attrs:{shape:f}}),e.disposeData(n.dataId)}else{const t=e.makeOutput(m,"float32"),n=e.dataIdMap.get(a.dataId).id,r=new Uint8Array(new Int32Array(z(a.shape)).buffer),s=new Uint8Array(new Int32Array(g).buffer),o=new Uint8Array(new Int32Array(w).buffer),i=new Uint8Array(new Int32Array(_).buffer),u=new Uint8Array(new Int32Array(m).buffer),l=new Uint8Array(new Int32Array(z(m)).buffer),c=e.dataIdMap.get(t.dataId).id;By(n,r,a.shape.length,s,o,i,u,l,m.length,c),v=fm({inputs:{x:t},backend:e,attrs:{shape:f}}),e.disposeData(t.dataId)}return v}};class Wy{constructor(t,e,n,r,a,s){this.separator=er(t),this.nGramWidths=e,this.leftPad=er(n),this.rightPad=er(r),this.padWidth=a,this.preserveShort=s}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,r,a,s){for(let o=0;o<a;++o){const i=this.getPadWidth(s),u=Math.max(0,i-o),l=Math.max(0,i-(a-(o+1))),c=s-(u+l),d=e+(u>0?0:o-i);let p=0;p+=u*this.leftPad.length;for(let e=0;e<c;++e)p+=t[d+e].length;p+=l*this.rightPad.length;p+=(u+l+c-1)*this.separator.length,n[r+o]=new Uint8Array(p);const m=n[r+o];let f=0;const h=t=>t.forEach((t=>m[f++]=t));for(let t=0;t<u;++t)h(this.leftPad),h(this.separator);for(let e=0;e<c-1;++e)h(t[d+e]),h(this.separator);if(c>0){h(t[d+c-1]);for(let t=0;t<l;++t)h(this.separator),h(this.rightPad)}else{for(let t=0;t<l-1;++t)h(this.rightPad),h(this.separator);h(this.rightPad)}}}compute(t,e){const n=t.length,r=e.length;if(r>0){let t=e[0];if(0!==t)throw new Error(`First split value must be 0, got ${t}`);for(let a=1;a<r;++a){let r=e[a]>=t;if(r=r&&e[a]<=n,!r)throw new Error(`Invalid split value ${e[a]}, must be in [${t}, ${n}]`);t=e[a]}if(t!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${t}`)}const a=r-1,s=O("int32",r);if(0===n||0===r){const t=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[t,s]}s[0]=0;for(let t=1;t<=a;++t){const n=e[t]-e[t-1];let r=0;this.nGramWidths.forEach((t=>{r+=this.getNumNGrams(n,t)})),this.preserveShort&&n>0&&0===r&&(r=1),s[t]=s[t-1]+r}const o=new Array(s[a]);for(let n=0;n<a;++n){const r=e[n];let a=s[n];if(this.nGramWidths.forEach((s=>{const i=e[n+1]-e[n],u=this.getNumNGrams(i,s);this.createNGrams(t,r,o,a,u,s),a+=u})),this.preserveShort&&a===s[n]){const s=e[n+1]-e[n];if(0===s)continue;const i=s+2*this.padWidth,u=1;this.createNGrams(t,r,o,a,u,i)}}return[o,s]}}const jy={kernelName:mn,backendName:"wasm",kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{data:a,dataSplits:s}=n,{separator:o,nGramWidths:i,leftPad:u,rightPad:l,padWidth:c,preserveShortSequences:d}=r,p=e.readSync(a.dataId),m=e.readSync(s.dataId),[f,h]=function(t,e,n,r,a,s,o,i){return new Wy(n,r,a,s,o,i).compute(t,e)}(p,m,o,i,u,l,c,d),y=e.makeOutput([f.length],"string");e.dataIdMap.get(y.dataId).stringBytes=f;const b=e.makeOutput(s.shape,"int32");return e.typedArrayFromHeap(b).set(h),[y,b]}};function qy(t,e,n,r){if(!t.length)return;if(0===e.length){for(let e=0;e<t.length;++e)r.push(t.subarray(e,e+1));return}if(1===e.length){const a=e[0];let s=t.indexOf(a);for(;-1!==s;){const e=t.subarray(0,s);n&&0===e.length||r.push(e),s=(t=t.subarray(s+1)).indexOf(a)}return void(n&&0===t.length||r.push(t))}let a=0;for(let s=0;s<t.length+1;s++)if(s===t.length||-1!==e.indexOf(t[s])){const e=t.subarray(a,s);n&&0===e.length||r.push(e),a=s+1}}const Hy={kernelName:fn,backendName:"wasm",kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{input:a,delimiter:s}=n,{skipEmpty:o}=r,i=e.readSync(a.dataId),u=e.readSync(s.dataId),[l,c,d]=function(t,e,n){const r=t.length,a=[];let s=0,o=0;const i=new Array(r);for(let u=0;u<r;++u){const r=a.length;qy(t[u],e,n,a);const l=a.length-r;i[u]=l,s+=l,o=Math.max(o,l)}const u=O("int32",2*s),l=new Array(s),c=[r,o];let d=0;for(let t=0;t<r;++t)for(let e=0;e<i[t];++e)u[2*d]=t,u[2*d+1]=e,l[d]=a[d],++d;return[u,l,c]}(i,u[0],o),p=c.length,m=e.makeOutput([p,2],"int32");e.typedArrayFromHeap(m).set(l);const f=e.makeOutput([p],"string");e.dataIdMap.get(f.dataId).stringBytes=c;const h=e.makeOutput([2],"int32");return e.typedArrayFromHeap(h).set(d),[m,f,h]}};const Gy={kernelName:hn,backendName:"wasm",kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{input:a}=n,{numBuckets:s}=r,o=function(t,e){const n=O("int32",t.length);for(let r=0;r<t.length;++r)n[r]=Zn(t[r]).modulo(e).getLowBitsUnsigned();return n}(e.readSync(a.dataId),s),i=e.makeOutput(a.shape,"int32");return e.typedArrayFromHeap(i).set(o),i}},Qy=Vp("Sub");let Xy;const Jy={kernelName:en,backendName:"wasm",setupFunc:function(t){Xy=t.wasm.cwrap(en,null,["number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{axis:a,keepDims:s}=r,{x:o}=n,i=e.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:m}=Xp(o,a,e);let f=d;if(m){const t=e.dataIdMap.get(c.dataId).id;t!==i&&(l=c,u=t,f=Ci(f.length,l.shape.length))}Ni("sum",f,l.shape.length);const[h,y]=Ti(l.shape,f),b=D(y),g=e.makeOutput(h,l.dtype);if(0!==D(l.shape)){const t=e.dataIdMap.get(g.dataId).id;Xy(u,b,Fp[g.dtype],t)}if(m&&e.disposeData(c.dataId),s){const t=Si(g.shape,p);g.shape=t}return g}},Ky=Ip("Tan"),Zy=Ip(yn);let Yy;const tb={kernelName:He,backendName:"wasm",setupFunc:function(t){Yy=t.wasm.cwrap(He,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{tensor:a,indices:s,updates:o}=n,{}=r,i=e.makeOutput(a.shape,a.dtype);if(0===D(a.shape))return i;const{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=Gs(0,s,a.shape),m=e.dataIdMap.get(s.dataId).id,f=e.dataIdMap.get(o.dataId).id,h=e.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(d).buffer),b=e.dataIdMap.get(i.dataId).id;return Yy(m,f,Fp[o.dtype],u,l,c,y,p,b,h),i}};let eb;const nb={kernelName:bn,backendName:"wasm",setupFunc:function(t){eb=t.wasm.cwrap(bn,null,["number","array","number","array","number","number"])},kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,s=n.dataIdMap.get(a.dataId).id,{reps:o}=r,i=new Array(a.shape.length);for(let t=0;t<i.length;t++)i[t]=a.shape[t]*o[t];const u=new Uint8Array(new Int32Array(a.shape).buffer),l=new Uint8Array(new Int32Array(i).buffer),c=n.makeOutput(i,a.dtype),d=n.dataIdMap.get(c.dataId).id;return eb(s,u,a.shape.length,l,i.length,Fp[c.dtype],d),c}};let rb;const ab={kernelName:gn,backendName:"wasm",setupFunc:function(t){rb=t.wasm.cwrap(gn,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{k:a,sorted:s}=n,o=e.dataIdMap.get(r.dataId).id,i=new Uint8Array(new Int32Array(r.shape).buffer),u=r.shape.slice();u[u.length-1]=a;const l=e.makeOutput(u,r.dtype),c=e.dataIdMap.get(l.dataId).id,d=e.makeOutput(u,"int32"),p=e.dataIdMap.get(d.dataId).id;return rb(o,i,r.shape.length,Fp[r.dtype],a,s,c,p),[l,d]}};let sb;const ob={kernelName:wn,backendName:"wasm",setupFunc:function(t){sb=t.wasm.cwrap(wn,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(t){const{backend:e,inputs:n,attrs:r}=t,{image:a,transforms:s}=n,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=r,[c,d,p,m]=a.shape,[f,h]=null!=l?l:[d,p],y=[c,f,h,m],b=new Uint8Array(new Int32Array(z(a.shape)).buffer),g=new Uint8Array(new Int32Array(z(y)).buffer),w=e.makeOutput(y,a.dtype),_=e.dataIdMap.get(w.dataId).id,v=e.dataIdMap.get(a.dataId).id,T=e.dataIdMap.get(s.dataId).id,S="nearest"===o?1:2;let N;switch(i){case"constant":default:N=1;break;case"reflect":N=2;break;case"wrap":N=3;break;case"nearest":N=4}return sb(v,T,s.shape[0]>1,c,f,h,m,p,d,b,a.shape.length-1,g,y.length-1,S,N,u,_),w}};const ib={kernelName:vn,backendName:"wasm",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:a}=n,{x:s}=e,{outputValues:o,outputShape:i,indices:u}=function(t,e,n,r){const a=$(e,n)[0],s=[1,n[0],1];for(let t=0;t<a;t++)s[0]*=n[t];s[1]=n[a];for(let t=a+1;t<n.length;t++)s[2]*=n[t];const o=new Map,i=new Int32Array(n[a]),u=new mr(s,r,t),l=[],c=1===s[0]&&1===s[2];for(let e=0;e<n[a];e++){let n;if(c)n=t[e].toString();else{const t=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)t.push(u.get(n,e,r));n=t.join(",")}const r=o.get(n);if(null!=r)i[e]=r;else{const t=o.size;o.set(n,t),i[e]=t,l.push(e)}}const d=s.slice();d[1]=o.size;const p=new mr(d,r);l.forEach(((t,e)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)p.set(u.get(n,t,r),n,e,r)}));const m=n.slice();return m[a]=d[1],{outputValues:p.values,outputShape:m,indices:i}}(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(i,s.dtype,void 0,o),r.makeOutput([u.length],"int32",void 0,u)]}};const ub={kernelName:Tn,backendName:"wasm",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:a}=e;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a.shape[s],i=a.shape.length,u=new Array(i-1);let l=0;for(let t=0;t<i;t++)t!==s&&(u[l++]=a.shape[t]);const c=new Array(o),d=new Array(i).fill(0),p=a.shape.slice();p[s]=1;for(let t=0;t<c.length;t++)d[s]=t,c[t]=wm({inputs:{x:a},attrs:{begin:d,size:p},backend:n});return c.map((({dataId:t,dtype:e})=>({dataId:t,dtype:e,shape:u})))}};const lb={kernelName:Sn,backendName:"wasm",kernelFunc:function(t){const{inputs:{x:e},backend:n}=t,r=n.makeOutput(e.shape,e.dtype);return n.typedArrayFromHeap(r).fill(0),r}},cb=[Rp,Mp,Lp,zp,Bp,Wp,Kp,Yp,em,nm,rm,am,sm,om,im,lm,dm,mm,bm,vm,Sm,Nm,km,Cm,Dm,Pm,$m,Rm,Mm,zm,Bm,Um,Wm,Hm,Qm,Jm,Zm,tf,nf,af,of,lf,df,pf,ff,hf,yf,gf,wf,vf,Sf,Nf,xf,Cf,Df,Pf,$f,Rf,If,Mf,qp,Lf,zf,Vf,Uf,Wf,jf,Hf,Qf,Gf,Xf,Jf,Kf,Zf,th,nh,ah,sh,ih,lh,dh,mh,hh,yh,wh,Nh,xh,kh,Dh,Ph,$h,Oh,Ih,Mh,Lh,Vh,Bh,Wh,qh,Hh,Gh,Qh,Xh,Jh,hm,Zh,ty,ny,ay,oy,uy,ly,cy,py,fy,yy,by,wy,_y,vy,_m,Th,Ty,Sy,xy,Cy,Py,Fy,Oy,Ry,Iy,My,Ly,Vy,Uy,jy,Hy,Gy,Qy,Jy,Ky,Zy,tb,nb,ab,ob,Qp,ib,ub,lb];for(const t of cb)In(t);const db=X();db.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(t){return!1}})),db.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(db.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(t){return!1}}));var pb=n(853),mb=n.n(pb),fb=n(269),hb=n(33),yb=n.n(hb);const bb=mb()||pb,gb=yb()||hb;class wb extends N{constructor(t){super(),this.wasm=t,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(Ab),Db=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new S(this,Rr)}write(t,e,n){const r={id:this.dataIdNextNumber++};return this.move(r,t,e,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){const e=tr();t();return{kernelMs:tr()-e}}move(t,e,n,r,a){const s=this.dataIdNextNumber++;if("string"===r){const o=e;return void this.dataIdMap.set(t,{id:s,stringBytes:o,shape:n,dtype:r,memoryOffset:null,refCount:a})}const o=D(n),i=o*R(r),u=this.wasm._malloc(i)>>>0;this.dataIdMap.set(t,{id:s,memoryOffset:u,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,o,u),null!=e&&this.wasm.HEAPU8.set(new Uint8Array(e.buffer,e.byteOffset,i),u)}async read(t){return this.readSync(t)}readSync(t,e,n){const{memoryOffset:r,dtype:a,shape:s,stringBytes:o}=this.dataIdMap.get(t);if("string"===a)return null!=e&&0!==e||!(null==n||n>=o.length)?o.slice(e,n):o;e=e||0,n=n||D(s);const i=R(a);return function(t,e){switch(e){case"float32":return new Float32Array(t);case"int32":return new Int32Array(t);case"bool":return new Uint8Array(t);default:throw new Error(`Unknown dtype ${e}`)}}(this.wasm.HEAPU8.slice(r+e*i,r+n*i).buffer,a)}disposeData(t,e=!1){if(this.dataIdMap.has(t)){const n=this.dataIdMap.get(t);if(n.refCount--,!e&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(t)}return!0}refCount(t){if(this.dataIdMap.has(t)){return this.dataIdMap.get(t).refCount}return 0}incRef(t){const e=this.dataIdMap.get(t);null!=e&&e.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,e,n,r){let a;if(null==n)a=this.write(null!=r?r:null,t,e);else{const r=this.dataIdNextNumber++;a={id:r},this.dataIdMap.set(a,{id:r,memoryOffset:n,shape:t,dtype:e,refCount:1});const s=D(t);this.wasm.tfjs.registerTensor(r,s,n)}return{dataId:a,shape:t,dtype:e}}typedArrayFromHeap({shape:t,dtype:e,dataId:n}){const r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=D(t);switch(e){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${e}`)}}}function _b(t){return(e,n)=>(function(t,e){return X().platform.fetch(t,e)}(t,{credentials:"same-origin"}).then((r=>{r.ok||e.env.a(`failed to load wasm binary file at '${t}'`),r.arrayBuffer().then((t=>{WebAssembly.instantiate(t,e).then((t=>{n(t.instance,t.module)}))}))})),{})}function vb(t,e,n){if(null!=Sb)return Sb;let r="tfjs-backend-wasm.wasm";return t&&e?r="tfjs-backend-wasm-threaded-simd.wasm":t&&(r="tfjs-backend-wasm-simd.wasm"),null!=xb&&null!=xb[r]?xb[r]:n+r}const Tb=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let Sb=null,Nb=null,xb={},kb=!1,Cb=!1;let Ab=-1,Db=null;function Eb(t,e,n,r){return new(n||(n=Promise))((function(a,s){function o(t){try{u(r.next(t))}catch(t){s(t)}}function i(t){try{u(r.throw(t))}catch(t){s(t)}}function u(t){var e;t.done?a(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,i)}u((r=r.apply(t,e||[])).next())}))}function Pb(t,e){var n,r,a,s,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(a=2&s[0]?r.return:s[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,s[1])).done)return a;switch(r=0,a&&(s=[2&s[0],a.value]),s[0]){case 0:case 1:a=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(a=(a=o.trys).length>0&&a[a.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!a||s[1]>a[0]&&s[1]<a[3])){o.label=s[1];break}if(6===s[0]&&o.label<a[1]){o.label=a[1],a=s;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(s);break}a[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],r=0}finally{n=a=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}!function(t,e,n=1){Rr.registerBackend(t,e,n)}("wasm",(async()=>{const{wasm:t}=await async function(){const[t,e]=await Promise.all([X().getAsync("WASM_HAS_SIMD_SUPPORT"),X().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{const a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){const t=fb.$.replace(/\n/g,"\\n"),e=new Blob([t],{type:"application/javascript"});return URL.createObjectURL(e)}return n.endsWith(".wasm")?vb(t,e,null!=Nb?Nb:r):r+n}};Cb&&(a.instantiateWasm=_b(vb(t,e,null!=Nb?Nb:"")));let s,o=!1;a.onAbort=()=>{o||kb||(kb=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},e&&t&&null==Sb?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+bb.toString()],{type:"text/javascript"}),s=bb(a)):s=gb(a),s.then((t=>{o=!0,kb=!1,t.tfjs={init:t.cwrap("init",null,[]),initWithThreadsCount:t.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:t.cwrap("get_threads_count","number",[]),registerTensor:t.cwrap("register_tensor",null,["number","number","number"]),disposeData:t.cwrap("dispose_data",null,["number"]),dispose:t.cwrap("dispose",null,[])},n({wasm:t})})).catch(r)}))}();return new wb(t)}),2);var Fb=function(t){return{startEndTensor:t,startPoint:$o(t,[0,0],[-1,2]),endPoint:$o(t,[0,2],[-1,2])}},$b={strides:[8,16],anchors:[2,6]};function Ob(t,e){var n,r,a;if(t.topLeft instanceof br&&t.bottomRight instanceof br){var s=Ka((function(){return[Eo([$o(hs(e-1,t.topLeft),0,1),$o(t.topLeft,1,1)]),Eo([hs(e-1,$o(t.bottomRight,0,1)),$o(t.bottomRight,1,1)])]}));n=s[0],r=s[1],null!=t.landmarks&&(a=Ka((function(){var n=hs(Pl([e-1,0]),t.landmarks),r=Pl([1,-1]);return rs(n,r)})))}else{var o=t.topLeft,i=o[0],u=o[1],l=t.bottomRight,c=l[0],d=l[1];n=[e-1-i,u],r=[e-1-c,d],null!=t.landmarks&&(a=t.landmarks.map((function(t){return[e-1-t[0],t[1]]})))}var p={topLeft:n,bottomRight:r};return null!=a&&(p.landmarks=a),null!=t.probability&&(p.probability=t.probability instanceof br?t.probability.clone():t.probability),p}function Rb(t,e){return Ka((function(){var n;return n=t.hasOwnProperty("box")?t.box:t,kl(function(t,e){var n=rs(t.startPoint,e),r=rs(t.endPoint,e),a=Qo([n,r],1);return Fb(a)}(n,e).startEndTensor)}))}var Ib=function(){function t(t,e,n,r,a,s){this.blazeFaceModel=t,this.width=e,this.height=n,this.maxFaces=r,this.anchorsData=function(t,e,n){for(var r=[],a=0;a<n.strides.length;a++)for(var s=n.strides[a],o=Math.floor((e+s-1)/s),i=Math.floor((t+s-1)/s),u=n.anchors[a],l=0;l<o;l++)for(var c=s*(l+.5),d=0;d<i;d++)for(var p=s*(d+.5),m=0;m<u;m++)r.push([p,c]);return r}(e,n,$b),this.anchors=Fl(this.anchorsData),this.inputSizeData=[e,n],this.inputSize=Pl([e,n]),this.iouThreshold=a,this.scoreThreshold=s}return t.prototype.getBoundingBoxes=function(t,e,n){return void 0===n&&(n=!0),Eb(this,void 0,void 0,(function(){var r,a,s,o,i,u,l,c,d,p,m,f,h,y,b=this;return Pb(this,(function(g){switch(g.label){case 0:return r=Ka((function(){var e=rd.resizeBilinear(t,[b.width,b.height]),n=rs(hs(ns(e,255),.5),2),r=b.blazeFaceModel.predict(n),a=kl(r),s=function(t,e,n){var r=$o(t,[0,1],[-1,2]),a=ts(r,e),s=$o(t,[0,3],[-1,2]),o=ns(s,n),i=ns(a,n),u=ns(o,2),l=hs(i,u),c=ts(i,u),d=rs(l,n),p=rs(c,n);return Qo([d,p],1)}(a,b.anchors,b.inputSize),o=$o(a,[0,0],[-1,1]);return[a,s,kl(Fo(o))]})),a=r[0],s=r[1],o=r[2],i=console.warn,console.warn=function(){},u=rd.nonMaxSuppression(s,o,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=i,[4,u.array()];case 1:return l=g.sent(),u.dispose(),c=l.map((function(t){return $o(s,[t,0],[1,-1])})),e?[3,3]:[4,Promise.all(c.map((function(t){return Eb(b,void 0,void 0,(function(){var e;return Pb(this,(function(n){switch(n.label){case 0:return[4,t.array()];case 1:return e=n.sent(),t.dispose(),[2,e]}}))}))})))];case 2:c=g.sent(),g.label=3;case 3:for(d=t.shape[1],p=t.shape[2],m=e?ns([p,d],this.inputSize):[p/this.inputSizeData[0],d/this.inputSizeData[1]],f=[],h=function(t){var r=c[t],s=Ka((function(){var s=Fb(r instanceof br?r:Fl(r));if(!n)return s;var i,u=l[t];return i=e?$o(b.anchors,[u,0],[1,2]):b.anchorsData[u],{box:s,landmarks:Co(kl($o(a,[u,5],[1,-1])),[6,-1]),probability:$o(o,[u],[1]),anchor:i}}));f.push(s)},y=0;y<c.length;y++)h(y);return s.dispose(),o.dispose(),a.dispose(),[2,{boxes:f,scaleFactor:m}]}}))}))},t.prototype.estimateFaces=function(t,e,n,r){return void 0===e&&(e=!1),void 0===n&&(n=!1),void 0===r&&(r=!0),Eb(this,void 0,void 0,(function(){var a,s,o,i,u,l,c=this;return Pb(this,(function(d){switch(d.label){case 0:return a=function(t){return t instanceof br?[t.shape[0],t.shape[1]]:[t.height,t.width]}(t),s=a[1],o=Ka((function(){return t instanceof br||(t=qs(t)),Ri(Qa(t,"float32"),0)})),[4,this.getBoundingBoxes(o,e,r)];case 1:return i=d.sent(),u=i.boxes,l=i.scaleFactor,o.dispose(),e?[2,u.map((function(t){var e=Rb(t,l),a={topLeft:$o(e,[0],[2]),bottomRight:$o(e,[2],[2])};if(r){var o=t,i=o.landmarks,u=o.probability,c=o.anchor,d=rs(ts(i,c),l);a.landmarks=d,a.probability=u}return n&&(a=Ob(a,s)),a}))]:[2,Promise.all(u.map((function(t){return Eb(c,void 0,void 0,(function(){var e,a,o,i,u,c,d,p,m,f,h,y=this;return Pb(this,(function(b){switch(b.label){case 0:return e=Rb(t,l),r?[3,2]:[4,e.array()];case 1:return u=b.sent(),a={topLeft:u.slice(0,2),bottomRight:u.slice(2)},[3,4];case 2:return[4,Promise.all([t.landmarks,e,t.probability].map((function(t){return Eb(y,void 0,void 0,(function(){return Pb(this,(function(e){return[2,t.array()]}))}))})))];case 3:o=b.sent(),i=o[0],u=o[1],c=o[2],d=t.anchor,m=(p=l)[0],f=p[1],h=i.map((function(t){return[(t[0]+d[0])*m,(t[1]+d[1])*f]})),a={topLeft:u.slice(0,2),bottomRight:u.slice(2),landmarks:h,probability:c},function(t){t.startEndTensor.dispose(),t.startPoint.dispose(),t.endPoint.dispose()}(t.box),t.landmarks.dispose(),t.probability.dispose(),b.label=4;case 4:return e.dispose(),n&&(a=Ob(a,s)),[2,a]}}))}))})))]}}))}))},t}();const Mb=JSON.parse('{"GP":"graph-model","BH":"1.15.0","e2":"TensorFlow.js Converter v1.3.2","Q8":{"signature":{"inputs":{"input:0":{"name":"input:0","dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"-1"},{"size":"128"},{"size":"128"},{"size":"3"}]}}},"outputs":{"Identity:0":{"name":"Identity:0","dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"-1"},{"size":"-1"},{"size":"17"}]}}}}},"vS":{"node":[{"name":"input","op":"Placeholder","attr":{"dtype":{"type":"DT_FLOAT"},"shape":{"shape":{"dim":[{"size":"-1"},{"size":"128"},{"size":"128"},{"size":"3"}]}}}},{"name":"StatefulPartitionedCall/model/conv2d/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"5"},{"size":"5"},{"size":"3"},{"size":"24"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_16/Conv2D_weights","op":"Const","attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"96"},{"size":"96"}]}}}}},{"name":"StatefulPartitionedCall/model/conv2d/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"24"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_1/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"24"},{"size":"24"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_16/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"96"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_1/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"24"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_2/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"24"},{"size":"28"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_2/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"28"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_3/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"28"},{"size":"32"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_3/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"32"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_4/Conv2D_weights","op":"Const","attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"32"},{"size":"36"}]}}}}},{"name":"StatefulPartitionedCall/model/conv2d_4/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"36"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_5/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"36"},{"size":"42"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_5/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"42"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_6/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"42"},{"size":"48"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_6/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"48"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_7/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"48"},{"size":"56"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_7/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"56"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_8/Conv2D_weights","op":"Const","attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"56"},{"size":"64"}]}}}}},{"name":"StatefulPartitionedCall/model/conv2d_8/Conv2D_bn_offset","op":"Const","attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"64"}]}}}}},{"name":"StatefulPartitionedCall/model/conv2d_9/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"64"},{"size":"72"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_9/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"72"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_10/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"72"},{"size":"80"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_10/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"80"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_11/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"80"},{"size":"88"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_11/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"88"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_12/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"88"},{"size":"96"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_12/Conv2D_bn_offset","op":"Const","attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"96"}]}}}}},{"name":"StatefulPartitionedCall/model/conv2d_13/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"96"},{"size":"96"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_13/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"96"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_14/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"96"},{"size":"96"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_14/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"96"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_15/Conv2D_weights","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"96"},{"size":"96"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/conv2d_15/Conv2D_bn_offset","op":"Const","attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"96"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"24"},{"size":"1"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding/Pad/paddings","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_INT32","tensorShape":{"dim":[{"size":"4"},{"size":"2"}]}}},"dtype":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_1/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"24"},{"size":"1"}]}}}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_2/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"28"},{"size":"1"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_3/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"32"},{"size":"1"}]}}}}},{"name":"StatefulPartitionedCall/model/channel_padding_3/Pad/paddings","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_INT32","tensorShape":{"dim":[{"size":"4"},{"size":"2"}]}}},"dtype":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_4/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"36"},{"size":"1"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_5/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"42"},{"size":"1"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding_5/Pad/paddings","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_INT32","tensorShape":{"dim":[{"size":"4"},{"size":"2"}]}}},"dtype":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_6/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"48"},{"size":"1"}]}}}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_7/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"56"},{"size":"1"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_8/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"64"},{"size":"1"}]}}}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_9/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"72"},{"size":"1"}]}}}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_10/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"80"},{"size":"1"}]}}}}},{"name":"StatefulPartitionedCall/model/classificator_8/Conv2D/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"88"},{"size":"2"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/classificator_8/BiasAdd/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"2"}]}}}}},{"name":"StatefulPartitionedCall/model/reshape/strided_slice/stack","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_INT32"},"value":{"tensor":{"dtype":"DT_INT32","tensorShape":{"dim":[{"size":"1"}]}}}}},{"name":"StatefulPartitionedCall/model/reshape/strided_slice/stack_1","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_INT32","tensorShape":{"dim":[{"size":"1"}]}}},"dtype":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/reshape/Reshape/shape/1","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_INT32","tensorShape":{}}},"dtype":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/reshape/Reshape/shape/2","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_INT32","tensorShape":{}}},"dtype":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_11/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"88"},{"size":"1"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_12/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"96"},{"size":"1"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_13/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"96"},{"size":"1"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_14/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"96"},{"size":"1"}]}}}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_15/depthwise/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"3"},{"size":"3"},{"size":"96"},{"size":"1"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/classificator_16/Conv2D/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"96"},{"size":"6"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/classificator_16/BiasAdd/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"6"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/regressor_8/Conv2D/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"88"},{"size":"32"}]}}}}},{"name":"StatefulPartitionedCall/model/regressor_8/BiasAdd/ReadVariableOp","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"32"}]}}},"dtype":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/reshape_1/Reshape/shape/2","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_INT32","tensorShape":{}}},"dtype":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/regressor_16/Conv2D/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"1"},{"size":"1"},{"size":"96"},{"size":"96"}]}}}}},{"name":"StatefulPartitionedCall/model/regressor_16/BiasAdd/ReadVariableOp","op":"Const","input":["^input"],"attr":{"dtype":{"type":"DT_FLOAT"},"value":{"tensor":{"dtype":"DT_FLOAT","tensorShape":{"dim":[{"size":"96"}]}}}}},{"name":"StatefulPartitionedCall/model/objects/concat/axis","op":"Const","input":["^input"],"attr":{"value":{"tensor":{"dtype":"DT_INT32","tensorShape":{}}},"dtype":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/activation/Relu","op":"_FusedConv2D","input":["input","StatefulPartitionedCall/model/conv2d/Conv2D_weights","StatefulPartitionedCall/model/conv2d/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"U0FNRQ=="},"fused_ops":{"list":{"s":["Qmlhc0FkZA==","UmVsdQ=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","2","2","1"]}},"data_format":{"s":"TkhXQw=="},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation/Relu","StatefulPartitionedCall/model/depthwise_conv2d/depthwise/ReadVariableOp"],"attr":{"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"dilations":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_1/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d/depthwise","StatefulPartitionedCall/model/conv2d_1/Conv2D_weights","StatefulPartitionedCall/model/conv2d_1/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}}}},{"name":"StatefulPartitionedCall/model/add/add","op":"AddV2","input":["StatefulPartitionedCall/model/activation/Relu","StatefulPartitionedCall/model/batch_normalization_v1_1/FusedBatchNormV3"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_1/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding/Pad","op":"Pad","input":["StatefulPartitionedCall/model/activation_1/Relu","StatefulPartitionedCall/model/channel_padding/Pad/paddings"],"attr":{"Tpaddings":{"type":"DT_INT32"},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_1/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_1/Relu","StatefulPartitionedCall/model/depthwise_conv2d_1/depthwise/ReadVariableOp"],"attr":{"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"dilations":{"list":{"i":["1","1","1","1"]}}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_2/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_1/depthwise","StatefulPartitionedCall/model/conv2d_2/Conv2D_weights","StatefulPartitionedCall/model/conv2d_2/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}}}},{"name":"StatefulPartitionedCall/model/add_1/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_2/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_2/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_1/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/max_pooling2d/MaxPool","op":"MaxPool","input":["StatefulPartitionedCall/model/activation_2/Relu"],"attr":{"ksize":{"list":{"i":["1","2","2","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","2","2","1"]}},"data_format":{"s":"TkhXQw=="}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_2/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_2/Relu","StatefulPartitionedCall/model/depthwise_conv2d_2/depthwise/ReadVariableOp"],"attr":{"padding":{"s":"U0FNRQ=="},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","2","2","1"]}}}},{"name":"StatefulPartitionedCall/model/channel_padding_1/Pad","op":"Pad","input":["StatefulPartitionedCall/model/max_pooling2d/MaxPool","StatefulPartitionedCall/model/channel_padding/Pad/paddings"],"attr":{"T":{"type":"DT_FLOAT"},"Tpaddings":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_3/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_2/depthwise","StatefulPartitionedCall/model/conv2d_3/Conv2D_weights","StatefulPartitionedCall/model/conv2d_3/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true}}},{"name":"StatefulPartitionedCall/model/add_2/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_3/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_1/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_3/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_2/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding_2/Pad","op":"Pad","input":["StatefulPartitionedCall/model/activation_3/Relu","StatefulPartitionedCall/model/channel_padding/Pad/paddings"],"attr":{"T":{"type":"DT_FLOAT"},"Tpaddings":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_3/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_3/Relu","StatefulPartitionedCall/model/depthwise_conv2d_3/depthwise/ReadVariableOp"],"attr":{"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_4/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_3/depthwise","StatefulPartitionedCall/model/conv2d_4/Conv2D_weights","StatefulPartitionedCall/model/conv2d_4/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="}}},{"name":"StatefulPartitionedCall/model/add_3/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_4/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_2/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_4/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_3/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding_3/Pad","op":"Pad","input":["StatefulPartitionedCall/model/activation_4/Relu","StatefulPartitionedCall/model/channel_padding_3/Pad/paddings"],"attr":{"T":{"type":"DT_FLOAT"},"Tpaddings":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_4/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_4/Relu","StatefulPartitionedCall/model/depthwise_conv2d_4/depthwise/ReadVariableOp"],"attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_5/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_4/depthwise","StatefulPartitionedCall/model/conv2d_5/Conv2D_weights","StatefulPartitionedCall/model/conv2d_5/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/add_4/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_5/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_3/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_5/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_4/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/max_pooling2d_1/MaxPool","op":"MaxPool","input":["StatefulPartitionedCall/model/activation_5/Relu"],"attr":{"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","2","2","1"]}},"ksize":{"list":{"i":["1","2","2","1"]}},"padding":{"s":"U0FNRQ=="}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_5/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_5/Relu","StatefulPartitionedCall/model/depthwise_conv2d_5/depthwise/ReadVariableOp"],"attr":{"strides":{"list":{"i":["1","2","2","1"]}},"data_format":{"s":"TkhXQw=="},"dilations":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding_4/Pad","op":"Pad","input":["StatefulPartitionedCall/model/max_pooling2d_1/MaxPool","StatefulPartitionedCall/model/channel_padding_3/Pad/paddings"],"attr":{"Tpaddings":{"type":"DT_INT32"},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_6/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_5/depthwise","StatefulPartitionedCall/model/conv2d_6/Conv2D_weights","StatefulPartitionedCall/model/conv2d_6/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}}}},{"name":"StatefulPartitionedCall/model/add_5/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_6/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_4/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_6/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_5/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding_5/Pad","op":"Pad","input":["StatefulPartitionedCall/model/activation_6/Relu","StatefulPartitionedCall/model/channel_padding_5/Pad/paddings"],"attr":{"T":{"type":"DT_FLOAT"},"Tpaddings":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_6/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_6/Relu","StatefulPartitionedCall/model/depthwise_conv2d_6/depthwise/ReadVariableOp"],"attr":{"padding":{"s":"U0FNRQ=="},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_7/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_6/depthwise","StatefulPartitionedCall/model/conv2d_7/Conv2D_weights","StatefulPartitionedCall/model/conv2d_7/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}}}},{"name":"StatefulPartitionedCall/model/add_6/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_7/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_5/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_7/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_6/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding_6/Pad","op":"Pad","input":["StatefulPartitionedCall/model/activation_7/Relu","StatefulPartitionedCall/model/channel_padding_5/Pad/paddings"],"attr":{"T":{"type":"DT_FLOAT"},"Tpaddings":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_7/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_7/Relu","StatefulPartitionedCall/model/depthwise_conv2d_7/depthwise/ReadVariableOp"],"attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_8/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_7/depthwise","StatefulPartitionedCall/model/conv2d_8/Conv2D_weights","StatefulPartitionedCall/model/conv2d_8/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="}}},{"name":"StatefulPartitionedCall/model/add_7/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_8/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_6/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_8/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_7/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding_7/Pad","op":"Pad","input":["StatefulPartitionedCall/model/activation_8/Relu","StatefulPartitionedCall/model/channel_padding_5/Pad/paddings"],"attr":{"T":{"type":"DT_FLOAT"},"Tpaddings":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_8/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_8/Relu","StatefulPartitionedCall/model/depthwise_conv2d_8/depthwise/ReadVariableOp"],"attr":{"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="},"dilations":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_9/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_8/depthwise","StatefulPartitionedCall/model/conv2d_9/Conv2D_weights","StatefulPartitionedCall/model/conv2d_9/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="}}},{"name":"StatefulPartitionedCall/model/add_8/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_9/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_7/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_9/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_8/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding_8/Pad","op":"Pad","input":["StatefulPartitionedCall/model/activation_9/Relu","StatefulPartitionedCall/model/channel_padding_5/Pad/paddings"],"attr":{"T":{"type":"DT_FLOAT"},"Tpaddings":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_9/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_9/Relu","StatefulPartitionedCall/model/depthwise_conv2d_9/depthwise/ReadVariableOp"],"attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_10/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_9/depthwise","StatefulPartitionedCall/model/conv2d_10/Conv2D_weights","StatefulPartitionedCall/model/conv2d_10/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/add_9/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_10/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_8/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_10/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_9/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/channel_padding_9/Pad","op":"Pad","input":["StatefulPartitionedCall/model/activation_10/Relu","StatefulPartitionedCall/model/channel_padding_5/Pad/paddings"],"attr":{"Tpaddings":{"type":"DT_INT32"},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_10/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_10/Relu","StatefulPartitionedCall/model/depthwise_conv2d_10/depthwise/ReadVariableOp"],"attr":{"padding":{"s":"U0FNRQ=="},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_11/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_10/depthwise","StatefulPartitionedCall/model/conv2d_11/Conv2D_weights","StatefulPartitionedCall/model/conv2d_11/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}}}},{"name":"StatefulPartitionedCall/model/add_10/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_11/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_9/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_11/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_10/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/max_pooling2d_2/MaxPool","op":"MaxPool","input":["StatefulPartitionedCall/model/activation_11/Relu"],"attr":{"ksize":{"list":{"i":["1","2","2","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","2","2","1"]}},"data_format":{"s":"TkhXQw=="}}},{"name":"StatefulPartitionedCall/model/classificator_8/BiasAdd","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/activation_11/Relu","StatefulPartitionedCall/model/classificator_8/Conv2D/ReadVariableOp","StatefulPartitionedCall/model/classificator_8/BiasAdd/ReadVariableOp"],"device":"/device:CPU:0","attr":{"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"U0FNRQ=="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_11/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_11/Relu","StatefulPartitionedCall/model/depthwise_conv2d_11/depthwise/ReadVariableOp"],"attr":{"padding":{"s":"U0FNRQ=="},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","2","2","1"]}}}},{"name":"StatefulPartitionedCall/model/regressor_8/BiasAdd","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/activation_11/Relu","StatefulPartitionedCall/model/regressor_8/Conv2D/ReadVariableOp","StatefulPartitionedCall/model/regressor_8/BiasAdd/ReadVariableOp"],"device":"/device:CPU:0","attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"U0FNRQ=="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}}}},{"name":"StatefulPartitionedCall/model/channel_padding_10/Pad","op":"Pad","input":["StatefulPartitionedCall/model/max_pooling2d_2/MaxPool","StatefulPartitionedCall/model/channel_padding_5/Pad/paddings"],"attr":{"Tpaddings":{"type":"DT_INT32"},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/reshape/Shape","op":"Shape","input":["StatefulPartitionedCall/model/classificator_8/BiasAdd"],"attr":{"T":{"type":"DT_FLOAT"},"out_type":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_12/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_11/depthwise","StatefulPartitionedCall/model/conv2d_12/Conv2D_weights","StatefulPartitionedCall/model/conv2d_12/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}}}},{"name":"StatefulPartitionedCall/model/reshape_1/Shape","op":"Shape","input":["StatefulPartitionedCall/model/regressor_8/BiasAdd"],"attr":{"T":{"type":"DT_FLOAT"},"out_type":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/reshape/strided_slice","op":"StridedSlice","input":["StatefulPartitionedCall/model/reshape/Shape","StatefulPartitionedCall/model/reshape/strided_slice/stack","StatefulPartitionedCall/model/reshape/strided_slice/stack_1","StatefulPartitionedCall/model/reshape/strided_slice/stack_1"],"attr":{"T":{"type":"DT_INT32"},"Index":{"type":"DT_INT32"},"shrink_axis_mask":{"i":"1"},"begin_mask":{"i":"0"},"ellipsis_mask":{"i":"0"},"new_axis_mask":{"i":"0"},"end_mask":{"i":"0"}}},{"name":"StatefulPartitionedCall/model/add_11/add","op":"AddV2","input":["StatefulPartitionedCall/model/batch_normalization_v1_12/FusedBatchNormV3","StatefulPartitionedCall/model/channel_padding_10/Pad"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/reshape_1/strided_slice","op":"StridedSlice","input":["StatefulPartitionedCall/model/reshape_1/Shape","StatefulPartitionedCall/model/reshape/strided_slice/stack","StatefulPartitionedCall/model/reshape/strided_slice/stack_1","StatefulPartitionedCall/model/reshape/strided_slice/stack_1"],"attr":{"shrink_axis_mask":{"i":"1"},"begin_mask":{"i":"0"},"ellipsis_mask":{"i":"0"},"new_axis_mask":{"i":"0"},"end_mask":{"i":"0"},"T":{"type":"DT_INT32"},"Index":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/reshape/Reshape/shape","op":"Pack","input":["StatefulPartitionedCall/model/reshape/strided_slice","StatefulPartitionedCall/model/reshape/Reshape/shape/1","StatefulPartitionedCall/model/reshape/Reshape/shape/2"],"attr":{"T":{"type":"DT_INT32"},"axis":{"i":"0"},"N":{"i":"3"}}},{"name":"StatefulPartitionedCall/model/activation_12/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_11/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/reshape_1/Reshape/shape","op":"Pack","input":["StatefulPartitionedCall/model/reshape_1/strided_slice","StatefulPartitionedCall/model/reshape/Reshape/shape/1","StatefulPartitionedCall/model/reshape_1/Reshape/shape/2"],"attr":{"T":{"type":"DT_INT32"},"axis":{"i":"0"},"N":{"i":"3"}}},{"name":"StatefulPartitionedCall/model/reshape/Reshape","op":"Reshape","input":["StatefulPartitionedCall/model/classificator_8/BiasAdd","StatefulPartitionedCall/model/reshape/Reshape/shape"],"attr":{"T":{"type":"DT_FLOAT"},"Tshape":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_12/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_12/Relu","StatefulPartitionedCall/model/depthwise_conv2d_12/depthwise/ReadVariableOp"],"attr":{"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/reshape_1/Reshape","op":"Reshape","input":["StatefulPartitionedCall/model/regressor_8/BiasAdd","StatefulPartitionedCall/model/reshape_1/Reshape/shape"],"attr":{"T":{"type":"DT_FLOAT"},"Tshape":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_13/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_12/depthwise","StatefulPartitionedCall/model/conv2d_13/Conv2D_weights","StatefulPartitionedCall/model/conv2d_13/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}},"num_args":{"i":"1"}}},{"name":"StatefulPartitionedCall/model/add_12/add","op":"AddV2","input":["StatefulPartitionedCall/model/activation_12/Relu","StatefulPartitionedCall/model/batch_normalization_v1_13/FusedBatchNormV3"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_13/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_12/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_13/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_13/Relu","StatefulPartitionedCall/model/depthwise_conv2d_13/depthwise/ReadVariableOp"],"attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_14/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_13/depthwise","StatefulPartitionedCall/model/conv2d_14/Conv2D_weights","StatefulPartitionedCall/model/conv2d_14/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}}}},{"name":"StatefulPartitionedCall/model/add_13/add","op":"AddV2","input":["StatefulPartitionedCall/model/activation_13/Relu","StatefulPartitionedCall/model/batch_normalization_v1_14/FusedBatchNormV3"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_14/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_13/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_14/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_14/Relu","StatefulPartitionedCall/model/depthwise_conv2d_14/depthwise/ReadVariableOp"],"attr":{"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="},"padding":{"s":"U0FNRQ=="},"dilations":{"list":{"i":["1","1","1","1"]}}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_15/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_14/depthwise","StatefulPartitionedCall/model/conv2d_15/Conv2D_weights","StatefulPartitionedCall/model/conv2d_15/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}}}},{"name":"StatefulPartitionedCall/model/add_14/add","op":"AddV2","input":["StatefulPartitionedCall/model/activation_14/Relu","StatefulPartitionedCall/model/batch_normalization_v1_15/FusedBatchNormV3"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_15/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_14/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_15/depthwise","op":"DepthwiseConv2dNative","input":["StatefulPartitionedCall/model/activation_15/Relu","StatefulPartitionedCall/model/depthwise_conv2d_15/depthwise/ReadVariableOp"],"attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"padding":{"s":"U0FNRQ=="},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}}}},{"name":"StatefulPartitionedCall/model/batch_normalization_v1_16/FusedBatchNormV3","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/depthwise_conv2d_15/depthwise","StatefulPartitionedCall/model/conv2d_16/Conv2D_weights","StatefulPartitionedCall/model/conv2d_16/Conv2D_bn_offset"],"device":"/device:CPU:0","attr":{"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"explicit_paddings":{"list":{}},"use_cudnn_on_gpu":{"b":true},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"VkFMSUQ="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}}}},{"name":"StatefulPartitionedCall/model/add_15/add","op":"AddV2","input":["StatefulPartitionedCall/model/activation_15/Relu","StatefulPartitionedCall/model/batch_normalization_v1_16/FusedBatchNormV3"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/activation_16/Relu","op":"Relu","input":["StatefulPartitionedCall/model/add_15/add"],"attr":{"T":{"type":"DT_FLOAT"}}},{"name":"StatefulPartitionedCall/model/classificator_16/BiasAdd","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/activation_16/Relu","StatefulPartitionedCall/model/classificator_16/Conv2D/ReadVariableOp","StatefulPartitionedCall/model/classificator_16/BiasAdd/ReadVariableOp"],"device":"/device:CPU:0","attr":{"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"U0FNRQ=="},"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"data_format":{"s":"TkhXQw=="},"strides":{"list":{"i":["1","1","1","1"]}},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}}}},{"name":"StatefulPartitionedCall/model/regressor_16/BiasAdd","op":"_FusedConv2D","input":["StatefulPartitionedCall/model/activation_16/Relu","StatefulPartitionedCall/model/regressor_16/Conv2D/ReadVariableOp","StatefulPartitionedCall/model/regressor_16/BiasAdd/ReadVariableOp"],"device":"/device:CPU:0","attr":{"fused_ops":{"list":{"s":["Qmlhc0FkZA=="]}},"dilations":{"list":{"i":["1","1","1","1"]}},"T":{"type":"DT_FLOAT"},"strides":{"list":{"i":["1","1","1","1"]}},"data_format":{"s":"TkhXQw=="},"use_cudnn_on_gpu":{"b":true},"explicit_paddings":{"list":{}},"num_args":{"i":"1"},"epsilon":{"f":0},"padding":{"s":"U0FNRQ=="}}},{"name":"StatefulPartitionedCall/model/reshape_2/Shape","op":"Shape","input":["StatefulPartitionedCall/model/classificator_16/BiasAdd"],"attr":{"T":{"type":"DT_FLOAT"},"out_type":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/reshape_3/Shape","op":"Shape","input":["StatefulPartitionedCall/model/regressor_16/BiasAdd"],"attr":{"T":{"type":"DT_FLOAT"},"out_type":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/reshape_2/strided_slice","op":"StridedSlice","input":["StatefulPartitionedCall/model/reshape_2/Shape","StatefulPartitionedCall/model/reshape/strided_slice/stack","StatefulPartitionedCall/model/reshape/strided_slice/stack_1","StatefulPartitionedCall/model/reshape/strided_slice/stack_1"],"attr":{"shrink_axis_mask":{"i":"1"},"begin_mask":{"i":"0"},"ellipsis_mask":{"i":"0"},"new_axis_mask":{"i":"0"},"end_mask":{"i":"0"},"Index":{"type":"DT_INT32"},"T":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/reshape_3/strided_slice","op":"StridedSlice","input":["StatefulPartitionedCall/model/reshape_3/Shape","StatefulPartitionedCall/model/reshape/strided_slice/stack","StatefulPartitionedCall/model/reshape/strided_slice/stack_1","StatefulPartitionedCall/model/reshape/strided_slice/stack_1"],"attr":{"T":{"type":"DT_INT32"},"Index":{"type":"DT_INT32"},"shrink_axis_mask":{"i":"1"},"ellipsis_mask":{"i":"0"},"begin_mask":{"i":"0"},"new_axis_mask":{"i":"0"},"end_mask":{"i":"0"}}},{"name":"StatefulPartitionedCall/model/reshape_2/Reshape/shape","op":"Pack","input":["StatefulPartitionedCall/model/reshape_2/strided_slice","StatefulPartitionedCall/model/reshape/Reshape/shape/1","StatefulPartitionedCall/model/reshape/Reshape/shape/2"],"attr":{"T":{"type":"DT_INT32"},"axis":{"i":"0"},"N":{"i":"3"}}},{"name":"StatefulPartitionedCall/model/reshape_3/Reshape/shape","op":"Pack","input":["StatefulPartitionedCall/model/reshape_3/strided_slice","StatefulPartitionedCall/model/reshape/Reshape/shape/1","StatefulPartitionedCall/model/reshape_1/Reshape/shape/2"],"attr":{"T":{"type":"DT_INT32"},"axis":{"i":"0"},"N":{"i":"3"}}},{"name":"StatefulPartitionedCall/model/reshape_2/Reshape","op":"Reshape","input":["StatefulPartitionedCall/model/classificator_16/BiasAdd","StatefulPartitionedCall/model/reshape_2/Reshape/shape"],"attr":{"T":{"type":"DT_FLOAT"},"Tshape":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/reshape_3/Reshape","op":"Reshape","input":["StatefulPartitionedCall/model/regressor_16/BiasAdd","StatefulPartitionedCall/model/reshape_3/Reshape/shape"],"attr":{"T":{"type":"DT_FLOAT"},"Tshape":{"type":"DT_INT32"}}},{"name":"StatefulPartitionedCall/model/classificators/concat","op":"ConcatV2","input":["StatefulPartitionedCall/model/reshape/Reshape","StatefulPartitionedCall/model/reshape_2/Reshape","StatefulPartitionedCall/model/reshape/Reshape/shape/2"],"attr":{"Tidx":{"type":"DT_INT32"},"T":{"type":"DT_FLOAT"},"N":{"i":"2"}}},{"name":"StatefulPartitionedCall/model/regressors/concat","op":"ConcatV2","input":["StatefulPartitionedCall/model/reshape_1/Reshape","StatefulPartitionedCall/model/reshape_3/Reshape","StatefulPartitionedCall/model/reshape/Reshape/shape/2"],"attr":{"Tidx":{"type":"DT_INT32"},"T":{"type":"DT_FLOAT"},"N":{"i":"2"}}},{"name":"StatefulPartitionedCall/model/objects/concat","op":"ConcatV2","input":["StatefulPartitionedCall/model/classificators/concat","StatefulPartitionedCall/model/regressors/concat","StatefulPartitionedCall/model/objects/concat/axis"],"attr":{"T":{"type":"DT_FLOAT"},"N":{"i":"2"},"Tidx":{"type":"DT_INT32"}}},{"name":"Identity","op":"Identity","input":["StatefulPartitionedCall/model/objects/concat"],"attr":{"T":{"type":"DT_FLOAT"}}}],"versions":{"producer":134,"minConsumer":12}},"zY":[{"W":[{"name":"StatefulPartitionedCall/model/conv2d/Conv2D_weights","shape":[5,5,3,24],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_16/Conv2D_weights","shape":[1,1,96,96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d/Conv2D_bn_offset","shape":[24],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_1/Conv2D_weights","shape":[1,1,24,24],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_16/Conv2D_bn_offset","shape":[96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_1/Conv2D_bn_offset","shape":[24],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_2/Conv2D_weights","shape":[1,1,24,28],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_2/Conv2D_bn_offset","shape":[28],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_3/Conv2D_weights","shape":[1,1,28,32],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_3/Conv2D_bn_offset","shape":[32],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_4/Conv2D_weights","shape":[1,1,32,36],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_4/Conv2D_bn_offset","shape":[36],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_5/Conv2D_weights","shape":[1,1,36,42],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_5/Conv2D_bn_offset","shape":[42],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_6/Conv2D_weights","shape":[1,1,42,48],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_6/Conv2D_bn_offset","shape":[48],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_7/Conv2D_weights","shape":[1,1,48,56],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_7/Conv2D_bn_offset","shape":[56],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_8/Conv2D_weights","shape":[1,1,56,64],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_8/Conv2D_bn_offset","shape":[64],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_9/Conv2D_weights","shape":[1,1,64,72],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_9/Conv2D_bn_offset","shape":[72],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_10/Conv2D_weights","shape":[1,1,72,80],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_10/Conv2D_bn_offset","shape":[80],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_11/Conv2D_weights","shape":[1,1,80,88],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_11/Conv2D_bn_offset","shape":[88],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_12/Conv2D_weights","shape":[1,1,88,96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_12/Conv2D_bn_offset","shape":[96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_13/Conv2D_weights","shape":[1,1,96,96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_13/Conv2D_bn_offset","shape":[96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_14/Conv2D_weights","shape":[1,1,96,96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_14/Conv2D_bn_offset","shape":[96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_15/Conv2D_weights","shape":[1,1,96,96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/conv2d_15/Conv2D_bn_offset","shape":[96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d/depthwise/ReadVariableOp","shape":[3,3,24,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/channel_padding/Pad/paddings","shape":[4,2],"dtype":"int32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_1/depthwise/ReadVariableOp","shape":[3,3,24,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_2/depthwise/ReadVariableOp","shape":[3,3,28,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_3/depthwise/ReadVariableOp","shape":[3,3,32,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/channel_padding_3/Pad/paddings","shape":[4,2],"dtype":"int32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_4/depthwise/ReadVariableOp","shape":[3,3,36,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_5/depthwise/ReadVariableOp","shape":[3,3,42,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/channel_padding_5/Pad/paddings","shape":[4,2],"dtype":"int32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_6/depthwise/ReadVariableOp","shape":[3,3,48,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_7/depthwise/ReadVariableOp","shape":[3,3,56,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_8/depthwise/ReadVariableOp","shape":[3,3,64,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_9/depthwise/ReadVariableOp","shape":[3,3,72,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_10/depthwise/ReadVariableOp","shape":[3,3,80,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/classificator_8/Conv2D/ReadVariableOp","shape":[1,1,88,2],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/classificator_8/BiasAdd/ReadVariableOp","shape":[2],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/reshape/strided_slice/stack","shape":[1],"dtype":"int32"},{"name":"StatefulPartitionedCall/model/reshape/strided_slice/stack_1","shape":[1],"dtype":"int32"},{"name":"StatefulPartitionedCall/model/reshape/Reshape/shape/1","shape":[],"dtype":"int32"},{"name":"StatefulPartitionedCall/model/reshape/Reshape/shape/2","shape":[],"dtype":"int32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_11/depthwise/ReadVariableOp","shape":[3,3,88,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_12/depthwise/ReadVariableOp","shape":[3,3,96,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_13/depthwise/ReadVariableOp","shape":[3,3,96,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_14/depthwise/ReadVariableOp","shape":[3,3,96,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/depthwise_conv2d_15/depthwise/ReadVariableOp","shape":[3,3,96,1],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/classificator_16/Conv2D/ReadVariableOp","shape":[1,1,96,6],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/classificator_16/BiasAdd/ReadVariableOp","shape":[6],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/regressor_8/Conv2D/ReadVariableOp","shape":[1,1,88,32],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/regressor_8/BiasAdd/ReadVariableOp","shape":[32],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/reshape_1/Reshape/shape/2","shape":[],"dtype":"int32"},{"name":"StatefulPartitionedCall/model/regressor_16/Conv2D/ReadVariableOp","shape":[1,1,96,96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/regressor_16/BiasAdd/ReadVariableOp","shape":[96],"dtype":"float32"},{"name":"StatefulPartitionedCall/model/objects/concat/axis","shape":[],"dtype":"int32"}]}]}'),Lb="iproov-assets/5.4.4/bin/group1-shard1of1.bin",zb="iproov-assets/5.4.4/bin/tfjs-backend-wasm-simd.wasm",Vb="iproov-assets/5.4.4/bin/tfjs-backend-wasm-threaded-simd.wasm",Bb="iproov-assets/5.4.4/bin/tfjs-backend-wasm.wasm";class Ub extends Error{constructor(t,e){super(t),this.isRecoverable=!1,this.isPermission=!1,this.internalCode=e||t,this.feedback=this.code=t}reason(t){t(this.code)}}class Wb extends Ub{constructor(){super("error_asset_fetch",arguments.length>0&&void 0!==arguments[0]?arguments[0]:"")}}async function jb(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e3,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:3;a=Math.max(1,a);try{return await fetch(t,e)}catch(s){return new Promise(((s,o)=>{setTimeout((()=>{if(--a,0===a){const t=n||new Wb;return o(t)}s(jb(t,e,n,r,a))}),r)}))}}let qb;self.addEventListener("message",(function(t){const{cmd:e,payload:n}=t.data;return"loadModels"===e?async function(t){const{assetBaseUrl:e,inputWidth:n,inputHeight:r,scoreThreshold:a,iouThreshold:s,maxFaces:o}=t,i=performance.now();try{const t=await jb(e+Lb,{},new Wb);if(!t.ok)throw new Wb;const l=await t.arrayBuffer();X().set("WASM_HAS_MULTITHREAD_SUPPORT",!1),function(t,e=!1){if(kb)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof t)Nb=t;else{xb=t;const e=Tb.filter((t=>null==xb[t]));if(e.length>0)throw new Error(`There were no entries found for the following binaries: ${e.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Cb=e}({"tfjs-backend-wasm.wasm":e+Bb,"tfjs-backend-wasm-simd.wasm":e+zb,"tfjs-backend-wasm-threaded-simd.wasm":e+Vb},!1),await(u="wasm",Rr.setBackend(u));const c=Ls({modelTopology:Mb.vS,weightSpecs:Mb.zY[0].W,weightData:l,format:Mb.GP,generatedBy:Mb.BH,convertedBy:Mb.e2,userDefinedMetadata:Mb.Q8}),d=new Pp(c);await d.load(),qb=new Ib(d,n,r,o,s,a),postMessage({exec:"loadModels",payload:{}}),postMessage({exec:"log",payload:`Models loaded in ${Math.round(performance.now()-i)}ms`})}catch(t){postMessage({exec:"error",payload:{ctor:t.constructor.name,message:t.message}}),setTimeout((()=>{throw t}))}var u}(n):"setupOutputPort"===e?function(t){self.outputPort=t.messagePort}(n):"engineDetect"===e?async function(t){const{buffer:e,width:n,height:r,channels:a,frameType:s}=t,o=new ImageData(new Uint8ClampedArray(e),n,r);try{const t=await qb.estimateFaces(o,!1);if(postMessage({exec:"engineDetect",payload:{predictions:t}}),self.outputPort&&null!==s&&t.length){const a=t[0];self.outputPort.postMessage({cmd:"featureDetection",payload:{frameType:s,width:n,height:r,buffer:e,feature:a}},[e])}}catch(t){postMessage({exec:"error",payload:t.message}),setTimeout((()=>{throw t}))}}(n):"terminate"===e?async function(){qb=null}():void 0}))})()})();